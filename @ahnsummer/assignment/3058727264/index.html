<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@ahnsummer/" data-discover="true">ahnsummer<!-- --> 님의 상세페이지</a> ＞ <!-- -->[4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter3-2/pull/22" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->ahnsummer</span><span>2025.12.01</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제의-핵심취지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제의-핵심취지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제의 핵심취지</h2>
<ul>
<li>React의 hook 이해하기</li>
<li>함수형 프로그래밍에 대한 이해</li>
<li>액션과 순수함수의 분리</li>
</ul>
<h2 id="과제에서-꼭-알아가길-바라는-점"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제에서-꼭-알아가길-바라는-점"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제에서 꼭 알아가길 바라는 점</h2>
<ul>
<li>엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup</li>
<li>엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()</li>
<li>엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등</li>
<li>엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart) vs capaitalize(str)</li>
</ul>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<ul class="contains-task-list">
<li>
<p>Component에서 비즈니스 로직을 분리하기</p>
</li>
<li>
<p>비즈니스 로직에서 특정 엔티티만 다루는 계산을 분리하기</p>
</li>
<li>
<p>뷰데이터와 엔티티데이터의 분리에 대한 이해</p>
</li>
<li>
<p>entities -&gt; features -&gt; UI 계층에 대한 이해</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 함수는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 Component와 UI를 다루는 Component는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 데이터 흐름에 맞는 계층구조를 이루고 의존성이 맞게 작성이 되었나요?</p>
</li>
</ul>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<ul class="contains-task-list">
<li>
<p>이번 심화과제는 Context나 Jotai를 사용해서 Props drilling을 없애는 것입니다.</p>
</li>
<li>
<p>어떤 props는 남겨야 하는지, 어떤 props는 제거해야 하는지에 대한 기준을 세워보세요.</p>
</li>
<li>
<p>Context나 Jotai를 사용하여 상태를 관리하는 방법을 익히고, 이를 통해 컴포넌트 간의 데이터 전달을 효율적으로 처리할 수 있습니다.</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Context나 Jotai를 사용해서 전역상태관리를 구축했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전역상태관리를 통해 domain custom hook을 적절하게 리팩토링 했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 도메인 컴포넌트에 도메인 props는 남기고 props drilling을 유발하는 불필요한 props는 잘 제거했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전체적으로 분리와 재조립이 더 수월해진 결합도가 낮아진 코드가 되었나요?</p>
</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p><a href="https://ahnsummer.github.io/front_7th_chapter3-2/">배포 링크</a></p>
<!-- -->
<h3 id="설계-관점에서-중점적으로-진행한-부분"><a class="anchor" aria-hidden="true" tabindex="-1" href="#설계-관점에서-중점적으로-진행한-부분"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>설계 관점에서 중점적으로 진행한 부분</h3>
<p>이번 과제에서 가장 중점적으로 신경 쓴 부분은 <strong>각 도메인에 대한 서비스 객체를 제공하여 가독성과 사용성 측면에서 이점을 누리고자 한 설계</strong>입니다. Context를 통해 단순히 데이터와 함수를 제공하는 것이 아니라, 각 엔티티가 자신의 동작을 메서드로 가지는 인스턴스 객체를 제공하는 방식으로 구현했습니다.</p>
<h4 id="서비스-객체-패턴-적용-전후-비교"><a class="anchor" aria-hidden="true" tabindex="-1" href="#서비스-객체-패턴-적용-전후-비교"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>서비스 객체 패턴 적용 전후 비교</h4>
<p><strong>1. 장바구니 아이템 수량 업데이트</strong></p>
<p><strong>적용 전:</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleIncrease</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">updateCartItemQuantity</span><span class="token punctuation">(</span>cart<span class="token punctuation">,</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>id<span class="token punctuation">,</span> item<span class="token punctuation">.</span>quantity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 또는 더 복잡한 경우</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleIncrease</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> newCart <span class="token operator">=</span> cart<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cartItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
</span><span class="code-line">    cartItem<span class="token punctuation">.</span>product<span class="token punctuation">.</span>id <span class="token operator">===</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>id
</span><span class="code-line">      <span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token operator">...</span>cartItem<span class="token punctuation">,</span> quantity<span class="token operator">:</span> cartItem<span class="token punctuation">.</span>quantity <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">:</span> cartItem
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">setCart</span><span class="token punctuation">(</span>newCart<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleIncrease = () =&gt; {
  updateCartItemQuantity(cart, item.product.id, item.quantity + 1);
};

// 또는 더 복잡한 경우
const handleIncrease = () =&gt; {
  const newCart = cart.map((cartItem) =&gt;
    cartItem.product.id === item.product.id
      ? { ...cartItem, quantity: cartItem.quantity + 1 }
      : cartItem
  );
  setCart(newCart);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>적용 후 (서비스 객체 패턴):</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleIncrease</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  item<span class="token punctuation">.</span><span class="token function">updateQuantity</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>quantity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleIncrease = () =&gt; {
  item.updateQuantity(item.quantity + 1);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>가독성 향상 효과:</strong></p>
<ul>
<li><code>item.updateQuantity()</code>를 보면 &quot;이 아이템의 수량을 업데이트한다&quot;는 의미가 메서드 이름에 그대로 드러납니다.</li>
<li>기존 방식의 접근에서는 <code>updateCartItemQuantity(cart, item.product.id, ...)</code>처럼 여러 인자를 전달해야 하고, &quot;어떤 장바구니의 어떤 아이템을&quot; 수정하는지 파악하기 위해 인자를 모두 읽어야 합니다.</li>
<li>서비스 객체 패턴에서는 <code>item</code>이라는 주체가 명확하므로, 메서드만 봐도 &quot;이 아이템에 대한 동작&quot;임을 즉시 알 수 있습니다.</li>
</ul>
<p><strong>2. 상품 가격 포맷팅</strong></p>
<p><strong>적용 전:</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> priceLabel <span class="token operator">=</span> <span class="token function">formatProductPrice</span><span class="token punctuation">(</span>product<span class="token punctuation">,</span> <span class="token punctuation">{</span>
</span><span class="code-line">  formatOptions<span class="token operator">:</span> <span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">&quot;prefix&quot;</span><span class="token punctuation">,</span> prefix<span class="token operator">:</span> <span class="token string">&quot;₩&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const priceLabel = formatProductPrice(product, {
  formatOptions: { type: &quot;prefix&quot;, prefix: &quot;₩&quot; },
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>적용 후 (서비스 객체 패턴):</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> priceLabel <span class="token operator">=</span> product<span class="token punctuation">.</span><span class="token function">priceLabel</span><span class="token punctuation">(</span><span class="token string">&quot;₩{price}&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const priceLabel = product.priceLabel(&quot;₩{price}&quot;);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>가독성 향상 효과:</strong></p>
<ul>
<li><code>product.priceLabel()</code>은 &quot;이 상품의 가격 레이블을 가져온다&quot;는 의미가 직관적입니다.</li>
<li>기존 접근에서는 <code>formatProductPrice(product, ...)</code>처럼 상품을 인자로 전달해야 하지만, 서비스 객체 패턴에서는 상품이 이미 주체이므로 메서드 호출만으로 충분합니다.</li>
<li>특히 <code>product.priceLabel()</code>은 &quot;상품이 자신의 가격을 포맷팅한다&quot;는 자연스러운 표현이 되어, 코드를 읽는 사람이 &quot;상품이 가격 정보를 제공한다&quot;는 도메인 개념을 바로 이해할 수 있습니다.</li>
</ul>
<p><strong>3. 장바구니 아이템 삭제</strong></p>
<p><strong>적용 전:</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleDelete</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">setCart</span><span class="token punctuation">(</span>cart<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>cartItem<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> cartItem<span class="token punctuation">.</span>product<span class="token punctuation">.</span>id <span class="token operator">!==</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleDelete = () =&gt; {
  setCart(cart.filter((cartItem) =&gt; cartItem.product.id !== item.product.id));
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>적용 후 (서비스 객체 패턴):</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleDelete</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  item<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleDelete = () =&gt; {
  item.delete();
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>가독성 향상 효과:</strong></p>
<ul>
<li><code>item.delete()</code>는 &quot;이 아이템을 삭제한다&quot;는 의미가 메서드 이름에 완벽하게 드러납니다.</li>
<li>함수형 접근에서는 <code>deleteCartItem(cart, item.product.id)</code>처럼 &quot;어떤 장바구니에서 어떤 아이템을&quot; 삭제하는지 명시해야 하지만, 서비스 객체 패턴에서는 <code>item</code>이 이미 자신의 컨텍스트를 알고 있으므로 메서드 호출만으로 충분합니다.</li>
<li>특히 <code>onDelete: () =&gt; item.delete()</code> 같은 코드를 보면, &quot;이 아이템을 삭제하는 핸들러&quot;라는 의미가 한눈에 들어옵니다.</li>
</ul>
<p><strong>4. 상품 수정</strong></p>
<p><strong>적용 전:</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleUpdate</span> <span class="token operator">=</span> <span class="token punctuation">(</span>updates<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>Product<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">setProducts</span><span class="token punctuation">(</span>
</span><span class="code-line">    products<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>id <span class="token operator">===</span> product<span class="token punctuation">.</span>id <span class="token operator">?</span> <span class="token punctuation">{</span> <span class="token operator">...</span>p<span class="token punctuation">,</span> <span class="token operator">...</span>updates <span class="token punctuation">}</span> <span class="token operator">:</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleUpdate = (updates: Partial&lt;Product&gt;) =&gt; {
  setProducts(
    products.map((p) =&gt; (p.id === product.id ? { ...p, ...updates } : p))
  );
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>적용 후 (서비스 객체 패턴):</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 컴포넌트에서 사용할 때</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">handleUpdate</span> <span class="token operator">=</span> <span class="token punctuation">(</span>updates<span class="token operator">:</span> Partial<span class="token operator">&lt;</span>Product<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  product<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>updates<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 컴포넌트에서 사용할 때
const handleUpdate = (updates: Partial&lt;Product&gt;) =&gt; {
  product.update(updates);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>가독성 향상 효과:</strong></p>
<ul>
<li><code>product.update(updates)</code>는 &quot;이 상품을 업데이트한다&quot;는 의미가 명확합니다.</li>
<li>기존 접근에서는 상품 목록 전체와 상품 ID를 전달해야 하지만, 서비스 객체 패턴에서는 상품이 자신의 ID를 알고 있으므로 업데이트할 내용만 전달하면 됩니다.</li>
<li>코드를 읽을 때 &quot;상품이 자신을 업데이트한다&quot;는 자연스러운 표현이 되어, 도메인 모델과 코드 표현이 일치합니다.</li>
</ul>
<h4 id="설계-의도와-효과"><a class="anchor" aria-hidden="true" tabindex="-1" href="#설계-의도와-효과"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>설계 의도와 효과</h4>
<p>이러한 서비스 객체 패턴을 적용한 이유는 다음과 같습니다:</p>
<ol>
<li>
<p><strong>의도 명확성</strong>: <code>item.updateQuantity(5)</code>를 보면 &quot;이 아이템의 수량을 5로 업데이트한다&quot;는 의도가 메서드 이름에 그대로 드러납니다. 반면 함수형 접근인 <code>updateCartItemQuantity(cart, itemId, 5)</code>는 여러 인자를 읽어야 의도를 파악할 수 있습니다.</p>
</li>
<li>
<p><strong>컨텍스트 내재화</strong>: 각 인스턴스가 자신의 데이터와 동작을 함께 가지고 있어, 외부에서 컨텍스트를 전달할 필요가 없습니다. 예를 들어 <code>item.delete()</code>는 <code>item</code>이 이미 자신이 어떤 장바구니에 속해있는지 알고 있으므로, 별도로 장바구니나 아이템 ID를 전달할 필요가 없습니다.</p>
</li>
<li>
<p><strong>도메인 모델과의 일치</strong>: &quot;장바구니 아이템이 자신의 수량을 업데이트한다&quot;는 도메인 개념이 코드에서 <code>item.updateQuantity()</code>로 자연스럽게 표현되어, 코드를 읽는 사람이 비즈니스 로직을 이해하기 쉬워집니다.</p>
</li>
<li>
<p><strong>코드 간결성</strong>: 함수형 접근에서는 여러 인자를 전달해야 하지만, 서비스 객체 패턴에서는 메서드 호출만으로 충분하여 코드가 간결해집니다.</p>
</li>
</ol>
<h4 id="객체지향과-함수형-프로그래밍의-멀티패러다임-접근"><a class="anchor" aria-hidden="true" tabindex="-1" href="#객체지향과-함수형-프로그래밍의-멀티패러다임-접근"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>객체지향과 함수형 프로그래밍의 멀티패러다임 접근</h4>
<p>서비스 객체 패턴을 적용하면서도, 내부적으로는 순수 함수를 적극적으로 활용하여 두 패러다임의 장점을 모두 가져가고자 했습니다.</p>
<p><strong>순수 함수와 비순수 함수의 구분 기준</strong></p>
<p>코드를 작성할 때 다음과 같은 기준으로 순수 함수와 비순수 함수를 구분했습니다:</p>
<ol>
<li>
<p><strong>순수 함수 (Pure Functions)</strong>: 계산 로직, 변환 로직</p>
<ul>
<li>입력에 대해 항상 같은 출력을 반환</li>
<li>사이드 이펙트 없음 (외부 상태 변경 없음)</li>
<li>예: <code>calculateItemTotalPrice</code>, <code>applyCouponToTotalPrice</code>, <code>getMaxApplicableDiscount</code>, <code>getRemainingStock</code>, <code>hasBulkPurchase</code></li>
</ul>
</li>
<li>
<p><strong>비순수 함수 (Impure Functions)</strong>: 상태 변경 로직</p>
<ul>
<li>상태를 변경하는 동작 (setState 호출)</li>
<li>예: <code>item.updateQuantity()</code>, <code>item.delete()</code>, <code>product.update()</code></li>
</ul>
</li>
</ol>
<p><strong>구체적인 구현 예시</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// CartContext.tsx에서 서비스 객체 생성</span>
</span><span class="code-line"><span class="token keyword">const</span> cartInstance<span class="token operator">:</span> CartItemInstance<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
</span><span class="code-line">    cart<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> idx<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token operator">...</span>item<span class="token punctuation">,</span>
</span><span class="code-line">      <span class="token comment">// 순수 함수를 사용하여 계산된 값들을 추가</span>
</span><span class="code-line">      totalPrice<span class="token operator">:</span> <span class="token function">calculateItemTotalPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> bulkPurchase<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 순수 함수</span>
</span><span class="code-line">      discountRate<span class="token operator">:</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>
</span><span class="code-line">        <span class="token function">getMaxApplicableDiscount</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> bulkPurchase<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token comment">// 순수 함수</span>
</span><span class="code-line">      <span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">      remainingStock<span class="token operator">:</span> <span class="token function">getRemainingStock</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 순수 함수</span>
</span><span class="code-line">
</span><span class="code-line">      <span class="token comment">// 비순수 함수: 상태를 변경하는 메서드</span>
</span><span class="code-line">      <span class="token function-variable function">updateQuantity</span><span class="token operator">:</span> <span class="token punctuation">(</span>newQuantity<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 검증 로직 (순수 함수로 분리 가능)</span>
</span><span class="code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>newQuantity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>newQuantity <span class="token operator">&gt;</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>stock<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">        <span class="token comment">// 상태 변경 (비순수)</span>
</span><span class="code-line">        <span class="token function">setCart</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">          <span class="token keyword">const</span> next <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>prev<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">          <span class="token keyword">if</span> <span class="token punctuation">(</span>newQuantity <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">            <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i <span class="token operator">!==</span> idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">          <span class="token punctuation">}</span>
</span><span class="code-line">          next<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>quantity <span class="token operator">=</span> newQuantity<span class="token punctuation">;</span>
</span><span class="code-line">          <span class="token keyword">return</span> next<span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">      <span class="token function-variable function">delete</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// 상태 변경 (비순수)</span>
</span><span class="code-line">        <span class="token function">setCart</span><span class="token punctuation">(</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prev<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i <span class="token operator">!==</span> idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">      <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">[</span>cart<span class="token punctuation">,</span> bulkPurchase<span class="token punctuation">,</span> setCart<span class="token punctuation">]</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// CartContext.tsx에서 서비스 객체 생성
const cartInstance: CartItemInstance[] = useMemo(
  () =&gt;
    cart.map((item, idx) =&gt; ({
      ...item,
      // 순수 함수를 사용하여 계산된 값들을 추가
      totalPrice: calculateItemTotalPrice(item, bulkPurchase), // 순수 함수
      discountRate: Math.round(
        getMaxApplicableDiscount(item, bulkPurchase) * 100 // 순수 함수
      ),
      remainingStock: getRemainingStock(item), // 순수 함수

      // 비순수 함수: 상태를 변경하는 메서드
      updateQuantity: (newQuantity: number) =&gt; {
        // 검증 로직 (순수 함수로 분리 가능)
        if (newQuantity &lt; 0) return false;
        if (newQuantity &gt; item.product.stock) return false;

        // 상태 변경 (비순수)
        setCart((prev) =&gt; {
          const next = [...prev];
          if (newQuantity === 0) {
            return next.filter((_, i) =&gt; i !== idx);
          }
          next[idx].quantity = newQuantity;
          return next;
        });
        return true;
      },
      delete: () =&gt; {
        // 상태 변경 (비순수)
        setCart((prev) =&gt; prev.filter((_, i) =&gt; i !== idx));
      },
    })),
  [cart, bulkPurchase, setCart]
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>멀티패러다임 접근의 이점</strong></p>
<ol>
<li>
<p><strong>테스트 용이성</strong>: 순수 함수는 독립적으로 테스트하기 쉽습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 순수 함수는 단위 테스트가 간단함</span>
</span><span class="code-line"><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">&quot;calculateItemTotalPrice&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&quot;should calculate total price with discount&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> item <span class="token operator">=</span> <span class="token punctuation">{</span> product<span class="token operator">:</span> <span class="token punctuation">{</span> price<span class="token operator">:</span> <span class="token number">1000</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> quantity<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">calculateItemTotalPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token function">expect</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 순수 함수는 단위 테스트가 간단함
describe(&quot;calculateItemTotalPrice&quot;, () =&gt; {
  it(&quot;should calculate total price with discount&quot;, () =&gt; {
    const item = { product: { price: 1000 }, quantity: 2 };
    const result = calculateItemTotalPrice(item, false);
    expect(result).toBe(2000);
  });
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>반면 <code>item.updateQuantity()</code> 같은 메서드는 React 상태 관리와 결합되어 있어 테스트가 복잡하지만, 내부에서 사용하는 순수 함수들은 쉽게 테스트할 수 있습니다.</p>
</li>
<li>
<p><strong>재사용성</strong>: 순수 함수는 다양한 컨텍스트에서 재사용할 수 있습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 같은 순수 함수를 다양한 곳에서 사용 가능</span>
</span><span class="code-line"><span class="token keyword">const</span> itemTotal <span class="token operator">=</span> <span class="token function">calculateItemTotalPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> bulkPurchase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> cartTotal <span class="token operator">=</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span>sum<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sum <span class="token operator">+</span> <span class="token function">calculateItemTotalPrice</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> bulkPurchase<span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token number">0</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 같은 순수 함수를 다양한 곳에서 사용 가능
const itemTotal = calculateItemTotalPrice(item, bulkPurchase);
const cartTotal = cart.reduce(
  (sum, item) =&gt; sum + calculateItemTotalPrice(item, bulkPurchase),
  0
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
<li>
<p><strong>가독성과 유지보수성의 균형</strong>:</p>
<ul>
<li>사용하는 입장에서는 <code>item.updateQuantity(5)</code>처럼 객체지향의 이점을 누립니다.</li>
<li>내부 구현에서는 <code>calculateItemTotalPrice(item, bulkPurchase)</code>처럼 순수 함수를 사용하여 로직이 명확하고 테스트하기 쉽습니다.</li>
</ul>
</li>
<li>
<p><strong>책임 분리</strong>:</p>
<ul>
<li>순수 함수는 &quot;무엇을 계산하는가&quot;에 집중 (비즈니스 로직)</li>
<li>비순수 함수는 &quot;어떻게 상태를 변경하는가&quot;에 집중 (상태 관리)</li>
<li>이렇게 분리하니 각 함수의 역할이 명확해지고, 비즈니스 로직을 변경할 때 상태 관리 코드를 건드릴 필요가 없습니다.</li>
</ul>
</li>
<li>
<p><strong>디버깅 용이성</strong>: 순수 함수는 입력과 출력이 명확하므로, 문제가 발생했을 때 어느 단계에서 문제가 생겼는지 추적하기 쉽습니다. 예를 들어 <code>totalPrice</code>가 잘못 계산되었다면, <code>calculateItemTotalPrice</code> 함수만 확인하면 됩니다.</p>
</li>
</ol>
<p><strong>설계 철학</strong></p>
<p>이러한 멀티패러다임 접근은 다음과 같은 철학을 따릅니다:</p>
<ul>
<li><strong>외부 인터페이스는 객체지향</strong>: 사용하는 입장에서는 객체의 메서드를 호출하는 것이 자연스럽고 읽기 쉽습니다.</li>
<li><strong>내부 구현은 함수형</strong>: 계산 로직은 순수 함수로 분리하여 테스트하고 재사용하기 쉽게 만듭니다.</li>
<li><strong>명확한 경계</strong>: 순수 함수와 비순수 함수를 명확히 구분하여, 각각의 장점을 최대한 활용합니다.</li>
</ul>
<p>이렇게 하면 객체지향의 가독성과 함수형의 테스트 용이성, 재사용성을 모두 가져갈 수 있습니다.</p>
<h3 id="과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제를 하면서 내가 알게된 점, 좋았던 점은 무엇인가요?</h3>
<ul>
<li>
<p><strong>멀티패러다임 프로그래밍의 가독성 효과</strong>: 함수형, 객체지향, 선언적 프로그래밍을 적절히 조합하여 코드 가독성을 크게 향상시킬 수 있었습니다.</p>
<ul>
<li><strong>함수형 패러다임 (순수 함수)</strong>: <code>calculateItemTotalPrice</code>, <code>applyCouponToTotalPrice</code>, <code>getMaxApplicableDiscount</code> 같은 계산 로직을 순수 함수로 분리하니, 입력과 출력이 명확해서 함수만 봐도 &quot;무엇을 하는지&quot; 즉시 이해할 수 있었습니다. 사이드 이펙트가 없어서 테스트하기도 쉽고, 함수 이름만 봐도 역할을 파악할 수 있어 코드를 읽는 시간이 단축되었습니다.</li>
<li><strong>객체지향 패러다임 (엔티티 인스턴스)</strong>: <code>CartItemInstance</code>, <code>ProductItemInstance</code>처럼 관련 데이터와 메서드를 하나의 객체로 묶으니, &quot;장바구니 아이템을 수정한다&quot;는 개념이 <code>item.updateQuantity()</code>, <code>item.delete()</code> 같은 메서드로 자연스럽게 표현되어 코드의 의도가 명확해졌습니다. 특히 <code>item.updateQuantity()</code>를 호출하는 코드를 보면 &quot;이 아이템의 수량을 업데이트한다&quot;는 의미가 바로 전달되어, 여러 파일을 오가며 로직을 추적할 필요가 없어졌습니다.</li>
<li><strong>선언적 패러다임 (React 컴포넌트)</strong>: 컴포넌트가 &quot;어떻게&quot;가 아닌 &quot;무엇을&quot; 렌더링하는지에 집중하니, JSX만 봐도 UI 구조를 한눈에 파악할 수 있었습니다. 예를 들어 <code>&lt;CartItemListSection items={cartItems} /&gt;</code>를 보면 &quot;장바구니 아이템 목록을 보여준다&quot;는 의도가 바로 드러나, 복잡한 DOM 조작 로직을 읽을 필요가 없어졌습니다.</li>
</ul>
</li>
<li>
<p><strong>Hook의 책임 분리</strong>: 컴포넌트에서 비즈니스 로직을 분리하여 hook으로 옮기니 컴포넌트가 훨씬 깔끔해지고 테스트하기 쉬워졌습니다. 특히 상태를 관리하는 <code>useProductForm</code>, <code>useCouponForm</code> 같은 hook들은 폼 관련 로직이 한 곳에 모여있어 유지보수가 편했습니다.</p>
</li>
<li>
<p><strong>Context를 통한 전역 상태 관리</strong>: Context API를 사용하여 <code>CartContext</code>, <code>ProductsContext</code>, <code>CouponsContext</code>를 만들면서 props drilling 문제를 해결했습니다. 각 도메인별로 Context를 분리하여 관심사 분리도 잘 되었고, 컴포넌트 트리에서 어디서든 필요한 상태에 접근할 수 있어 코드가 간결해졌습니다.</p>
</li>
<li>
<p><strong>도메인별 폴더 구조</strong>: <code>domains/cart</code>, <code>domains/products</code>, <code>domains/coupon</code>으로 도메인별로 폴더를 나누니 코드를 찾기 쉽고 유지보수가 편해졌습니다. 각 도메인의 Context, utils, hooks가 한 곳에 모여있어 관련 코드를 빠르게 찾을 수 있었습니다.</p>
</li>
</ul>
<h3 id="이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제에서 내가 제일 신경 쓴 부분은 무엇인가요?</h3>
<ol>
<li>
<p><strong>서비스 객체 패턴을 통한 가독성 향상</strong>: 각 도메인 엔티티(CartItem, Product 등)가 자신의 동작을 메서드로 가지는 인스턴스 객체를 제공하여, 코드의 의도를 명확하게 표현하고자 했습니다. <code>item.updateQuantity()</code>, <code>item.delete()</code>, <code>product.priceLabel()</code> 같은 메서드는 &quot;이 엔티티가 자신의 동작을 수행한다&quot;는 의미가 메서드 이름에 그대로 드러나, 함수형 접근(<code>updateCartItemQuantity(cart, itemId, ...)</code>)보다 훨씬 읽기 쉽고 이해하기 쉬웠습니다. 특히 컴포넌트에서 사용할 때 <code>onDelete: () =&gt; item.delete()</code> 같은 코드는 &quot;이 아이템을 삭제한다&quot;는 의도가 한눈에 들어와, 여러 파일을 오가며 로직을 추적할 필요가 없어졌습니다.</p>
</li>
<li>
<p><strong>멀티패러다임 프로그래밍을 통한 가독성 향상</strong>:</p>
<ul>
<li><strong>계산 로직은 순수 함수로</strong>: <code>calculateItemTotalPrice(item, hasBulkPurchase)</code> 같은 함수는 입력만 받아 결과를 반환하므로, 함수 시그니처만 봐도 &quot;장바구니 아이템과 대량 구매 여부를 받아 총액을 계산한다&quot;는 의미가 명확합니다. 함수 내부를 읽지 않아도 역할을 파악할 수 있어 가독성이 향상되었습니다.</li>
<li><strong>엔티티 동작은 인스턴스 메서드로</strong>: <code>item.updateQuantity(5)</code>를 보면 &quot;이 아이템의 수량을 5로 업데이트한다&quot;는 의미가 직관적으로 전달됩니다. 반면 함수형 스타일인 <code>updateCartItemQuantity(cart, itemId, 5)</code>보다 더 자연스럽고 읽기 쉬웠습니다. 특히 <code>item.delete()</code> 같은 메서드는 &quot;이 아이템을 삭제한다&quot;는 의도가 메서드 이름에 그대로 드러나 코드를 읽는 사람이 즉시 이해할 수 있었습니다.</li>
<li><strong>UI는 선언적으로</strong>: <code>&lt;CartItemListSection items={cartItems} /&gt;</code>처럼 컴포넌트를 선언적으로 사용하니, JSX만 봐도 &quot;장바구니 아이템 목록을 보여준다&quot;는 의도가 명확합니다. 복잡한 조건문이나 반복문을 읽을 필요 없이 구조를 한눈에 파악할 수 있어 가독성이 크게 향상되었습니다.</li>
</ul>
</li>
<li>
<p><strong>Hook은 상태 관리가 있을 때만 사용</strong>: 초기에는 모든 로직을 hook으로 분리하려 했지만, 상태를 관리하지 않는 단순 함수 호출(<code>usePurchase</code>, <code>useCouponSelection</code> 등)은 hook으로 만들 필요가 없다는 것을 깨달았습니다. 상태를 관리하는 <code>useProductForm</code>, <code>useCouponForm</code>만 hook으로 유지하니, hook의 역할이 명확해지고 코드가 더 간결해졌습니다.</p>
</li>
<li>
<p><strong>도메인 props vs UI props 구분</strong>: 도메인 컴포넌트(<code>CartItem</code>, <code>ProductCard</code>)에는 도메인 관련 props만 남기고, Context를 통해 전역 상태를 직접 접근하여 불필요한 props drilling을 제거했습니다. 이렇게 하니 컴포넌트가 받는 props가 줄어들어 컴포넌트의 책임이 명확해졌습니다.</p>
</li>
<li>
<p><strong>계산 함수의 순수성</strong>: 모든 계산 함수들이 사이드 이펙트 없이 입력에 대해 항상 같은 결과를 반환하도록 작성했습니다. 이렇게 하니 함수를 독립적으로 테스트할 수 있고, 함수의 역할을 이해하기 쉬워졌습니다.</p>
</li>
</ol>
<h3 id="이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제를 통해 앞으로 해보고 싶은게 있다면 알려주세요!</h3>
<ul>
<li><strong>lodash, es-toolkit과 같은 유틸리티 라이브러리의 적극적인 사용</strong>
함수형 프로그래밍에 대해 찾아보다보니 es-toolkit이나 lodash와 같은 유틸리티 라이브러리를 사용하면 의미가 더 명확한 코드를 더 간결하게 작성할 수 있을 것 같았습니다. 이러한 유틸리티 라이브러리에서 주로 사용되는 함수들에 대해 공부하고 실무에서 더 폭 넓게 활용해보고 싶습니다.</li>
</ul>
<h3 id="리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문 편하게 남겨주세요 :)</h3>
<ul>
<li>
<p><strong>멀티패러다임 프로그래밍의 적절성</strong>: 함수형(순수 함수), 객체지향(인스턴스 메서드), 선언적(React 컴포넌트) 패러다임을 함께 사용했는데, 각 패러다임을 언제 사용하는 것이 가장 적절한지 궁금합니다. 예를 들어 계산 로직은 순수 함수로, 엔티티의 동작은 인스턴스 메서드로 분리한 것이 가독성 측면에서 적절한 선택이었는지 의견이 궁금합니다. 특히, 각 도메인에 대한 훅이 service 객체를 제공함을 통해 객체지향의 이점을 가져와 사용하고자 하였는데 사용하는 입장에서 편리하다고 느껴지기는 하였으나 훅이 너무 거대하고 많은 역할을 하고 있는 것은 아닌 지 의문이 들기도 하였습니다.</p>
</li>
<li>
<p><strong>Hook 분리 기준</strong>: 컴포넌트에서 hook으로 로직을 분리할 때, 상태 관리가 없는 단순 함수 호출은 hook으로 만들지 않는 것이 맞다고 생각합니다. 하지만 데이터 변환 로직(<code>cart.list.map(...)</code>) 같은 경우는 컴포넌트에 두는 것이 맞는지, 아니면 별도의 함수로 분리하는 것이 맞는지 의견이 궁금합니다. 저는 우선 컴포넌트에 둔 경우가 많은데, 오히려 과도하게 분리하면 코드를 옮겨다니며 로직을 파악하는 게 어려워질 수 있다고 생각했기 때문입니다.</p>
</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>고생하셨습니다 소은님~
과제도 잘 진행해주셨고 회고도 아주 꼼꼼히 잘 정리해주셨네요.
적용해주신 패턴도 합리적인 이유로 잘 선택해주셨고 접근 방식도 좋았던 것 같아요 ㅎㅎ 명확하게 각 패턴들의 장단점을 이해하고 사용하려고 하시는 부분도 좋네요</p>
<blockquote>
<p>멀티패러다임 프로그래밍의 적절성</p>
</blockquote>
<p>예를 들어 계산 로직은 순수 함수로, 엔티티의 동작은 인스턴스 메서드로 분리한 것이 가독성 측면에서 적절한 선택이었는지 의견이 궁금합니다.
-&gt; 좋은 고민인데요..!  넵 좋은 방향이였다고 생각해요 ㅎㅎ 말씀대로 개발자 입장에서는 쓰기 좋은 방향인데, 훅이 너무 거대해진다는 단점이 생기는것 같아요. 이야기를 듣고 생각이 드는건 모델에 액션이 묶여있는 그 Rich Domain Model과 유사한데, 일반적으로는 데이터와 액션을 분리해서 관리하는걸 선호하는 것 같아요. (마치 리덕스처럼요) 훅이 너무 거대해진다면, 데이터와 업데이트 로직(행위)를 분리해서 관리하는것도 좋을 것 같아요!</p>
<p>(저는 지금은 별로 거대하고 복잡하게 느껴지진 않는것 같아요 ㅋㅋ)</p>
<blockquote>
<p>Hook 분리 기준</p>
</blockquote>
<p>넵 저도 동일한데요. 이 부분은 데이터 변환 로직이다보니.. 너무 과하게 분리되면 로직을 파악하게 어려울 수 있어서 적절한 기준을 만드는게 좋은 것 같아요. 너무 과도하게 복잡한 로직들은 분리하고, 컴포넌트 내부에 유지를 하는게 좋지 않을까 라고 생각이듭니다.</p>
<p>고생하셨고 담주도 화이팅입니다!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 안소은 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 안소은님이 제출한 [4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 안소은, [4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 안소은 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 안소은님이 제출한 [4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 안소은 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 안소은님이 제출한 [4팀 안소은] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
