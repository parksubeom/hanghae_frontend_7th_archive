<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@daehyunk1m/" data-discover="true">daehyunk1m<!-- --> 님의 상세페이지</a> ＞ <!-- -->[3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter4-2/pull/22" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->daehyunk1m</span><span>2025.12.22</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h1 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h1>
<h2 id="과제-배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 배포 링크</h2>
<ul>
<li><a href="https://daehyunk1m.github.io/front_7th_chapter4-2/">https://daehyunk1m.github.io/front_7th_chapter4-2/</a></li>
</ul>
<h2 id="과제-요구사항"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-요구사항"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 요구사항</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 배포 후 url 제출</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> API 호출 최적화(<code>Promise.all</code> 이해)</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 연산 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 리렌더링 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 시간표 블록 드래그시 렌더링 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 시간표 블록 드롭시 렌더링 최적화</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<h4 id="새로-학습한-개념"><a class="anchor" aria-hidden="true" tabindex="-1" href="#새로-학습한-개념"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>새로 학습한 개념</h4>
<p><strong>1. CQRS 패턴을 활용한 Context 최적화</strong></p>
<p>기존에는 하나의 Context에 상태와 업데이트 함수를 함께 제공했는데, 이 방식은 상태가 변경될 때마다 업데이트 함수만 필요한 컴포넌트도 리렌더링되는 문제가 있었습니다. CQRS(Command Query Responsibility Segregation) 패턴을 적용하여 Command Context(상태 업데이트)와 Query Context(상태 조회)를 분리했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// ScheduleContext.tsx - CQRS 패턴 적용</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleCommandContext <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>SetSchedulesMap <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleQueryContext <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>SchedulesMap <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useScheduleCommand</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ScheduleCommandContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useScheduleQuery</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useContext</span><span class="token punctuation">(</span>ScheduleQueryContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// ScheduleContext.tsx - CQRS 패턴 적용
const ScheduleCommandContext = createContext&lt;SetSchedulesMap | undefined&gt;(undefined);
const ScheduleQueryContext = createContext&lt;SchedulesMap | undefined&gt;(undefined);

export const useScheduleCommand = () =&gt; useContext(ScheduleCommandContext);
export const useScheduleQuery = () =&gt; useContext(ScheduleQueryContext);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이를 통해 <code>SearchDialog</code>와 <code>ScheduleDndProvider</code>는 <code>useScheduleCommand</code>만 구독하여 상태 변경 시 리렌더링되지 않고, 실제로 상태를 표시하는 <code>ScheduleTables</code>만 리렌더링되도록 최적화했습니다.</p>
<p><strong>2. 클로저를 활용한 API 캐싱 패턴</strong></p>
<p>클로저가 외부 변수를 &quot;기억&quot;하는 특성을 활용하여 API 응답을 캐싱하는 고차 함수를 구현했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// utils.ts - 클로저 캐싱</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> createCachedFetcher <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">fetcher</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>AxiosResponse<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">let</span> cache<span class="token operator">:</span> AxiosResponse<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 클로저로 캐시 유지</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>cache <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">;</span> <span class="token comment">// 캐시 히트</span>
</span><span class="code-line">    <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    cache <span class="token operator">=</span> data<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> cachedFetchMajors <span class="token operator">=</span> <span class="token function">createCachedFetcher</span><span class="token punctuation">(</span>fetchMajors<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> cachedFetchLiberalArts <span class="token operator">=</span> <span class="token function">createCachedFetcher</span><span class="token punctuation">(</span>fetchLiberalArts<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// utils.ts - 클로저 캐싱
export const createCachedFetcher = &lt;T&gt;(fetcher: () =&gt; Promise&lt;AxiosResponse&lt;T&gt;&gt;) =&gt; {
  let cache: AxiosResponse&lt;T&gt; | null = null; // 클로저로 캐시 유지

  return async () =&gt; {
    if (cache !== null) return cache; // 캐시 히트
    const data = await fetcher();
    cache = data;
    return data;
  };
};

// 사용
const cachedFetchMajors = createCachedFetcher(fetchMajors);
const cachedFetchLiberalArts = createCachedFetcher(fetchLiberalArts);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3. useDndContext 격리를 통한 드래그 성능 최적화</strong></p>
<p><code>@dnd-kit</code>의 <code>useDndContext</code>는 드래그 중 매 프레임마다 상태가 변경되어 구독하는 모든 컴포넌트가 리렌더링됩니다. 이를 해결하기 위해 Context를 사용하는 부분만 별도 컴포넌트로 분리했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// ScheduleTable.tsx - TableOutline 분리</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">TableOutline</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> tableId<span class="token punctuation">,</span> children <span class="token punctuation">}</span><span class="token operator">:</span> PropsWithChildren<span class="token operator">&lt;</span><span class="token punctuation">{</span> tableId<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> dndContext <span class="token operator">=</span> <span class="token function">useDndContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 이 컴포넌트만 드래그 중 리렌더링</span>
</span><span class="code-line">  <span class="token keyword">const</span> activeTableId <span class="token operator">=</span> <span class="token function">getActiveTableId</span><span class="token punctuation">(</span>dndContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Box outline<span class="token operator">=</span><span class="token punctuation">{</span>activeTableId <span class="token operator">===</span> tableId <span class="token operator">?</span> <span class="token string">&quot;5px dashed&quot;</span> <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span>children<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token comment">/* children은 리렌더링되지 않음 */</span><span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Box<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// ScheduleTable.tsx - TableOutline 분리
const TableOutline = ({ tableId, children }: PropsWithChildren&lt;{ tableId: string }&gt;) =&gt; {
  const dndContext = useDndContext(); // 이 컴포넌트만 드래그 중 리렌더링
  const activeTableId = getActiveTableId(dndContext);

  return (
    &lt;Box outline={activeTableId === tableId ? &quot;5px dashed&quot; : undefined}&gt;
      {children} {/* children은 리렌더링되지 않음 */}
    &lt;/Box&gt;
  );
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="기존-지식의-재발견심화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기존-지식의-재발견심화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기존 지식의 재발견/심화</h4>
<p><strong>useMemo/useCallback 선택적 적용의 중요성</strong></p>
<p>처음에는 &quot;모든 함수에 useCallback, 모든 계산에 useMemo를 적용하면 되겠지&quot;라고 생각했지만, 실제로는 메모이제이션 자체에도 비용(의존성 비교, 메모리 사용)이 발생합니다. 이 과제를 통해 다음 기준으로 선택적 적용의 중요성을 체감했습니다:</p>
<ul>
<li><strong>useMemo 적용 기준</strong>: 5단계 필터링 체인처럼 계산 비용이 높거나, 결과가 자식 컴포넌트의 props로 전달되는 경우</li>
<li><strong>useCallback 적용 기준</strong>: memo된 자식 컴포넌트에 전달되는 콜백이거나, 의존성 배열에 포함되는 함수</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// SearchDialog.tsx - 5단계 필터링은 useMemo 적용 가치 있음</span>
</span><span class="code-line"><span class="token keyword">const</span> filteredLectures <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> lectures
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token comment">/* 검색어 */</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token comment">/* 학년 */</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token comment">/* 전공 */</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token comment">/* 학점 */</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token comment">/* 요일/시간 */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchOptions<span class="token punctuation">,</span> lectures<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// SearchDialog.tsx - 5단계 필터링은 useMemo 적용 가치 있음
const filteredLectures = useMemo(() =&gt; {
  return lectures
    .filter(/* 검색어 */)
    .filter(/* 학년 */)
    .filter(/* 전공 */)
    .filter(/* 학점 */)
    .filter(/* 요일/시간 */);
}, [searchOptions, lectures]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>React.memo 커스텀 비교 함수</strong></p>
<p>기본 React.memo는 props를 얕은 비교를 통해 다름을 판단하는데, 객체 props의 경우 매번 새 참조가 생성되어 메모이제이션이 무력화될 수 있습니다. 커스텀 비교 함수로 실제로 비교가 필요한 값만 확인하도록 최적화했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// LectureItem.tsx - ID만 비교하는 커스텀 비교 함수</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> LectureItem <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token punctuation">{</span> lecture<span class="token punctuation">,</span> onClick <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">/* ... */</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> prev<span class="token punctuation">.</span>lecture<span class="token punctuation">.</span>id <span class="token operator">===</span> next<span class="token punctuation">.</span>lecture<span class="token punctuation">.</span>id <span class="token comment">// 같은 강의면 리렌더링 스킵</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// LectureItem.tsx - ID만 비교하는 커스텀 비교 함수
export const LectureItem = React.memo(
  ({ lecture, onClick }) =&gt; {
    /* ... */
  },
  (prev, next) =&gt; prev.lecture.id === next.lecture.id // 같은 강의면 리렌더링 스킵
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="구현-과정에서의-기술적-도전과-해결"><a class="anchor" aria-hidden="true" tabindex="-1" href="#구현-과정에서의-기술적-도전과-해결"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>구현 과정에서의 기술적 도전과 해결</h4>
<p><strong>문제</strong>: 드래그 중 시간표 전체가 리렌더링되어 버벅임 발생</p>
<p><strong>원인 분석</strong>: React DevTools Profiler로 확인한 결과, <code>useDndContext</code>를 사용하는 <code>ScheduleTable</code> 컴포넌트가 드래그 중 60fps로 리렌더링되고 있었습니다. <code>useDndContext</code>는 드래그 위치, 충돌 감지 등의 정보를 실시간으로 업데이트하기 때문입니다.</p>
<p><strong>해결 과정</strong>:</p>
<ol>
<li><code>ScheduleTable</code>에서 <code>useDndContext</code>를 사용하는 부분(드래그 중 테두리 표시)을 <code>TableOutline</code> 컴포넌트로 분리</li>
<li><code>ScheduleTable</code>과 <code>DraggableSchedule</code>에 <code>React.memo</code> 적용</li>
<li>결과적으로 드래그 중에는 <code>TableOutline</code>만 리렌더링되고, 실제 시간표 데이터는 드롭 시에만 업데이트</li>
</ol>
<hr/>
<h3 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h3>
<h4 id="특히-만족스러운-구현"><a class="anchor" aria-hidden="true" tabindex="-1" href="#특히-만족스러운-구현"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>특히 만족스러운 구현</h4>
<p><strong>1. ScheduleContext의 CQRS 패턴</strong></p>
<p>단순히 &quot;리렌더링을 줄인다&quot;는 목표를 넘어서, 관심사 분리라는 설계 원칙을 적용했습니다. 상태를 &quot;읽기&quot;와 &quot;쓰기&quot;로 분리함으로써:</p>
<ul>
<li>컴포넌트가 자신에게 필요한 Context만 구독</li>
<li>불필요한 의존성 제거로 테스트 용이성 향상</li>
<li>향후 상태 관리 로직 변경 시 영향 범위 최소화</li>
</ul>
<p><strong>2. createCachedFetcher의 재사용성</strong></p>
<p>제네릭 타입을 활용하여 어떤 API fetcher에도 적용 가능한 범용 캐싱 유틸리티를 구현했습니다. 기존 API 호출 코드를 수정하지 않고도 캐싱을 적용할 수 있어 관심사 분리가 잘 되었습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 타입 안정성을 유지하면서 어떤 fetcher에도 적용 가능</span>
</span><span class="code-line"><span class="token keyword">const</span> cachedFetch <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createCachedFetcher</span><span class="token generic class-name"><span class="token operator">&lt;</span>Lecture<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>fetchLectures<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 타입 안정성을 유지하면서 어떤 fetcher에도 적용 가능
const cachedFetch = createCachedFetcher&lt;Lecture[]&gt;(fetchLectures);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="코드-설계-관련-고민과-결정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-설계-관련-고민과-결정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 설계 관련 고민과 결정</h4>
<p><strong>메모이제이션 적용 범위 결정</strong></p>
<p>모든 컴포넌트에 React.memo를 적용하는 것은 오히려 성능에 해로울 수 있다고 생각했고 다음 기준으로 선택적 적용을 결정했습니다:</p>



































<table><thead><tr><th>컴포넌트</th><th>memo 적용</th><th>이유</th></tr></thead><tbody><tr><td>LectureItem</td><td>O</td><td>리스트 아이템, 수백 개 렌더링 가능</td></tr><tr><td>MajorItem</td><td>O</td><td>체크박스 리스트, 개별 변경 빈번</td></tr><tr><td>DraggableSchedule</td><td>O</td><td>드래그 중 리렌더링 방지 필요</td></tr><tr><td>ScheduleTable</td><td>O</td><td>드래그 중 리렌더링 방지 필요</td></tr><tr><td>SearchDialog</td><td>X</td><td>최상위 컴포넌트, 부모 리렌더링 드뭄</td></tr></tbody></table>
<p>하지만 Q&amp;A 시간때 오히려 &quot;가끔&quot; 메모이제이션을 적용하는 것보다 오히려 &quot;모두&quot; 메모이제이션을 적용하는 것이 좋을 수 있다고 하여 이후엔 모두 메모이제이션하는 방향을 고려해볼 예정입니다.</p>
<p>참조 - <a href="https://yceffort.kr/2022/04/memo-for-referential-stability-in-react">https://yceffort.kr/2022/04/memo-for-referential-stability-in-react</a></p>
<hr/>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<h4 id="가장-큰-배움이-있었던-부분"><a class="anchor" aria-hidden="true" tabindex="-1" href="#가장-큰-배움이-있었던-부분"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>가장 큰 배움이 있었던 부분</h4>
<p><strong>Context 리렌더링 메커니즘의 이해</strong></p>
<p>이론적으로 &quot;Context 값이 변경되면 구독 컴포넌트가 리렌더링된다&quot;는 것은 알고 있었지만, 실제로 어떤 상황에서 문제가 되는지 체감하지 못했습니다. 이 과제에서:</p>
<ol>
<li>React DevTools Profiler로 드래그 중 리렌더링 횟수 측정</li>
<li><code>useDndContext</code>가 매 프레임 변경됨을 확인</li>
<li>Context 분리/컴포넌트 분리로 해결</li>
<li>최적화 전후 렌더링 횟수 비교</li>
</ol>
<p>이 과정을 통해 &quot;왜 Context 최적화가 필요한지&quot;를 직접 경험하고, 해결 패턴을 체득했습니다.</p>
<p><strong>Promise.all의 동작 원리 재확인</strong></p>
<p><code>Promise.all</code>은 배열 내 모든 Promise가 resolve될 때까지 기다립니다. 하지만 단순히 Promise.all로 감싼다고 병렬 실행이 되는 것은 아닙니다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 이건 병렬 실행이 아님! (이미 실행된 Promise를 기다리는 것)</span>
</span><span class="code-line"><span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;/api/1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;/api/2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 이게 진짜 병렬 실행</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>result1<span class="token punctuation">,</span> result2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;/api/1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">&quot;/api/2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 이건 병렬 실행이 아님! (이미 실행된 Promise를 기다리는 것)
const result1 = await fetch(&quot;/api/1&quot;);
const result2 = await fetch(&quot;/api/2&quot;);
await Promise.all([result1, result2]);

// 이게 진짜 병렬 실행
const [result1, result2] = await Promise.all([fetch(&quot;/api/1&quot;), fetch(&quot;/api/2&quot;)]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="추가-학습이-필요한-영역"><a class="anchor" aria-hidden="true" tabindex="-1" href="#추가-학습이-필요한-영역"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>추가 학습이 필요한 영역</h4>
<ul>
<li><strong>React Profiler 심화</strong>: Ranked 차트 분석, 렌더링 시간 측정</li>
<li><strong>Bundle 최적화</strong>: Code splitting, Tree shaking, Dynamic import</li>
<li><strong>Web Vitals</strong>: LCP, FID, CLS 측정 및 개선</li>
</ul>
<hr/>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p>시간표 애플리케이션이라는 구체적인 맥락이 있어서 &quot;왜 이 최적화가 필요한지&quot; 체감할 수 있었습니다. 드래그 중 버벅임은 사용자 경험에 직접 영향을 주기 때문에 최적화의 필요성을 절실히 느꼈습니다.</p>
<hr/>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<p>Q&amp;A에서 &quot;선택적 메모이제이션보다 전체 적용이 나을 수 있다&quot;는 내용이 인상깊었습니다. 현재는 리렌더링 비용이 큰 컴포넌트만 메모이제이션을 적용했는데 React 19의 React Compiler가 도입되면 수동 메모이제이션이 불필요해질 것으로 예상되는데, 현 시점에서도 전체 적용이 더 좋은 전략일까요?</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>잘했어요 대현! 이번 과제에서 &quot;왜 리렌더링이 발생하는가&quot;를 정확히 진단하고, 그에 맞는 해결책을 체계적으로 적용하는 접근법을 배우기 위함이었습니다. React DevTools Profiler로 실제 렌더링 횟수를 측정하면서 최적화를 해본 경험이 도움이 되었기를 바랍니다. 감으로 최적화하는 게 아니라 측정 기반으로 접근하는 습관은 실무를 할 때 도움이 될거에요!</p>
<p>CQRS 패턴으로 Context를 Command/Query로 분리했다는 점이 눈에 들어오네요. 단순히 &quot;리렌더링 줄이기&quot;를 넘어서 &quot;상태를 읽는 쪽과 쓰는 쪽의 관심사가 다르다&quot;는 것을 이해하는 건 큰 이점이 있습니다. 이런 분리는 나중에 상태 관리 방식이 바뀌어도 영향 범위가 명확해지는 장점이 있습니다.</p>
<p>또한 useDndContext를 TableOutline으로 격리한 부분도 잘했습니다. 자주 바뀌는 상태를 구독하는 컴포넌트는 최소한의 UI만 담당하게 한다는 원칙은 중요합니다.</p>
<p>Q) Q&amp;A에서 &quot;선택적 메모이제이션보다 전체 적용이 나을 수 있다&quot;는 내용이 인상깊었습니다. 현재는 리렌더링 비용이 큰 컴포넌트만 메모이제이션을 적용했는데 React 19의 React Compiler가 도입되면 수동 메모이제이션이 불필요해질 것으로 예상되는데, 현 시점에서도 전체 적용이 더 좋은 전략일까요?</p>
<p>=&gt; 실무에서 선택적 적용보다 전체 적용이 나을 수 있다는 건 컨벤션을 위함입니다. 언제는 해야한다라는걸 기준을 참 잡기가 어렵거든요. 또한 React Compiler가 나오면 수동 메모이제이션이 불필요해지는 건 맞지만, 아직 프로덕션 레디가 아니에요. 현 시점에서는 대현님이 하신 것처럼 &quot;왜 이 컴포넌트에 memo가 필요한지&quot; 이유를 설명할 수 있는 선택적 적용이 학습에는 더 좋다고 봅니다.</p>
<p>=&gt; 사실 논쟁의 다른 측면은 useMemo를 안 쓸 수 있도록 하는게 좋다는 측면도 있습니다. 리렌더링이 되어야 하는 이유가 2개이상이라면 컴포넌트의 책임이 여러개라는 의미이기도 하니까요.</p>
<p>일단 본인이 최대한 모두의 의견들을 다 경험하고 나서 경험을 통해 선택을 할 수 있게 되기를 바랍니다.</p>
<p>마지막 챕터까지 정말 수고 많으셨어요! 앞으로도 이렇게 손으로 부딪히면서 배우는 방식 계속 이어가시길 바랍니다. 고생하셨습니다! 화이팅입니다</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 - 김대현 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 김대현님이 제출한 [3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 김대현, [3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 - 김대현 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 김대현님이 제출한 [3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 - 김대현 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 김대현님이 제출한 [3팀 김대현] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-RTTRX4Ru.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
