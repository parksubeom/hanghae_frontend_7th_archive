<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@ds92ko/" data-discover="true">ds92ko<!-- --> 님의 상세페이지</a> ＞ <!-- -->[2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter3-2/pull/32" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->ds92ko</span><span>2025.12.02</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h2>
<ul>
<li><strong>Advanced:</strong> <a href="https://ds92ko.github.io/front_7th_chapter3-2/">https://ds92ko.github.io/front_7th_chapter3-2/</a></li>
<li><strong>Basic:</strong> <a href="https://ds92ko.github.io/front_7th_chapter3-2/index.basic.html">https://ds92ko.github.io/front_7th_chapter3-2/index.basic.html</a></li>
</ul>
<h2 id="과제의-핵심취지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제의-핵심취지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제의 핵심취지</h2>
<ul>
<li>React의 hook 이해하기</li>
<li>함수형 프로그래밍에 대한 이해</li>
<li>액션과 순수함수의 분리</li>
</ul>
<h2 id="과제에서-꼭-알아가길-바라는-점"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제에서-꼭-알아가길-바라는-점"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제에서 꼭 알아가길 바라는 점</h2>
<ul>
<li>엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup</li>
<li>엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()</li>
<li>엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등</li>
<li>엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart) vs capaitalize(str)</li>
</ul>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<ul class="contains-task-list">
<li>
<p>Component에서 비즈니스 로직을 분리하기</p>
</li>
<li>
<p>비즈니스 로직에서 특정 엔티티만 다루는 계산을 분리하기</p>
</li>
<li>
<p>뷰데이터와 엔티티데이터의 분리에 대한 이해</p>
</li>
<li>
<p>entities -&gt; features -&gt; UI 계층에 대한 이해</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 함수는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 Component와 UI를 다루는 Component는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 데이터 흐름에 맞는 계층구조를 이루고 의존성이 맞게 작성이 되었나요?</p>
</li>
</ul>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<ul class="contains-task-list">
<li>
<p>이번 심화과제는 Context나 Jotai를 사용해서 Props drilling을 없애는 것입니다.</p>
</li>
<li>
<p>어떤 props는 남겨야 하는지, 어떤 props는 제거해야 하는지에 대한 기준을 세워보세요.</p>
</li>
<li>
<p>Context나 Jotai를 사용하여 상태를 관리하는 방법을 익히고, 이를 통해 컴포넌트 간의 데이터 전달을 효율적으로 처리할 수 있습니다.</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Context나 Jotai를 사용해서 전역상태관리를 구축했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전역상태관리를 통해 domain custom hook을 적절하게 리팩토링 했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 도메인 컴포넌트에 도메인 props는 남기고 props drilling을 유발하는 불필요한 props는 잘 제거했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전체적으로 분리와 재조립이 더 수월해진 결합도가 낮아진 코드가 되었나요?</p>
</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<p>이번 과제를 시작하기 전까지 저는 함수형 프로그래밍(FP)에 대해 다음과 같은 오해를 가지고 있었습니다.</p>
<ul>
<li>
<p>오해 1: <strong>FP는 OOP와 상반되는 개념이다.</strong>
FP는 객체의 상태 변경을 지양하고 순수 함수와 불변성에 중점을 두기 때문에, OOP의 핵심인 캡슐화와 Mutation을 부정한다고 생각했습니다.</p>
</li>
<li>
<p>오해 2: <strong>FP는 모든 것을 순수 함수로만 만들어야 한다.</strong>
실제 애플리케이션의 부수 효과(Side Effect), 즉 네트워크 통신, 상태 변경, 콘솔 출력 같은 필수적인 동작을 FP가 어떻게 다룰 수 있는지에 대한 이해가 부족했습니다.</p>
</li>
<li>
<p>오해 3: <strong>FP는 실무의 복잡한 비즈니스 로직을 구현하기에는 너무 이론적이다.</strong>
단순한 <code>map</code>, <code>filter</code>, <code>reduce</code> 이상의 복잡한 로직을 FP 방식으로 구조화하는 것이 비효율적이라고 생각했습니다.</p>
</li>
</ul>
<p>하지만 이번 과제를 통해 FP의 목표와 실용적 가치를 깊이 이해하게 되었습니다.</p>
<ul>
<li>
<p><strong>FP의 목표는 OOP의 대안이 아닌 보완</strong>
FP는 OOP를 대체하는 것이 아니라, &quot;어떻게 하면 더 안전하게 데이터를 다룰 수 있을까?&quot; 에 초점을 맞춥니다.</p>
<ul>
<li>OOP의 장점: <code>Product</code> 엔티티처럼 데이터와 관련된 행위(메서드)를 캡슐화하여 도메인의 관심사를 효과적으로 분리합니다.</li>
<li>FP의 역할: 장바구니 총액 계산 로직(<code>calculateCartTotal</code>)처럼 데이터를 변경하지 않는 순수한 계산은 컴포넌트나 객체의 내부 상태에 묶어두지 않고, 순수 함수(<code>Pure Function</code>)로 분리하여 예측 불가능한 부수 효과를 제거하는 데 활용됩니다.</li>
</ul>
<p>결국, 이번 과제에서 저는 OOP가 담당해야 할 엔티티 캡슐화와 FP가 담당해야 할 계산의 순수성을 <code>models/</code> 폴더 분리를 통해 동시에 확보할 수 있었습니다.</p>
</li>
<li>
<p><strong>핵심은 순수 함수 최대화와 부수 효과 캡슐화</strong>
FP는 모든 것을 순수하게 만들라는 것이 아니라, 순수 함수를 최대한 늘리고, 부수 효과(Side Effect)는 의도된 경계에 모아 관리하라는 철학임을 깨달았습니다.</p>
<ul>
<li>Calculation (순수): <code>calculateCartTotal</code>과 같은 계산 로직은 <code>models/</code>에 순수 함수로 분리되었습니다.</li>
<li>Action (부수 효과): 상태를 변경하거나 알림을 표시하는 <code>addToCart</code>나 <code>handleNotificationAdd</code> 같은 함수는 Custom Hook이나 Zustand Store의 Action에 캡슐화하여 부수 효과가 발생하는 지점을 명확히 통제했습니다.</li>
</ul>
<p>이러한 Action / Calculation / Data 분리를 통해, 순수하지 않은 코드는 격리시키고 핵심 비즈니스 로직은 예측 가능하게 만들 수 있었습니다.</p>
</li>
<li>
<p><strong>FP는 복잡성 관리의 강력한 도구</strong>
복잡한 할인 계산 로직을 <code>getMaxDiscountRate</code>, <code>hasBulkPurchase</code> 등 작은 순수 함수들로 쪼개고 이를 조합하는 함수 합성 방식을 적용해보니, 복잡한 로직을 마치 레고 블록처럼 쉽게 이해하고 테스트하며 확장할 수 있었습니다.</p>
<p>로직이 변경되더라도 전체 시스템이 아닌 특정 작은 함수 블록만 수정하면 되므로, 유지보수성과 확장성 측면에서 FP가 실무에 얼마나 실용적인 아키텍처 원칙인지 깊이 체감할 수 있었습니다.</p>
</li>
</ul>
<h3 id="과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제를 하면서 내가 알게된 점, 좋았던 점은 무엇인가요?</h3>
<h4 id="기본-과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본-과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본 과제</h4>
<p>초기 1,123줄의 <code>App.tsx</code> 코드를 리팩토링하면서, 단순히 코드를 분할하는 것을 넘어 관심사 분리와 FP 사고를 적용하는 것의 가치를 체감했습니다.</p>
<ul>
<li>
<p><strong>함수형 프로그래밍 원칙 적용</strong></p>
<p>기존 코드에서는 <code>calculateCartTotal()</code> 같은 함수가 컴포넌트 내부 변수를 클로저로 참조하여 외부 상태에 의존했습니다.
이는 함수형 프로그래밍의 핵심 원칙인 순수 함수(Pure Function)를 위반하는 패턴이었습니다.</p>
<p><strong>순수 함수와 부수 효과 제거:</strong></p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// origin: 부수 효과가 있는 함수 (외부 상태 의존)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">calculateCartTotal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 컴포넌트 내부 변수 cart, selectedCoupon을 클로저로 참조</span>
</span><span class="code-line">  <span class="token keyword">return</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">+</span> selectedCoupon<span class="token punctuation">.</span>discount<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// advanced: 순수 함수 (명시적 파라미터, 부수 효과 없음)</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">calculateCartTotal</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cart<span class="token operator">:</span> CartItem<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> selectedCoupon<span class="token operator">:</span> Coupon <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 같은 입력에 대해 항상 같은 출력 보장</span>
</span><span class="code-line">  <span class="token keyword">return</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>selectedCoupon<span class="token operator">?.</span>discount <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// origin: 부수 효과가 있는 함수 (외부 상태 의존)
const calculateCartTotal = () =&gt; {
  // 컴포넌트 내부 변수 cart, selectedCoupon을 클로저로 참조
  return cart.reduce(...) + selectedCoupon.discount;
};

// advanced: 순수 함수 (명시적 파라미터, 부수 효과 없음)
export const calculateCartTotal = (cart: CartItem[], selectedCoupon: Coupon | null) =&gt; {
  // 같은 입력에 대해 항상 같은 출력 보장
  return cart.reduce(...) + (selectedCoupon?.discount || 0);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>그 외에도</p>
<p><strong>불변성을 통한 안전한 데이터 조작:</strong>
filter, map과 같은 배열 메서드를 사용해 새 배열을 반환하거나, 스프레드 연산자로 새 배열을 반환하도록 처리했습니다.</p>
<p><strong>함수 합성으로 복잡한 로직 구현:</strong>
작은 순수 함수들을 합성하여 복잡한 계산을 수행하도록 처리했습니다.</p>
<p><strong>고차 함수와 선언적 프로그래밍:</strong> 기존의 명령형 방식을 선언적 방식으로 리팩토링</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// origin: 명령형 패턴 (forEach + 변수 누적)</span>
</span><span class="code-line"><span class="token keyword">const</span> calculateCartTotal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">{</span>
</span><span class="code-line">  totalBeforeDiscount<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</span><span class="code-line">  totalAfterDiscount<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">let</span> totalBeforeDiscount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 변수 선언 및 초기화</span>
</span><span class="code-line">  <span class="token keyword">let</span> totalAfterDiscount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  cart<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// forEach로 반복하면서 변수 변경</span>
</span><span class="code-line">    <span class="token keyword">const</span> itemPrice <span class="token operator">=</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>price <span class="token operator">*</span> item<span class="token punctuation">.</span>quantity<span class="token punctuation">;</span>
</span><span class="code-line">    totalBeforeDiscount <span class="token operator">+=</span> itemPrice<span class="token punctuation">;</span> <span class="token comment">// 부수 효과: 변수 변경</span>
</span><span class="code-line">    totalAfterDiscount <span class="token operator">+=</span> <span class="token function">calculateItemTotal</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// advanced: 선언형 패턴 (reduce로 누적)</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">calculateCartTotal</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cart<span class="token operator">:</span> CartItem<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> selectedCoupon<span class="token operator">:</span> Coupon <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> totalBeforeDiscount<span class="token punctuation">,</span> totalAfterDiscount<span class="token operator">:</span> beforeCoupon <span class="token punctuation">}</span> <span class="token operator">=</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">      totalBeforeDiscount<span class="token operator">:</span> acc<span class="token punctuation">.</span>totalBeforeDiscount <span class="token operator">+</span> item<span class="token punctuation">.</span>product<span class="token punctuation">.</span>price <span class="token operator">*</span> item<span class="token punctuation">.</span>quantity<span class="token punctuation">,</span>
</span><span class="code-line">      totalAfterDiscount<span class="token operator">:</span> acc<span class="token punctuation">.</span>totalAfterDiscount <span class="token operator">+</span> <span class="token function">calculateItemTotal</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> cart<span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">{</span> totalBeforeDiscount<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> totalAfterDiscount<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token comment">// 초기값</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// origin: 명령형 패턴 (forEach + 변수 누적)
const calculateCartTotal = (): {
  totalBeforeDiscount: number;
  totalAfterDiscount: number;
} =&gt; {
  let totalBeforeDiscount = 0; // 변수 선언 및 초기화
  let totalAfterDiscount = 0;

  cart.forEach(item =&gt; {
    // forEach로 반복하면서 변수 변경
    const itemPrice = item.product.price * item.quantity;
    totalBeforeDiscount += itemPrice; // 부수 효과: 변수 변경
    totalAfterDiscount += calculateItemTotal(item);
  });
  // ...
};

// advanced: 선언형 패턴 (reduce로 누적)
export const calculateCartTotal = (cart: CartItem[], selectedCoupon: Coupon | null) =&gt; {
  const { totalBeforeDiscount, totalAfterDiscount: beforeCoupon } = cart.reduce(
    (acc, item) =&gt; ({
      totalBeforeDiscount: acc.totalBeforeDiscount + item.product.price * item.quantity,
      totalAfterDiscount: acc.totalAfterDiscount + calculateItemTotal(item, cart)
    }),
    { totalBeforeDiscount: 0, totalAfterDiscount: 0 } // 초기값
  );
  // ...
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이렇게 변경하면서 함수형 프로그래밍의 핵심 원칙들을 적용할 수 있었습니다:</p>
<ul>
<li><strong>순수성(Purity)</strong>: 같은 입력에 대해 항상 같은 출력을 보장</li>
<li><strong>명시적 의존성(Explicit Dependencies)</strong>: 모든 의존성을 파라미터로 명시</li>
<li><strong>부수 효과 제거(Side Effect Free)</strong>: 외부 상태를 변경하지 않음</li>
<li><strong>불변성(Immutability)</strong>: 원본 데이터를 변경하지 않고 새로운 데이터를 반환</li>
<li><strong>함수 합성(Function Composition)</strong>: 작은 순수 함수들을 조합하여 복잡한 로직 구현</li>
</ul>
<p>덕분에 테스트 코드 작성과 버그를 발견하고 예방하기 용이한 코드로 리팩토링이 가능했습니다.
또한 이 로직을 다른 컴포넌트나 모듈에서 재사용할 수 있어 유지보수와 확장성 측면에서도 큰 도움이 됐습니다.</p>
</li>
<li>
<p><strong>코드 구조 개선과 관심사 분리를 통한 유지보수성 극대화</strong></p>
<p>초기 App.tsx는 1,123줄에 달하며 모든 로직이 한 곳에 섞여 있었습니다.
이는 디버깅과 기능 수정 등에 엄청난 비효율을 발생시키게 됩니다.</p>
<p><strong>해결 방법:</strong></p>
<ul>
<li>기능별로 작게 분리하고 각 모듈에 단일 책임 원칙 적용</li>
<li>Custom Hook을 도입해 상태관리 및 비즈니스 로직 캡슐화</li>
<li>순수 함수를 <code>models/</code>(도메인 로직)와 <code>utils/</code>(범용 유틸리티) 폴더로 분리하여 부수 효과 없는 계산 로직 관리</li>
</ul>
<p>이를 적용하자, 코드를 읽고 이해하는 시간이 획기적으로 단축되었으며, 컴포넌트는 오직 View 렌더링 역할에 집중하게 되었습니다.
특히 함수형 프로그래밍 원칙에 따라 순수 함수로 분리된 계산 로직은 예측 가능하고 테스트하기 쉬워졌습니다.
이를 통해 모듈화된 아키텍처와 함수형 프로그래밍이 대규모 애플리케이션의 유지보수성과 협업 효율에 얼마나 필수적인 요소인지 깊이 체감했습니다.</p>
</li>
</ul>
<h4 id="심화과제-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h4>
<p>상태 관리 라이브러리(Zustand)와 영속화(Persist) 기능을 적용하며 전역 상태 관리의 심화 패턴을 학습했습니다.</p>
<ul>
<li>
<p><strong>Zustand 전역 상태의 특성 이해</strong></p>
<p><code>useNotifications</code>를 전역 상태로 변경하는 과정에서 이전 테스트의 알림이 다음 테스트에 영향을 주며 기존 테스트가 깨지는 문제가 발생했습니다.
<code>useState</code>는 렌더링마다 새로운 상태를 생성하므로 상태가 독립적이지만, Zustand store는 전역 싱글톤으로 메모리에 유지됩니다.
이 때문에 테스트 환경에서 이전 테스트의 데이터가 다음 테스트에 남아 예상치 못한 오류를 일으킬 수 있음을 알게 되었습니다.
전역 상태 관리 환경에서는 테스트 간 상태 간섭을 막기 위해 명시적 초기화가 필수적이라는 점을 체득했습니다.</p>
</li>
<li>
<p><strong>persist 미들웨어 동작 원리 파악</strong></p>
<p>persist를 적용하면서, persist store가 스토어 생성 시 localStorage에서 상태를 읽어와 초기 상태로 복원하기 때문에 단순히 localStorage를 지우는 것만으로는 충분하지 않고, 스토어 상태와 localStorage를 동시에 초기화해야 함을 알게 되었습니다.</p>
<pre class="language-diff"><code class="language-diff code-highlight"><span class="code-line">beforeEach(() =&gt; {
</span><span class="code-line"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   // localStorage 초기화
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">   localStorage.clear();
</span></span></span><span class="code-line inserted"><span class="token unchanged"><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // store 초기화
</span></span></span><span class="code-line inserted"><span class="token inserted-sign inserted"><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    useCart.getState().actions.clearCart();
</span></span></span><span class="code-line"><span class="token inserted-sign inserted"><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   ...
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span></span>});
</span></code><div class="copied" data-code="beforeEach(() =&gt; {
    // localStorage 초기화
    localStorage.clear();
+    // store 초기화
+    useCart.getState().actions.clearCart();
    ...
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>테스트에서 localStorage를 지워도 이미 메모리에 존재하는 store 인스턴스에는 이전 상태가 그대로 남아 있습니다.</li>
<li>persist store는 localStorage를 읽어 스토어 상태를 초기화하는 시점이 스토어 생성 시점이므로, localStorage만 초기화하면 이전 데이터가 유지됩니다.</li>
</ul>
<p>이를 통해 persist store가 localStorage와 메모리 상태를 어떻게 복원하고 동기화하는지 직접 경험하며, 전역 상태 관리 + 영속화(store persist) 동작 원리를 이해할 수 있었습니다.</p>
</li>
</ul>
<hr/>
<h3 id="이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제에서 내가 제일 신경 쓴 부분은 무엇인가요?</h3>
<h4 id="기본과제-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h4>
<ul>
<li>
<p><strong>PageType 기반 설계로 확장성 확보</strong></p>
<p>기존에는 <code>isAdmin</code> 같은 boolean 플래그로 페이지를 구분했기 때문에 페이지가 늘어날수록 플래그와 분기문이 함께 증가하는 구조적 문제가 있었습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>isAdmin<span class="token punctuation">,</span> setIsAdmin<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const [isAdmin, setIsAdmin] = useState(false);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>예를 들어 마이페이지가 추가되면 다음과 같이 새로운 플래그와 조건이 계속 붙습니다.</p>
<pre class="language-diff"><code class="language-diff code-highlight"><span class="code-line">const [isAdmin, setIsAdmin] = useState(false);
</span><span class="code-line inserted"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> const [isMyPage, setIsMyPage] = useState(false);
</span></span></span><span class="code-line"><span class="token inserted-sign inserted"><span class="token line"></span></span>
</span><span class="code-line">if (isAdmin) {...}
</span><span class="code-line inserted"><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> else if (isMyPage) {...}
</span></span></span></code><div class="copied" data-code="const [isAdmin, setIsAdmin] = useState(false);
+ const [isMyPage, setIsMyPage] = useState(false);

if (isAdmin) {...}
+ else if (isMyPage) {...}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이는 다음과 같은 문제를 만들어 냅니다.</p>
<ul>
<li>상태가 늘어날수록 컴포넌트 복잡도 증가</li>
<li>누락·충돌 같은 버그 가능성 증가</li>
<li>타입 시스템에서 페이지 종류를 제어할 수 없음</li>
<li>페이지가 많아질수록 유지보수 비용이 선형적으로 증가</li>
</ul>
<p>이 문제를 해결하기 위해 페이지 구분 방식을 boolean 기반이 아닌 PageType 기반의 단일 책임 구조로 전환했습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">PAGES</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  store<span class="token operator">:</span> <span class="token string">&#x27;store&#x27;</span><span class="token punctuation">,</span>
</span><span class="code-line">  admin<span class="token operator">:</span> <span class="token string">&#x27;admin&#x27;</span>
</span><span class="code-line"><span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">usePage</span> <span class="token operator">=</span> <span class="token punctuation">(</span>initialPage<span class="token operator">:</span> PageType <span class="token operator">=</span> <span class="token constant">PAGES</span><span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>currentPage<span class="token punctuation">,</span> setCurrentPage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span>PageType<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>initialPage<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> switchPage <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page<span class="token operator">:</span> PageType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">setCurrentPage</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> isCurrentPage <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>page<span class="token operator">:</span> PageType<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> currentPage <span class="token operator">===</span> page<span class="token punctuation">,</span> <span class="token punctuation">[</span>currentPage<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">    currentPage<span class="token punctuation">,</span>
</span><span class="code-line">    setCurrentPage<span class="token punctuation">,</span>
</span><span class="code-line">    switchPage<span class="token punctuation">,</span>
</span><span class="code-line">    isCurrentPage
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="export const PAGES = {
  store: &#x27;store&#x27;,
  admin: &#x27;admin&#x27;
} as const;

const usePage = (initialPage: PageType = PAGES.store) =&gt; {
  const [currentPage, setCurrentPage] = useState&lt;PageType&gt;(initialPage);

  const switchPage = useCallback((page: PageType) =&gt; {
    setCurrentPage(page);
  }, []);

  const isCurrentPage = useCallback((page: PageType) =&gt; currentPage === page, [currentPage]);

  return {
    currentPage,
    setCurrentPage,
    switchPage,
    isCurrentPage
  };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 방식으로 페이지를 관리할 경우, 새로운 페이지를 추가할 때 PAGES만 확장하면 되고 기존 로직은 수정할 필요가 없습니다.</p>
<pre class="language-diff"><code class="language-diff code-highlight"><span class="code-line">export const PAGES = {
</span><span class="code-line"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> store: &#x27;store&#x27;,
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"> admin: &#x27;admin&#x27;,
</span></span></span><span class="code-line inserted"><span class="token unchanged"><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> mypage: &#x27;mypage&#x27;
</span></span></span><span class="code-line"><span class="token inserted-sign inserted"><span class="token line"></span></span>} as const;
</span></code><div class="copied" data-code="export const PAGES = {
  store: &#x27;store&#x27;,
  admin: &#x27;admin&#x27;,
+ mypage: &#x27;mypage&#x27;
} as const;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>확장성, 가독성, 타입 안정성 모두 확보할 수 있는 구조로 개선했습니다.</p>
</li>
<li>
<p><strong>Compound Component 패턴과 Context 구성</strong></p>
<p>Tabs UI는 여러 하위 컴포넌트가 상호작용해야 하는 구조입니다.</p>
<ul>
<li>Tabs (root)</li>
<li>TabList</li>
<li>Tab</li>
<li>TabPanel</li>
</ul>
<p>이런 구조는 Compound Component 패턴의 장점을 그대로 가져갈 수 있는 대표적인 케이스입니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tabs</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">TabList</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Tab</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Tab</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">TabList</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">TabPanel</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">...</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">TabPanel</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Tabs</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;Tabs&gt;
  &lt;TabList&gt;
    &lt;Tab&gt;...&lt;/Tab&gt;
  &lt;/TabList&gt;
  &lt;TabPanel&gt;...&lt;/TabPanel&gt;
&lt;/Tabs&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 패턴을 선택한 이유는 다음과 같습니다</p>
<ul>
<li>
<p>선언적 UI 구성
사용자가 <code>&lt;Tabs&gt;</code> 컴포넌트를 구성할 때, &quot;어떻게 동작하는지&quot;가 아니라 &quot;<strong>어떤 UI가 필요한지</strong>&quot;만 표현하면 됩니다.</p>
</li>
<li>
<p>내부 통신 구조 단일화
TabList, TabPanel은 서로 다른 레벨의 컴포넌트이지만 하나의 Tabs 상태를 공유해야 합니다.
이를 위해 private Context를 사용했고, 이는 Tabs 내부에서만 쓰이기 때문에 분리하지 않았습니다.</p>
<p>→ 응집도가 높아지고, 외부 노출도 방지되며 책임 범위가 명확해집니다.</p>
</li>
<li>
<p>로직의 재사용성 확보
상태 제어 로직은 UI와 분리할 필요가 있었기 때문에 useTabs를 별도 hook으로 만들어 범용적으로 활용할 수 있게 했습니다.</p>
</li>
</ul>
</li>
<li>
<p><strong>아이콘 네이밍 기준 결정</strong></p>
<p>Icon 컴포넌트를 추출하면서 네이밍을 용도 기반(close, delete, add 등)으로 할지 모양 기반(x, trash, plus 등)으로 할지 고민했습니다.</p>
<p><strong>용도 기반 네이밍의 장점과 한계:</strong></p>
<p>용도 기반 네이밍을 적용하면 아이콘 이름이 명확해집니다.</p>
<ul>
<li><code>CloseIcon</code></li>
<li><code>DeleteIcon</code></li>
<li><code>AddIcon</code></li>
</ul>
<p>이 방식은 어떤 UI 동작을 위한 아이콘인지 직관적으로 이해할 수 있다는 장점이 있습니다.
하지만 같은 모양의 아이콘을 다른 용도로 사용할 때 아이콘 컴포넌트가 중복 생성되는 문제가 발생합니다.</p>
<p>예를 들어 X 모양 아이콘을 생각해보면,</p>
<ul>
<li>모달 닫기 버튼 → <code>CloseIcon</code></li>
<li>장바구니 아이템 삭제 버튼 → <code>DeleteIcon</code></li>
</ul>
<p>둘다 동일한 X 모양을 사용하지만, 용도가 다르다는 이유만으로 서로 다른 아이콘 컴포넌트를 만들어야 합니다.
이렇게 되면 용도가 변경되거나 새로운 용도가 추가될 때마다 아이콘 컴포넌트를 새로 만들거나 이름을 변경하는 비효율이 생깁니다.
이 문제를 해결하기 위해 모양 기반 네이밍(XIcon, TrashIcon, PlusIcon 등)으로 방향을 정했습니다.</p>
<p><strong>모양 기반 네이밍의 장점:</strong></p>
<ul>
<li>하나의 아이콘을 다양한 용도에서 재사용 가능</li>
<li>용도가 바뀌어도 컴포넌트 이름을 다시 만들거나 수정할 필요 없음</li>
<li>아이콘의 그래픽 형태 기준으로 관리되기 때문에 일관성 유지가 쉬움</li>
<li>UI 전체에서 시각적 구성 요소를 기준으로 관리할 수 있어 디자인 시스템 관점에서도 더 안정적</li>
</ul>
<p>X 모양 자체는 변하지 않기 때문에, 용도가 달라져도 컴포넌트를 추가로 만들 필요가 없습니다.
이런 점을 종합해볼 때 재사용성·유연성·유지보수성 관점에서 모양 기반 네이밍이 더 적합하다고 판단했습니다.</p>
</li>
</ul>
<h4 id="심화과제-2"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제-2"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h4>
<ul>
<li>
<p><strong>Zustand Persist 호환성 문제 해결을 위한 커스텀 Storage 구현</strong></p>
<p>Zustand persist를 적용하면서 아래와 같은 저장 구조 때문에 문제가 발생했습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token punctuation">{</span>
</span><span class="code-line">  state<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span> 
</span><span class="code-line">  version<span class="token operator">:</span> <span class="token number">0</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="{
  state: {...}, 
  version: 0
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>advanced 버전은 이 구조를 저장하지만, basic 버전은 배열만 저장하는 단순 구조였습니다.
→ 즉, 기본 저장 구조가 달라서 기존 데이터를 읽지 못하는 호환성 문제가 생김</p>
<p>이를 해결하기 위해 처음에는 <code>partialize</code>로 필요한 부분만 저장하도록 시도했습니다.</p>
<pre class="language-diff"><code class="language-diff code-highlight"><span class="code-line">{
</span><span class="code-line deleted"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"> partialize: ({ context }) =&gt; ({ context })
</span></span></span><span class="code-line inserted"><span class="token deleted-sign deleted"><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> partialize: ({ context }) =&gt; [...context.cart]
</span></span></span><span class="code-line"><span class="token inserted-sign inserted"><span class="token line"></span></span>}
</span></code><div class="copied" data-code="{
- partialize: ({ context }) =&gt; ({ context })
+ partialize: ({ context }) =&gt; [...context.cart]
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>하지만 persist의 기본 포맷을 바꿀 수 없었기 때문에, 최종적으로 직접 PersistStorage를 구현해 advanced 버전에서도 basic과 동일한 구조로 저장되도록 만들었습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> cartStorage<span class="token operator">:</span> PersistStorage<span class="token operator">&lt;</span><span class="token punctuation">{</span> context<span class="token operator">:</span> CartContext <span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function-variable function">getItem</span><span class="token operator">:</span> name <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> stored <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stored<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>stored<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">setItem</span><span class="token operator">:</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> cart <span class="token operator">=</span> value<span class="token punctuation">.</span>state<span class="token punctuation">.</span>context<span class="token punctuation">.</span>cart<span class="token punctuation">;</span>
</span><span class="code-line">    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>cart<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">removeItem</span><span class="token operator">:</span> name <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="export const cartStorage: PersistStorage&lt;{ context: CartContext }&gt; = {
  getItem: name =&gt; {
    const stored = localStorage.getItem(name);
    if (!stored) return null;

    return JSON.parse(stored);
  },
  setItem: (name, value) =&gt; {
    const cart = value.state.context.cart;
    localStorage.setItem(name, JSON.stringify(cart));
  },
  removeItem: name =&gt; {
    localStorage.removeItem(name);
  }
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 방식으로 basic 버전과 동일한 localStorage 구조를 유지하면서도 zustand persist의 자동 저장·복원 기능을 그대로 활용할 수 있었습니다.</p>
</li>
<li>
<p><strong>searchTerm 전역 상태 관리 결정</strong></p>
<p><code>searchTerm</code>은 Header의 검색 인풋과 StorePage의 ProductList처럼 서로 다른 서브트리 컴포넌트들이 공유하는 값입니다.</p>
<pre><code class="code-highlight"><span class="code-line">App
</span><span class="code-line">├── Header
</span><span class="code-line">│   └── Input
</span><span class="code-line">│
</span><span class="code-line">└── StorePage
</span><span class="code-line">    └── main
</span><span class="code-line">        └── StorePage
</span><span class="code-line">            └── ProductSection
</span><span class="code-line">                └── ProductList
</span></code><div class="copied" data-code="App
├── Header
│   └── Input
│
└── StorePage
    └── main
        └── StorePage
            └── ProductSection
                └── ProductList
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이를 props로 전달하려면 App까지 거슬러 올라가는 구조가 되는데, 검색 기능은 App의 책임이 아니기 때문에 비효율적이고 자연스럽지 않다고 판단했습니다.
또한 두 컴포넌트는 서로 내부 동작을 몰라도 되는 독립된 모듈입니다.</p>
<ul>
<li>Header/Input → 입력 UI</li>
<li>StorePage/ProductList → 필터링된 상품 리스트</li>
</ul>
<p>하지만 동일한 검색 상태를 공유해야 하므로 전역 상태가 더 적합하다고 판단했습니다.
그래서 zustand store로 분리해 아래 이점을 확보했습니다.</p>
<ul>
<li>props drilling 완전 제거</li>
<li>검색 기능이 필요한 컴포넌트만 직접 구독</li>
<li>컴포넌트 결합도 감소</li>
<li>검색 로직의 단일 책임 확보</li>
</ul>
</li>
</ul>
<hr/>
<h3 id="이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제를 통해 앞으로 해보고 싶은게 있다면 알려주세요!</h3>
<p>이번 과제에서 관심사 분리와 모듈화의 중요성을 깊이 체감했습니다.
이를 바탕으로 프로젝트의 확장성과 유지보수성을 극대화하기 위해, 코드 구조를 한 단계 더 발전시키는 것에 도전해보고 싶습니다.</p>
<h4 id="기능-중심의-코드-구조-개선"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기능-중심의-코드-구조-개선"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기능 중심의 코드 구조 개선</h4>
<p>현재 프로젝트는 <code>models/</code>, <code>hooks/</code>, <code>components/</code>, <code>pages/</code>, <code>stores/</code>, <code>storage/</code> 등 역할 기반으로 코드가 분산되어 있습니다.</p>
<pre><code class="code-highlight"><span class="code-line">현재 구조 예시 (장바구니 기능):
</span><span class="code-line">src/advanced/
</span><span class="code-line">├── models/cart.ts          (계산 로직)
</span><span class="code-line">├── stores/cart.ts          (전역 상태)
</span><span class="code-line">├── storage/cart.ts         (persist storage)
</span><span class="code-line">├── hooks/selected-coupon.ts (로컬 상태)
</span><span class="code-line">└── pages/store/components/cart-section.tsx (UI)
</span></code><div class="copied" data-code="현재 구조 예시 (장바구니 기능):
src/advanced/
├── models/cart.ts          (계산 로직)
├── stores/cart.ts          (전역 상태)
├── storage/cart.ts         (persist storage)
├── hooks/selected-coupon.ts (로컬 상태)
└── pages/store/components/cart-section.tsx (UI)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이러한 구조는 특정 기능을 수정하거나 확장할 때 관련 코드를 여러 폴더에서 찾아야 하는 비효율성과 기능의 전체 맥락 파악의 어려움을 야기했습니다.</p>
<p>따라서 다음 프로젝트에서는 기능 중심으로 코드를 설계하는 FSD 아키텍처를 도입해보고 싶습니다.
FSD 구조를 적용하면 특정 기능(Feature)에 관련된 모든 코드(모델, 상태, UI, 로직)가 하나의 디렉토리 내에 모여 응집도가 극대화됩니다.</p>
<pre><code class="code-highlight"><span class="code-line">FSD 구조 예시:
</span><span class="code-line">src/advanced/
</span><span class="code-line">├── features/
</span><span class="code-line">│   ├── cart/                   // 장바구니 관련 모든 코드
</span><span class="code-line">│   │   ├── models/
</span><span class="code-line">│   │   ├── store.ts
</span><span class="code-line">│   │   └── components/
</span><span class="code-line">│   ├── products/
</span><span class="code-line">│   └── coupons/
</span><span class="code-line">└── shared/                     // 공통 유틸리티 및 컴포넌트
</span></code><div class="copied" data-code="FSD 구조 예시:
src/advanced/
├── features/
│   ├── cart/                   // 장바구니 관련 모든 코드
│   │   ├── models/
│   │   ├── store.ts
│   │   └── components/
│   ├── products/
│   └── coupons/
└── shared/                     // 공통 유틸리티 및 컴포넌트
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>높은 응집도: 기능 단위로 코드가 독립적으로 관리되어 개발 및 테스트가 용이해집니다.</li>
<li>명확한 경계: 새로운 기능 추가 시 코드를 작성해야 할 위치가 명확해져 온보딩 및 확장성이 향상됩니다.</li>
<li>유지보수성: 기능 단위로 코드를 추적하고 수정하기 쉬워져 장기적인 프로젝트의 유지보수 효율을 높일 수 있을 것이라 기대합니다.</li>
</ul>
<hr/>
<h3 id="리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문 편하게 남겨주세요 :)</h3>
<h4 id="searchterm-전역-상태-관리-결정에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#searchterm-전역-상태-관리-결정에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>searchTerm 전역 상태 관리 결정에 대한 질문</h4>
<ul>
<li>
<p><code>searchTerm</code>을 전역 상태로 분리하여 관리한 아키텍처적 결정에 대해 리뷰를 받고 싶습니다.</p>
<p><code>searchTerm</code>은 서로 다른 컴포넌트 서브트리(검색 인풋, 상품 목록 등)에서 동시에 참조하고 변경해야 하는 값이었습니다. 이 값을 Props Drilling을 통해 전달할 경우 최상위 <code>App</code> 컴포넌트가 검색이라는 특정 기능의 책임까지 떠맡게 되어 관심사 분리 원칙에 위배된다고 판단했습니다.</p>
<p>따라서 두 모듈이 동일한 검색 상태에 직접 접근하도록 전역 상태 관리 방식을 채택하는 것이 더 적절하다고 판단했는데, 이 선택이 해당 상태의 특성을 고려했을 때 적합한 결정이었을까요?</p>
</li>
</ul>
<h4 id="compound-component-패턴과-context-설계에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#compound-component-패턴과-context-설계에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Compound Component 패턴과 Context 설계에 대한 질문</h4>
<ul>
<li>
<p>제네릭 타입 T를 Provider에 전달해야 하는 Compound Component 패턴을 구현하면서, Context 생성 시점에 <code>any</code>를 사용하고 <code>useContext</code>를 사용하는 훅에서 타입 단언을 수행하여 타입을 지정하는 방식이 타입 안전성 측면에서 적절한 해결책인지 궁금합니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">TabsContext</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>TabsContextValue<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> useTabsContext <span class="token operator">=</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span> <span class="token attr-name">extends</span> <span class="token attr-name">string</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">() =&gt; </span><span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> context <span class="token operator">=</span> <span class="token function">useContext</span><span class="token punctuation">(</span><span class="token maybe-class-name">TabsContext</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> context <span class="token keyword">as</span> <span class="token maybe-class-name">TabsContextValue</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 타입 단언</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token plain-text">;
</span></span></code><div class="copied" data-code="const TabsContext = createContext&lt;TabsContextValue&lt;any&gt; | null&gt;(null);

const useTabsContext = &lt;T extends string&gt;() =&gt; {
  const context = useContext(TabsContext);
  return context as TabsContextValue&lt;T&gt;; // 타입 단언
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
</ul>
<h4 id="props-유지-기준에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#props-유지-기준에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Props 유지 기준에 대한 질문</h4>
<ul>
<li>
<p><code>totals</code>와 같이 장바구니 상태를 기반으로 계산되는 결과값을 처리할 때, 다음 두 방식 중 어떤 것이 더 나은 아키텍처적 선택일까요?
현재 방식처럼 부모 컴포넌트(예: StorePage)에서 계산 후 Props로 자식 컴포넌트(예: CouponSection, PaymentSection)에 전달하는 방식과 자식 컴포넌트가 Store에서 필요한 상태를 구독하여 각 컴포넌트 내부에서 계산을 수행하는 방식 중 어떤 방식이 더 적절한지 의견을 묻고 듣고싶습니다.</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 현재 방식: StorePage에서 계산 후 props로 전달</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">StorePage</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> cart <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">cartContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>selectedCoupon<span class="token punctuation">,</span> setSelectedCoupon<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useSelectedCoupon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> totals <span class="token operator">=</span> <span class="token function">calculateCartTotal</span><span class="token punctuation">(</span>cart<span class="token punctuation">,</span> selectedCoupon<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 계산 결과</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CouponSection</span></span> <span class="token attr-name">totals</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>totals<span class="token punctuation">}</span></span> <span class="token attr-name">selectedCoupon</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>selectedCoupon<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">PaymentSection</span></span> <span class="token attr-name">totals</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>totals<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 현재 방식: StorePage에서 계산 후 props로 전달
const StorePage = () =&gt; {
  const { cart } = cartContext();
  const [selectedCoupon, setSelectedCoupon] = useSelectedCoupon();
  const totals = calculateCartTotal(cart, selectedCoupon); // 계산 결과

  return (
    &lt;CouponSection totals={totals} selectedCoupon={selectedCoupon} /&gt;
    &lt;PaymentSection totals={totals} /&gt;
  );
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
<li>
<p><code>selectedCoupon</code>을 로컬 상태로 두는 것과 전역 상태로 관리하는 것의 기준이 무엇일까요?
현재 <code>selectedCoupon</code>을 <code>StorePage</code> 내에서만 사용하는 로컬 상태로 관리하고 있습니다.
이 결정에 대해 다음과 같은 의문이 있습니다.</p>
<ul>
<li>판단 근거의 적절성: <code>selectedCoupon</code>이 <code>StorePage</code> 내부에서만 사용되고 있어 로컬 상태를 유지했는데, 이 판단이 적절했을까요?</li>
<li>상태 관리 기준: 상태를 로컬로 둘지 전역으로 관리할지 판단하는 명확한 기준은 무엇일까요? (사용 범위, 관심사 분리, 변경 빈도, Props Drilling의 깊이 등을 고려했을 때의 최적의 기준에 대한 조언을 구합니다.)</li>
<li>만약 <code>selectedCoupon</code>을 전역 상태로 분리해야 한다면, 프로젝트의 주요 전역 상태 관리 툴인 Zustand를 사용하는 것이 좋을까요, 아니면 StorePage 컴포넌트 서브트리 내에서만 사용하도록 Context API를 활용하여 부분적인 전역 상태로 관리하는 것이 더 적절한 선택일까요?</li>
</ul>
</li>
</ul>
<h4 id="zustand에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#zustand에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Zustand에 대한 질문</h4>
<ul>
<li>
<p>Zustand selector를 사용하여 상태 객체 전체를 구독하는 대신, 필요한 속성(cart, totalItemCount 등)만 더 세밀하게 구독하는 방식이 실제 렌더링 성능 최적화에 유의미한 이점을 가져다줄까요?</p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 예시: 더 세밀한 selector 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> cart <span class="token operator">=</span> <span class="token function">useCart</span><span class="token punctuation">(</span>state <span class="token arrow operator">=&gt;</span> state<span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">.</span><span class="token property-access">cart</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cart만 구독</span>
</span><span class="code-line"><span class="token keyword">const</span> totalItemCount <span class="token operator">=</span> <span class="token function">useCart</span><span class="token punctuation">(</span>state <span class="token arrow operator">=&gt;</span> state<span class="token punctuation">.</span><span class="token property-access">context</span><span class="token punctuation">.</span><span class="token property-access">totalItemCount</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// totalItemCount만 구독</span>
</span></code><div class="copied" data-code="// 예시: 더 세밀한 selector 사용
const cart = useCart(state =&gt; state.context.cart); // cart만 구독
const totalItemCount = useCart(state =&gt; state.context.totalItemCount); // totalItemCount만 구독
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
<li>
<p>현재 <code>cartContext()</code>, <code>cartActions()</code> 와 같이 특정 객체를 반환하는 Selector 함수 패턴을 사용하고 있습니다.
이 방식이 Zustand Store에서 context나 actions를 분리하여 사용하는 데 있어 성능(리렌더링) 측면에서 이점이 있는지 궁금합니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 현재 패턴</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">cartContext</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useCart</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> context <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">cartActions</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useCart</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> actions <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> actions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 현재 패턴
export const cartContext = () =&gt; useCart(({ context }) =&gt; context);
export const cartActions = () =&gt; useCart(({ actions }) =&gt; actions);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
<li>
<p>Basic 버전과의 호환성을 위해 <code>setItem</code>시 배열만 저장하도록 커스텀 <code>Storage</code>를 구현했습니다.
이러한 버전/호환성 문제가 발생했을 때, 커스텀 Storage 구현 외에 다른 아키텍처적 대안이 있을까요?
이 경우, 오히려 Zustand의 persist 미들웨어를 사용하지 않고 수동으로 localStorage를 관리하는 것이 더 나은 선택이었을까요?</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 현재 커스텀 Storage 구현</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> cartStorage<span class="token operator">:</span> PersistStorage<span class="token operator">&lt;</span><span class="token punctuation">{</span> context<span class="token operator">:</span> CartContext <span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function-variable function">getItem</span><span class="token operator">:</span> name <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> stored <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stored<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>stored<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">setItem</span><span class="token operator">:</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> cart <span class="token operator">=</span> value<span class="token punctuation">.</span>state<span class="token punctuation">.</span>context<span class="token punctuation">.</span>cart<span class="token punctuation">;</span>
</span><span class="code-line">    localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>cart<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 배열만 저장</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">removeItem</span><span class="token operator">:</span> name <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 현재 커스텀 Storage 구현
export const cartStorage: PersistStorage&lt;{ context: CartContext }&gt; = {
  getItem: name =&gt; {
    const stored = localStorage.getItem(name);
    if (!stored) return null;
    return JSON.parse(stored);
  },
  setItem: (name, value) =&gt; {
    const cart = value.state.context.cart;
    localStorage.setItem(name, JSON.stringify(cart)); // 배열만 저장
  },
  removeItem: name =&gt; {
    localStorage.removeItem(name);
  }
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
</li>
</ul>
<h4 id="아이콘-네이밍-기준에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#아이콘-네이밍-기준에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>아이콘 네이밍 기준에 대한 질문</h4>
<p>아이콘 네이밍을 결정하는 데 있어 재사용성과 유연성을 고려하여 모양 기반 네이밍(예: XIcon, TrashIcon)을 선택했습니다.
하지만 이는 용도 기반 네이밍(예: CloseIcon, DeleteIcon)과 비교했을 때 다음과 같은 의문이 발생했습니다.</p>
<ul>
<li>
<p>디자인 시스템 관점: 장기적인 유지보수와 일관성 측면에서 모양 기반과 용도 기반 중 어떤 네이밍 방식이 더 적합한 선택일까요?</p>
</li>
<li>
<p>유연성: 모양 기반 네이밍이 재사용성에 유리하다고 판단했으나, 만약 아이콘의 모양 자체가 변경될 경우 네이밍도 함께 수정해야 하는 단점이 발생합니다. 이를 회피할 수 있는, 모양 기반 및 용도 기반 외의 더 나은 네이밍 기준이나 접근 방식이 있을까요?</p>
</li>
</ul>
<p>질문이 많아 죄송합니다! 그리고 감사합니다!</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>수고하셨습니다. 다솜님!</p>
<ul>
<li>searchTerm 전역 상태 관리
너무 복잡하게 생각하실 필요 없을 것 같아욥.
이게 너무 단순한 조언일지 모르지만 &quot;필요할 때, 그 이유때문에 사용하면&quot; 됩니다. 멘토링때 말씀드렸던 리팩토링과 같은 이치죠
이유가 있다면 그리고 현재 대체가능한 대안이 없다면 사용하시면됩니다.</li>
</ul>
<p>요즘은 같이 캐싱기반에 패칭도구인 Tanstack Query가 상태관리도구의 대부분의 영역을 커버하고 있습니다.
그럼 어느때 상태관리 도구를 사용해야하느냐 할때,
서버에 저장할 필요없는 UI의 휘발성 상태를 멀리 떨어져있는 UI들이 공유할 때 사용하는 것은 그 이유중 하나일 것 같아요.</p>
<ul>
<li>
<p>Compound Component 패턴과 Context 설계에 대한 질문
제가 뭔가 잘못 이해한건 아닌지 모르겠지만, 왜 제너릭타입이 필요한거에요?
activeTab의 type이 스트링이면 되지 않나요?
뭔게 제가 의도를 파악하지 못한 것 같은데욥 tabㅇ
탭과 패널을 매칭하는 키 격인 activeTab을 string으로  제한하면 많은 부분이 해결될 것 같아요!</p>
</li>
<li>
<p>Props 유지와 selectedCoupon 관리 기준
totals는 부모(StorePage)에서 계산 후 props로 전달하는 현재 방식이 저는 적절한 것같아요.
totals가 서브 노드의 한곳에서만 사용된다면 성능상의 이슈로 서브컴포넌트에서 직접 훅을 사용하라고 말씀드렸을텐데 그것도 아닌것 같아요.
전역과 로컬 상태에 대한 기준은 재사용성과 프롭드릴링을 피하는 관점에서 잘 선택하시면 될 것 같습니다.
서브컴포넌트가 다른곳에서 재사용된다면 저는 서브노드에서 상태를 불러올것 같아요. 무거운 계산이라면 메모이제이션도 활용해서 계산할때 비용을 줄일 수도 있고욥.
그렇지 않으면 저도 이렇게 만들것 같아욥.</p>
</li>
</ul>
<p>뭔가 답이 있다기 보다는 상황에 따라 자신만에 이유를 만드는게 제일 중요한 것 같아요.</p>
<ul>
<li>Zustand Selector와 Storage
세밀한 selector는 리렌더링을 줄여 성능 최적화에 유의미합니다. 현재 cartContext() 패턴도 객체 분리로 괜찮으나, selector 직접 사용이 더 정밀합니다.
실제로 개발자도구를 사용해 어떻게 영향을 주는지 직접 눈으로 하나씩 확인해보시면 좋을 것 같아요.</li>
</ul>
<p>스토리지는 사실 적절히 영리하게 대응하셨다고 생각합니다. 말씀하신대로 수동으로 구현해도 괜찮고요.
이건 사실 그냥 선택의 문제인 것 같습니다 :)</p>
<ul>
<li>아이콘 네이밍
장기적인 관점에서는 모양보다는 용도기반 네이밍이 유리합니다.
옹도기반 네이밍이 모양보다는 좀 더 추상적인 개념이고 변경가능성을 수반합니다
이는 꼭 아이콘 네이밍 뿐 아니라
변수나 함수에대한 네이밍에서도 동일합니다~</li>
</ul>
<p>헥헥..
다솜님 말씀하신대로 내용이 많고,  제가 시간이 별루 없어서 최대한 작성한다고 했는데 부족하거나 잘못 답변하게 있을 수도 있어요
이해해주세요~</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 고다솜 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 고다솜, [2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
