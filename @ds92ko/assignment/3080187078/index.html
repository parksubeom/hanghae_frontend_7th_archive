<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@ds92ko/" data-discover="true">ds92ko<!-- --> 님의 상세페이지</a> ＞ <!-- -->[2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter3-3/pull/16" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->ds92ko</span><span>2025.12.08</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h2>
<p><a href="https://ds92ko.github.io/front_7th_chapter3-3/">https://ds92ko.github.io/front_7th_chapter3-3/</a></p>
<h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="목표--전역상태관리를-이용한-적절한-분리와-계층에-대한-이해를-통한-fsd-폴더-구조-적용하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#목표--전역상태관리를-이용한-적절한-분리와-계층에-대한-이해를-통한-fsd-폴더-구조-적용하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>목표 : 전역상태관리를 이용한 적절한 분리와 계층에 대한 이해를 통한 FSD 폴더 구조 적용하기</h4>
<ul>
<li>전역상태관리를 사용해서 상태를 분리하고 관리하는 방법에 대한 이해</li>
<li>Context API, Jotai, Zustand 등 상태관리 라이브러리 사용하기</li>
<li>FSD(Feature-Sliced Design)에 대한 이해</li>
<li>FSD를 통한 관심사의 분리에 대한 이해</li>
<li>단일책임과 역할이란 무엇인가?</li>
<li>관심사를 하나만 가지고 있는가?</li>
<li>어디에 무엇을 넣어야 하는가?</li>
</ul>
<h4 id="체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>체크포인트</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 전역상태관리를 사용해서 상태를 분리하고 관리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> Props Drilling을 최소화했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shared 공통 컴포넌트를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> shared 공통 로직을 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> entities를 중심으로 type을 정의하고 model을 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> entities를 중심으로 ui를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> entities를 중심으로 api를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> feature를 중심으로 사용자행동(이벤트 처리)를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> feature를 중심으로 ui를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> feature를 중심으로 api를 분리했나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> widget을 중심으로 데이터를 재사용가능한 형태로 분리했나요?</li>
</ul>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<h4 id="목표-서버상태관리-도구인-tanstackquery를-이용하여-비동기코드를-선언적인-함수형-프로그래밍으로-작성하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#목표-서버상태관리-도구인-tanstackquery를-이용하여-비동기코드를-선언적인-함수형-프로그래밍으로-작성하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>목표: 서버상태관리 도구인 TanstackQuery를 이용하여 비동기코드를 선언적인 함수형 프로그래밍으로 작성하기</h4>
<ul>
<li>TanstackQuery의 사용법에 대한 이해</li>
<li>TanstackQuery를 이용한 비동기 코드 작성에 대한 이해</li>
<li>비동기 코드를 선언적인 함수형 프로그래밍으로 작성하는 방법에 대한 이해</li>
</ul>
<h4 id="체크포인트-1"><a class="anchor" aria-hidden="true" tabindex="-1" href="#체크포인트-1"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>체크포인트</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 모든 API 호출이 TanStack Query의 useQuery와 useMutation으로 대체되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 쿼리 키가 적절히 설정되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> fetch와 useState가 아닌 선언적인 함수형 프로그래밍이 적절히 적용되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 캐싱과 리프레시 전략이 올바르게 구현되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 낙관적인 업데이트가 적용되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 에러 핸들링이 적절히 구현되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 서버 상태와 클라이언트 상태가 명확히 분리되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 코드가 간결하고 유지보수가 용이한 구조로 작성되었는가?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> TanStack Query의 Devtools가 정상적으로 작동하는가?</li>
</ul>
<h3 id="최종과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#최종과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>최종과제</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 폴더구조와 나의 멘탈모데일이 일치하나요?</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 다른 사람이 봐도 이해하기 쉬운 구조인가요?</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<h3 id="이번-과제를-통해-이전에-비해-새롭게-알게-된-점이-있다면-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제를-통해-이전에-비해-새롭게-알게-된-점이-있다면-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제를 통해 이전에 비해 새롭게 알게 된 점이 있다면 적어주세요.</h3>
<p>FSD를 처음 적용해보며 &quot;<strong>폴더 구조가 단순한 조직화 도구가 아니라, 코드의 의미론적 경계를 정의하는 메타 언어</strong>&quot;라는 인상을 받았습니다.
실무에서는 보통 역할별/도메인별 같은 직관적인 분류로 코드를 정리해왔는데, FSD의 각 레이어는 그런 분류와는 다른 차원의 사고를 요구했습니다.</p>
<p>예를 들어 이전에는 <code>api</code>, <code>hooks</code>, <code>types</code> 등 기술 스택이나 역할에 따라 파일을 배치하는 것이 자연스러웠습니다.
하지만 FSD는 &quot;이 기능이 어떤 책임을 가지고, 어느 레이어까지 외부에 노출 되어야 하는가?&quot;를 먼저 묻습니다.
이 과정에서 기능의 경계, 의존성 방향, 재사용 가능성 같은 구조적 개념을 더 선명하게 고민하게 됐습니다.</p>
<p>또한 동일한 기능이라도 레이어에 따라 &quot;어디에 둘 것인가&quot;가 달라지다보니, 단순히 폴더에 넣는 문제가 아니라 기능을 어떻게 정의하고 분해할 것인가가 먼저 결정돼야 한다는 점을 깨달았습니다.
이를 고민하는 과정에서 자연스럽게 비즈니스 도메인을 더 명확히 바라보게 되었고, &quot;기능 단위로 사고한다&quot;는 말이 이론적이기만 한 말이 아니라 실제로 코드 구조에 그대로 반영된다는 점을 경험했습니다.</p>
<p>무엇보다 인상적이었던 건, 구조를 맞추기 위해 억지로 끼워 넣는 느낌보다 오히려 &quot;아, 이건 feature가 아니라 entity였네&quot; 같은 판단이 점점 명확해졌다는 점입니다.
이는 구조가 사고를 규정하고, 사고가 다시 구조를 강화하는 순환 과정을 직접 느낀 경험이었습니다.</p>
<h3 id="본인이-과제를-하면서-가장-애쓰려고-노력했던-부분은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#본인이-과제를-하면서-가장-애쓰려고-노력했던-부분은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>본인이 과제를 하면서 가장 애쓰려고 노력했던 부분은 무엇인가요?</h3>
<p>가장 깊이 고민한 부분은 &quot;<strong>FSD 레이어의 경계를 어떻게 명확히 할 것인가</strong>&quot;였습니다.</p>
<p>FSD 공식 문서의 정의만으로는 실제 코드를 배치할 때 애매한 지점이 많았습니다.
그래서 각 레이어의 역할을 명확히 하기 위해 나만의 기준을 세웠습니다:</p>
<ul>
<li>
<p><strong>shared</strong>: 최대한 순수하고 전역적이거나 공통적으로 사용되는 것들</p>
<ul>
<li>예: <code>shared/ui/Button</code>, <code>shared/ui/Input</code>, <code>shared/api/base</code>, <code>shared/lib/useQueryParams</code></li>
</ul>
</li>
<li>
<p><strong>entities</strong>: CRUD 중 **R(Read)**에 해당하는 부분, 즉 readOnly 쿼리들</p>
<ul>
<li>예: <code>entities/post/api/queries.ts</code>의 <code>postQueries.list()</code>, <code>entities/user/api/queries.ts</code>의 <code>userQueries.list()</code></li>
<li>entities의 <code>api/api.ts</code>에는 모든 HTTP 메서드가 있지만, <code>api/queries.ts</code>에는 GET만 <code>queryOptions</code>로 정의</li>
</ul>
</li>
<li>
<p><strong>features</strong>: <strong>CUD(Create, Update, Delete)</strong>, 즉 mutations와 같은 커맨드들을 몰아두는 곳</p>
<ul>
<li>예: <code>features/post/api/mutations.ts</code>의 <code>postMutations.add()</code>, <code>postMutations.update()</code>, <code>postMutations.delete()</code></li>
<li>사용자 액션과 관련된 UI들도 함께 배치 (<code>AddDialog</code>, <code>EditDialog</code>, <code>DeleteButton</code> 등)</li>
</ul>
</li>
<li>
<p><strong>widgets</strong>: 여러 features를 묶어서 하나의 복합적인 기능 단위로 만드는 곳</p>
<ul>
<li>예: <code>widgets/post/ui/PostTable</code>은 <code>features/post</code>, <code>features/tag</code>, <code>features/user</code>를 조합하여 사용</li>
</ul>
</li>
<li>
<p><strong>pages</strong>: 페이지 레벨의 컴포넌트</p>
</li>
<li>
<p><strong>app</strong>: 앱 전역 설정 및 라우팅</p>
</li>
</ul>
<p>이 기준을 적용하니 코드 구조가 매우 명확해졌습니다. entities는 순수하게 읽기 전용 쿼리만 담당하고, features는 사용자가 실제로 데이터를 변경하는 액션(CUD)만 담당하게 되어 각 레이어의 책임이 분명해졌습니다.</p>
<p>하지만 그럼에도 <code>postWithAuthorQueries</code>와 같은 <code>postQueries</code>와 <code>userQueries</code>를 결합하여 가공한 형태는 의존성 방향에 따라 <code>features</code>에 두는 등의 예외 케이스가 발생했습니다.
(예외 케이스의 발생 배경 및 결정 근거는 하단의 리뷰 받고 싶은 내용 1번 항목에서 확인 부탁드립니다)</p>
<p>또 하나 고민했던 부분은 &quot;<strong>URL 파라미터를 단일 소스로 관리하기</strong>&quot;였습니다.</p>
<p>기존 코드에서는 useState와 URLSearchParams 양쪽에서 상태를 관리하고 있었는데, 이는 동기화 문제를 야기할 수 있습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// shared/lib/useQueryParams.ts</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">useQueryParams</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">getQueryParam</span> <span class="token operator">=</span> <span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">return</span> queryParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token constant">DEFAULT_QUERY_PARAMS</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">&quot;&quot;</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">updateQuery</span> <span class="token operator">=</span> <span class="token punctuation">(</span>params<span class="token operator">:</span> Params<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// URL만 업데이트하고, 컴포넌트는 URL 변경을 구독</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// shared/lib/useQueryParams.ts
export const useQueryParams = () =&gt; {
  const getQueryParam = (key: string) =&gt; {
    return queryParams.get(key) || DEFAULT_QUERY_PARAMS[key] || &quot;&quot;
  }

  const updateQuery = (params: Params) =&gt; {
    // URL만 업데이트하고, 컴포넌트는 URL 변경을 구독
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>그래서 URL을 단일 소스로 만들고, 모든 컴포넌트가 URL을 구독하도록 했습니다. 이렇게 하면</p>
<ul>
<li>상태 동기화 문제 해결</li>
<li>브라우저 뒤로가기/앞으로가기 자연스럽게 동작</li>
<li>URL 공유 가능</li>
</ul>
<p>하지만 이 결정의 트레이드오프는</p>
<ul>
<li>URL이 모든 상태를 담아야 함 (복잡도 증가)</li>
<li>URL 파라미터 파싱 로직이 여러 곳에 분산될 수 있음</li>
</ul>
<p>이런 고민들을 통해 &quot;<strong>완벽한 구조는 없다. 맥락에 맞는 트레이드오프를 선택하는 것</strong>&quot;이라는 것을 다시 한번 깨달았습니다.</p>
<h3 id="아직은-막연하다거나-더-고민이-필요한-부분을-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#아직은-막연하다거나-더-고민이-필요한-부분을-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>아직은 막연하다거나 더 고민이 필요한 부분을 적어주세요.</h3>
<p>FSD를 처음 경험하다 보니, 이번 과제에서는 FSD의 원칙과 철학을 최대한 정석적으로 따르고자 노력했습니다.
하지만 이 과정에서 때로는 원칙에 지나치게 매몰되어 극단적이었던 부분이 있었던 것 같습니다.</p>
<p>예를 들어 &quot;모든 것을 기능별로 분리하고 단일 책임 원칙을 지켜야 해!&quot;라는 강박에 사로잡혀 <code>AddDialogButton</code> 컴포넌트를 별도의 파일로 분리했던 게 지금 돌이켜 보면 조금 과했던 것 같습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/features/post/ui/AddDialogButton.tsx</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> Plus <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;lucide-react&quot;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useDialogActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;../../../shared/model/useDialog&quot;</span>
</span><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;../../../shared/ui&quot;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">AddDialogButton</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> setDialog <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useDialogActions</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setDialog</span><span class="token punctuation">(</span><span class="token punctuation">{</span> type<span class="token operator">:</span> <span class="token string">&quot;add-post&quot;</span><span class="token punctuation">,</span> id<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>Plus className<span class="token operator">=</span><span class="token string">&quot;w-4 h-4 mr-2&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      게시물 추가
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// src/features/post/ui/AddDialogButton.tsx

import { Plus } from &quot;lucide-react&quot;
import { useDialogActions } from &quot;../../../shared/model/useDialog&quot;
import { Button } from &quot;../../../shared/ui&quot;

const AddDialogButton = () =&gt; {
  const { setDialog } = useDialogActions()

  return (
    &lt;Button onClick={() =&gt; setDialog({ type: &quot;add-post&quot;, id: null })}&gt;
      &lt;Plus className=&quot;w-4 h-4 mr-2&quot; /&gt;
      게시물 추가
    &lt;/Button&gt;
  )
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>FSD를 적용하며 느낀 점은 &quot;<strong>원칙을 맹신하면 오히려 구조가 복잡해진다</strong>&quot;는 것이었습니다.
앞으로는 &quot;의미있는 분리&quot;와 &quot;실용적인 응집&quot; 사이의 균형을 찾아, 구조적 이점은 취하되 개발의 효율성을 해치지 않는 설계를 적용하고 싶습니다.</p>
<h3 id="이번에-배운-내용-중을-통해-앞으로-개발에-어떻게-적용해보고-싶은지-적어주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번에-배운-내용-중을-통해-앞으로-개발에-어떻게-적용해보고-싶은지-적어주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번에 배운 내용 중을 통해 앞으로 개발에 어떻게 적용해보고 싶은지 적어주세요.</h3>
<p>FSD를 경험하면서 가장 크게 깨달은 점은, 아키텍처는 단순히 코드를 폴더로 정리하는 방법이 아니라, 우리가 만든 코드의 &quot;의미&quot;를 설명해주는 언어와 같다는 것이었습니다.
이 깨달음을 바탕으로, 앞으로 개발할 때는 다음 네 가지를 특히 신경 써서 적용해보려고 합니다.</p>
<ol>
<li>
<p>&quot;이 코드가 왜 여기에 있어야 하는가&quot;에 답하기
앞으로는 코드를 정리할 때 단순히 &quot;비슷한 기능이니까&quot;라는 이유를 넘어설 것입니다.
코드가 어떤 맥락과 책임 아래 존재하는지를 고민하고, 그 이유를 구조로 표현하겠습니다.
이렇게 하면 코드를 처음 보는 사람도 이 파일이 시스템에서 어떤 역할을 하는지 빠르게 파악할 수 있을 것입니다.</p>
</li>
<li>
<p>트레이드오프는 숨기지 않고 명시적으로 인정하기
완벽한 아키텍처는 없다는 것을 배웠습니다. 어떤 구조를 선택하든 <strong>장점과 단점</strong>이 존재합니다.
이제부터는 &quot;최선&quot;의 구조를 찾으려 하기보다, 프로젝트의 현 상황과 목표에 가장 적합한 구조를 선택하겠습니다.
그리고 그 선택의 이유를 문서나 코드 주석 등을 통해 명확하게 남겨서, 나중에 구조를 변경할 때 중요한 판단 근거가 되도록 하겠습니다.</p>
</li>
<li>
<p>레이어 간 의존성, 의식적으로 관리하기
레이어 간의 의존성은 자연스러운 것이지만, 무심코 만들어진 의존성은 미래의 변경을 어렵게 만듭니다.
&quot;상위 레이어가 하위 레이어를 의존한다&quot;는 단순한 규칙을 넘어, &quot;<strong>왜 이 의존성이 필요한지</strong>&quot;, &quot;<strong>이 의존성이 깨질 경우 어떤 파급 효과가 있는지</strong>&quot;&quot;를 끊임없이 질문하며, 꼭 필요한 의존성만 허용하고 그 취약성을 관리하겠습니다.</p>
</li>
<li>
<p>데이터 변환 책임의 경계 명확히 하기
API 응답 데이터를 화면에 보여주기까지는 여러 변환 과정을 거칩니다.
이 변환을 어디서 할지(예: API 통신 레이어, UI 컴포넌트 내부 등)에 대한 답을 코드 구조 그 자체로 표현하겠습니다.
이렇게 하면 &quot;여기서 데이터 포맷을 바꿔도 되는가?&quot;라는 질문에 대한 답이 명확해지고, 데이터 일관성을 유지하는 데 도움이 될 것입니다.</p>
</li>
</ol>
<p>FSD를 실무에 적용할 때는, FSD를 100% 따르기보다는 FSD가 가진 접근법과 응집도 철학을 팀의 특성과 프로젝트의 맥락에 맞춰 유연하게 변형하는 것이 중요하다고 생각합니다. FSD는 훌륭한 &quot;제안&quot;이지, 절대적인 &quot;정답&quot;은 아니니까요.</p>
<p>마지막으로, 아키텍처는 살아있는 것이라는 점을 항상 기억하겠습니다.
처음 만든 구조가 완벽할 필요는 없습니다. 프로젝트가 성장하고 요구사항이 바뀌면 구조도 함께 진화해야 합니다.
이 진화의 방향을 &quot;무작정&quot;이 아니라, &quot;의식적으로&quot; 선택해나가는 개발자가 되겠습니다.</p>
<h2 id="챕터-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#챕터-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>챕터 셀프회고</h2>
<blockquote>
<p>클린코드와 아키테쳑 챕터 함께 하느라 고생 많으셨습니다!
지난 3주간의 여정을 돌이켜 볼 수 있도록 준비해보았습니다.
아래에 적힌 질문들은 추억(?)을 회상할 수 있도록 도와주려고 만든 질문이며, 꼭 질문에 대한 대답이 아니어도 좋으니 내가 느꼈던 인사이트들을 자유롭게 적어주세요.</p>
</blockquote>
<h3 id="클린코드-읽기-좋고-유지보수하기-좋은-코드-만들기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#클린코드-읽기-좋고-유지보수하기-좋은-코드-만들기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>클린코드: 읽기 좋고 유지보수하기 좋은 코드 만들기</h3>
<ul>
<li>더티코드를 접했을 때 어떤 기분이었나요? ^^; 클린코드의 중요성, 읽기 좋은 코드란 무엇인지, 유지보수하기 쉬운 코드란 무엇인지에 대한 생각을 공유해주세요</li>
</ul>
<p>이번 챕터에서 더티 코드를 접했을 때 PTSD가 왔습니다...ㅋㅋㅋ
직장에서 얻은 별명 중 하나가 &quot;앵그리 솜&quot;이었는데, 이런 코드들을 볼 때 그렇게 화가났던 것 같습니다.
수백 줄짜리의 단일 컴포넌트, 모호한 타입의 변수들, 여기저기 뒤섞이고 분산된 로직들...</p>
<p>물론 &quot;제대로 동작 하는가?&quot;의 관점에서 바라본다면 별개의 문제일 순 있지만, &quot;코드의 의도를 명확히 전달할 수 있는가?&quot;의 관점에서 생각해 봤을 때 더티 코드는 치명적입니다.
각 상태가 언제 업데이트 되는지, 어떤 로직이 어떤 조건에서 실행되는지 등을 추적하고 파악하는 데 엄청난 시간과 노력을 소모하게 만듭니다.</p>
<p>코드를 리팩토링 하면서 얻은 가장 큰 깨달음은 &quot;<strong>클린 코드는 단순히 예쁜 코드가 아닌, 코드의 의도를 명확히 전달해 협업과 성장을 돕는 코드</strong>&quot;라는 점이었습니다.</p>
<p><strong>더티 코드에서 발견한 공통적 특징</strong></p>
<p>리팩토링 이전 코드에서는 다음과 같은 문제점들이 두드러지게 나타났습니다.</p>
<ul>
<li>의도 불명확성: 코드가 무엇을 하는지는 알 수 있지만, 왜 그렇게 구현되었는지 맥락을 파악하기 어려웠습니다.</li>
<li>숨겨진 의존성: 여러 <code>useEffect</code> 훅들이 서로에게 의존하고 있었지만, 그 의존 관계가 명시적이지 않고 코드 전체에 분산되어 있었습니다.</li>
<li>흐름 파악의 어려움: 상태 업데이트 및 로직 실행 흐름이 여러 곳에 흩어져 있어, 전체적인 동작 원리를 한눈에 파악하기가 힘들었습니다.</li>
</ul>
<p><strong>리팩토링을 통해 얻은 변화</strong></p>
<p>반면, 클린 코드로 변화된 후에는 다음과 같은 긍정적인 특징들이 나타났습니다.</p>
<ul>
<li>각 함수와 훅이 하나의 명확한 책임만을 갖습니다.</li>
<li>함수의 이름이 그 함수가 수행하는 일을 정확히 설명하여, 내부 구현을 보기 전에 그 의도를 알 수 있습니다.</li>
<li>데이터와 상태의 흐름이 명확하게 분리 및 표현되어 전체적인 로직 파악이 쉬워졌습니다.</li>
</ul>
<p><strong>클린코드의 핵심 목표</strong></p>
<ol>
<li>
<p>읽기 좋은 코드: &quot;빠른 이해&quot;를 목표로
읽기 좋은 코드란, 코드를 처음 접하는 사람이 코드의 의도를 빠르고 정확하게 이해할 수 있도록 만드는 것입니다. 이는 단순히 주석을 많이 달거나 변수명을 길게 하는 것이 아니라, 코드의 구조 자체가 의도를 드러내도록 설계하는 것을 의미합니다.</p>
<ul>
<li>의도가 드러나는 이름: 함수의 이름이 그 기능과 역할을 설명합니다.</li>
<li>명확한 반환 값: 함수나 훅의 반환 값을 통해 어떤 데이터를 제공하는지 명확하게 알 수 있습니다.</li>
</ul>
</li>
<li>
<p>유지보수하기 쉬운 코드: &quot;변경 범위 최소화&quot;를 목표로
유지보수하기 쉬운 코드란, 변경이 발생했을 때 영향을 받는 범위를 최소화하고 유연하게 대응할 수 있는 코드입니다.
이것이 바로 <strong>관심사의 분리</strong>를 구현하는 핵심 목표입니다.</p>
<p>예를 들어, 리팩토링 전에는 검색 로직 하나를 바꾸기 위해 <code>searchPosts</code> 함수, 여러 <code>useState</code>, <code>useEffect</code> 의존성, 그리고 URL 업데이트 로직까지 복합적으로 확인해야 했습니다.</p>
<p>하지만 리팩토링 후에는 검색이라는 관심사가 완전히 분리된 <code>useSearch</code> 훅 하나만 수정하면 됩니다.
다른 컴포넌트는 전혀 영향을 받지 않습니다.</p>
</li>
</ol>
<p><strong>클린 코드의 궁극적인 지향점: 적절한 추상화</strong></p>
<p>다만, 여기서 주의할 점은 과도한 분리가 오히려 복잡도를 증가시킬 수 있다는 점입니다.
모든 것을 작은 함수로 나누는 것이 능사는 아니며, 너무 파편화되면 전체적인 로직 흐름을 파악하기가 어려워집니다.</p>
<p>결국 클린 코드의 핵심은 &quot;<strong>적절한 수준의 추상화</strong>&quot;를 찾는 것임을 느꼈습니다.
너무 추상적이어서 이해하기 어렵지도 않고, 그렇다고 너무 구체적이어서 쉽게 변경할 수 없는 것도 아닌, 유지보수성과 가독성을 모두 확보하는 균형점을 찾는 것이 중요하다는 생각이 들었습니다.</p>
<h3 id="결합도-낮추기-디자인-패턴-순수함수-컴포넌트-분리-전역상태-관리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#결합도-낮추기-디자인-패턴-순수함수-컴포넌트-분리-전역상태-관리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>결합도 낮추기: 디자인 패턴, 순수함수, 컴포넌트 분리, 전역상태 관리</h3>
<ul>
<li>거대한 단일 컴포넌트를 봤을때의 느낌! 처음엔 막막했던 상태관리, 디자인 패턴이라는 말이 어렵게만 느껴졌던 시절, 순수함수로 분리하면서 &quot;아하!&quot;했던 순간, 컴포넌트가 독립적이 되어가는 과정에서의 깨달음을 들려주세요</li>
</ul>
<p>지난주 1,000줄이 넘어가는 <code>App.tsx</code>를 처음 봤을 때 정말 막막했습니다.
이론적으로는 &#x27;함수형 프로그래밍&#x27;이나 &#x27;디자인 패턴&#x27; 같은 개념들을 알고 있었지만, 실제로 모든 로직과 상태가 한곳에 뒤엉킨 코드 앞에서 어디서부터 손을 대야 할지 엄두가 나지 않았습니다.</p>
<p>하지만 리팩토링을 하나씩 진행해 나가며, 단순히 파일을 쪼개는 것을 넘어 &quot;<strong>왜 결합도를 낮춰야 하는가</strong>&quot;에 대한 근본적인 가치를 체감할 수 있었습니다.</p>
<p><strong>순수 함수로의 전환, 그 &quot;아하!&quot;의 순간</strong></p>
<p>처음에는 단순히 함수를 밖으로 빼내는 것만으로도 충분하다고 생각했습니다.
하지만 <code>calculateCartTotal()</code> 같은 함수가 여전히 컴포넌트 내부 변수를 참조하고 있는 것을 보며, 이것이 테스트와 재사용을 가로막는 원인임을 깨달았습니다.</p>
<p>외부 의존성을 끊어내고 순수 함수로 전환한 순간, 비로소 코드가 명쾌해졌습니다.</p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// Before: 외부 상태에 암묵적으로 의존하는 함수</span>
</span><span class="code-line"><span class="token comment">// cart와 selectedCoupon이 어디서 왔는지 알 수 없고, 테스트하기도 어렵습니다.</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">calculateCartTotal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">+</span> selectedCoupon<span class="token punctuation">.</span>discount<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// After: 순수 함수 - 모든 의존성이 명시적</span>
</span><span class="code-line"><span class="token comment">// 같은 입력에는 항상 같은 출력이 보장되므로, 언제 어디서든 믿고 쓸 수 있습니다.</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">calculateCartTotal</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cart<span class="token operator">:</span> CartItem<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> selectedCoupon<span class="token operator">:</span> Coupon <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> cart<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>selectedCoupon<span class="token operator">?.</span>discount <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// Before: 외부 상태에 암묵적으로 의존하는 함수
// cart와 selectedCoupon이 어디서 왔는지 알 수 없고, 테스트하기도 어렵습니다.
const calculateCartTotal = () =&gt; {
  return cart.reduce(...) + selectedCoupon.discount;
};

// After: 순수 함수 - 모든 의존성이 명시적
// 같은 입력에는 항상 같은 출력이 보장되므로, 언제 어디서든 믿고 쓸 수 있습니다.
export const calculateCartTotal = (cart: CartItem[], selectedCoupon: Coupon | null) =&gt; {
  return cart.reduce(...) + (selectedCoupon?.discount || 0);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>모든 입력이 파라미터로 명시되자 데이터의 흐름이 투명해졌고, &quot;<strong>같은 입력에 같은 출력</strong>&quot;이라는 함수형 프로그래밍의 아름다움을 실감했습니다.</p>
<p><strong>컴포넌트가 독립적으로 되어가는 과정에서의 깨달음</strong></p>
<p>거대한 컴포넌트를 작은 컴포넌트들로 분리하면서, 각 컴포넌트가 <strong>자신만의 명확한 책임</strong>을 갖게 되었습니다.
이 과정에서 가장 크게 느낀 점은 심리적인 안정감입니다.</p>
<ul>
<li>&quot;이 컴포넌트를 수정해도 다른 곳은 망가지지 않는다&quot;는 확신</li>
<li>새로운 기능을 추가할 때 &quot;어디에 넣어야 할지&quot; 고민할 필요 없는 명확한 위치</li>
</ul>
<p>이 두 가지가 개발의 속도와 질을 완전히 바꿔놓았습니다.</p>
<p><strong>전역 상태 관리와 디자인 패턴의 실전 적용</strong></p>
<p>Zustand를 사용한 전역 상태 관리를 적용하면서, Props Drilling의 문제를 해결하고 컴포넌트 간 결합도를 낮출 수 있었습니다.
각 컴포넌트는 필요한 상태만 구독하고, 상태 변경 로직은 Store에 집중시켜 관심사 분리를 명확히 할 수 있었습니다.</p>
<p>또한, Compound Component 패턴으로 Tabs 컴포넌트를 구현해보며, 디자인 패턴이 단순한 이론이 아니라 유연성과 재사용성을 극대화하는 실질적인 도구임을 깨달았습니다.</p>
<p>처음의 막막했던 코드 덩어리가 각자의 역할이 명확한 유기적인 구조로 재탄생하는 과정을 통해 결합도가 낮은 코드의 장점을 체감할 수 있었습니다.
수정할 부분을 찾기 위해 헤매던 시간은 사라졌고, 코드를 읽는 것만으로도 전체 흐름이 보입니다.</p>
<p>&quot;<strong>결합도를 낮춘다</strong>&quot;는 것은 단순히 코드를 나누는 기술이 아니라, 변화에 유연하고 믿을 수 있는 소프트웨어를 만드는 핵심 열쇠였습니다.</p>
<h3 id="응집도-높이기-서버상태관리-폴더-구조"><a class="anchor" aria-hidden="true" tabindex="-1" href="#응집도-높이기-서버상태관리-폴더-구조"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>응집도 높이기: 서버상태관리, 폴더 구조</h3>
<ul>
<li>&quot;이 코드는 대체 어디에 둬야 하지?&quot;라고 고민했던 시간, FSD를 적용해보면서의 느낌, 나만의 구조를 만들어가는 과정, TanStack Query로 서버 상태를 분리하면서 느낀 해방감(?)등을 공유해주세요</li>
</ul>
<p>이번 과제를 통해 얻은 가장 중요한 구조적 깨달음은, FSD를 통한 폴더 구조의 개선과 TanStack Query를 통한 서버 상태 관리의 분리가 높은 응집도를 만드는 데 결정적인 역할을 한다는 점입니다.</p>
<ol>
<li>FSD: 기능 중심 설계의 이유</li>
</ol>
<p>이번 과제를 진행하기 전, FSD는 왜 Feature를 기준으로 구조를 설계하려고 했을까? 라는 궁금증이 생겼습니다.
전통적인 아키텍처의 경우 복잡성이 증가할수록 다음과 같은 문제에 직면했습니다.</p>
<ul>
<li>레이어별 구조: 하나의 기능을 완성하려면 여러 레이어 폴더를 오가야 하므로, 개발 흐름이 단절되고 기능 파악이 어려워집니다.</li>
<li>도메인별 구조: 도메인 간의 복잡한 의존성이 발생할 경우 구조가 얽히기 쉽습니다.</li>
</ul>
<p>이러한 문제점을 통해 FSD가 <strong>Feature</strong>를 기준으로 구조를 설계한 것은, 기능이 사용자에게 실질적인 가치를 제공하는 최소 단위이자, 변경 요청이 들어오는 단위이기 때문 아닐까? 라는 생각이 들었습니다.</p>
<p>예를 들어, &quot;게시물 추가&quot; 기능을 구현할 때, FSD 구조는 다음과 같이 기능과 관련된 모든 것을 한곳에 모읍니다.</p>
<ul>
<li><code>features/post/ui/AddForm.tsx</code>: UI</li>
<li><code>features/post/lib/useAddForm.ts</code>: 클라이언트 로직</li>
<li><code>features/post/api/mutations.ts</code>: API 호출</li>
</ul>
<p>이러한 기능별 응집 덕분에, 개발자는 &quot;이 기능이 무엇을 하는지, 어떻게 동작하는지&quot;를 features/post 폴더 안에서 한 번에 파악할 수 있습니다. 사용자 요구사항의 변경이 코드 구조 변경으로 자연스럽게 매핑되므로, 변경에 유연하게 대응할 수 있습니다.</p>
<ol start="2">
<li>TanStack Query를 통한 서버 상태 관리 분리</li>
</ol>
<p>기존의 <code>useState</code>와 <code>useEffect</code>를 사용한 서버 상태 관리 방식은 로딩, 에러, 캐싱, 리프레시 로직 등 모든 것을 수동으로 처리해야 했기 때문에 코드가 복잡해지고 UI 로직과 서버 상태 로직이 섞여 응집도가 낮았습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>posts<span class="token punctuation">,</span> setPosts<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>total<span class="token punctuation">,</span> setTotal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>loading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token operator">...</span>
</span><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>selectedTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">fetchPostsByTag</span><span class="token punctuation">(</span>selectedTag<span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token function">fetchPosts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  <span class="token function">updateURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>skip<span class="token punctuation">,</span> limit<span class="token punctuation">,</span> sortBy<span class="token punctuation">,</span> sortOrder<span class="token punctuation">,</span> selectedTag<span class="token punctuation">]</span><span class="token punctuation">)</span>
</span></code><div class="copied" data-code="const [posts, setPosts] = useState([])
const [total, setTotal] = useState(0)
const [loading, setLoading] = useState(false)
...
useEffect(() =&gt; {
  if (selectedTag) {
    fetchPostsByTag(selectedTag)
  } else {
    fetchPosts()
  }
  updateURL()
}, [skip, limit, sortBy, sortOrder, selectedTag])
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>TanStack Query를 도입하면서 서버 상태 관리가 획기적으로 개선되었습니다.</p>
<pre><code class="code-highlight"><span class="code-line">const { data, isLoading, error } = useQuery(postQueries.list(params));
</span></code><div class="copied" data-code="const { data, isLoading, error } = useQuery(postQueries.list(params));
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>선언적 상태 관리: <code>isLoading</code>, <code>error</code> 같은 상태가 자동으로 제공되어 수동 관리가 사라집니다.</li>
<li>캐싱 및 리프레시 자동화: 데이터 캐싱 및 백그라운드 리프레시를 라이브러리가 자동으로 처리하여 복잡한 로직을 개발할 필요가 없어집니다.</li>
<li>간편한 낙관적 업데이트: <code>mutation</code>의 <code>onSettled</code> 등을 활용하여 서버 응답을 기다리지 않고도 관련 쿼리를 즉시 업데이트하는 낙관적 업데이트를 쉽게 구현할 수 있습니다.</li>
</ul>
<h2 id="리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문</h2>
<h3 id="1-여러-도메인의-api-응답을-결합하여-가공한-쿼리는-fsd에서-어떤-레이어에-두는-것이-적절할까요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-여러-도메인의-api-응답을-결합하여-가공한-쿼리는-fsd에서-어떤-레이어에-두는-것이-적절할까요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 여러 도메인의 API 응답을 결합하여 가공한 쿼리는 FSD에서 어떤 레이어에 두는 것이 적절할까요?</h3>
<p><code>postWithAuthorQueries</code>를 <code>features/post/api/queries.ts</code>에 배치하기로 결정했으나, 이 판단이 FSD 원칙에 부합하는지 확신이 서지 않아 질문드립니다.</p>
<p><strong>초기 고민: 역할 정의의 모호함</strong></p>
<p>처음에는 이 쿼리의 소속을 두고 고민이 깊었습니다.
<code>postWithAuthorQueries</code>는 entities 계층의 <code>postQueries</code>와 <code>userQueries</code>를 결합하여 가공한 형태인데, FSD의 통상적인 정의와 충돌하는 지점이 있었기 때문입니다.</p>
<ul>
<li>Entities: 비즈니스 도메인을 순수하게 정의하는 곳</li>
<li>Features: Entity를 활용해 구체적인 사용자 액션을 구현하는 곳</li>
</ul>
<p>이 정의에 따르면 다음과 같은 딜레마가 생깁니다.</p>
<ul>
<li>&quot;Post와 User라는 순수 도메인의 조합이므로 entities에 두어야 하는가?&quot;</li>
<li>&quot;사용자 액션(Action)이 아니라 단순 데이터 조합(Query)인데 features에 두는 것이 맞는가?&quot;</li>
</ul>
<p><strong>의사결정 과정: 수직적 아키텍처로서의 이해</strong></p>
<p>고민하던 중 준형님과의 대화를 통해 FSD를 고정된 역할보다는 &quot;하위 레이어를 소비하는 수직적 폴더 아키텍처&quot;로 이해해야 한다는 통찰을 얻었습니다.
즉, 데이터 취합 계층을 두면 entities보다 상위 레벨로 올릴 수 있고, 코드를 라인 단위로 보는 것이 아닌 거시적 관점에서 다룰 수 있다는 것입니다.</p>
<p>이 조언을 바탕으로, <code>postWithAuthorQueries</code>가 <code>postQueries</code>와 <code>userQueries</code>를 의존하므로 상위 레이어인 features에 두는 것이 의존성 방향 측면에서 가장 타당하다고 판단했습니다.</p>
<p><strong>남은 의문: Features의 성격과 구조적 타당성</strong></p>
<p>의존성 방향을 따랐음에도 불구하고, 여전히 features 레이어의 본질적인 성격과 충돌하는 지점이 남아 있습니다.</p>
<p>FSD의 정의상 features는 주로 &quot;게시물 추가/수정&quot;과 같은 사용자 행동을 다루는 레이어입니다.
반면 <code>postWithAuthorQueries</code>는 액션이 없는 단순한 데이터 조합 쿼리일 뿐이라, features 레이어의 본질적인 역할과 맞는지 의구심이 듭니다.</p>
<p>코치님께서는 이 부분에 대해 어떻게 생각하시는지 의견을 듣고 싶습니다.</p>
<h3 id="2-소규모-프로젝트에서는-query-key를-중앙에서-관리하는-방식이-더-적합할까요-아니면-도메인별로-분산하여-관리하는-방식이-더-바람직할까요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-소규모-프로젝트에서는-query-key를-중앙에서-관리하는-방식이-더-적합할까요-아니면-도메인별로-분산하여-관리하는-방식이-더-바람직할까요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 소규모 프로젝트에서는 Query Key를 중앙에서 관리하는 방식이 더 적합할까요, 아니면 도메인별로 분산하여 관리하는 방식이 더 바람직할까요?</h3>
<p>현재 프로젝트에서 Query Key 관리 방식을 두고 고민하고 있습니다. FSD 구조 내에서 분산형과 중앙화 중 어느 것을 우선해야 할지 코치님의 의견을 듣고 싶습니다.</p>
<p>현재는 각 엔티티별로 쿼리 키를 분산 관리하고 있습니다.</p>
<p><strong>현재의 분산형 구조 (entities 캡슐화)</strong>
현재는 아래와 같이 각 entities 폴더 내에서 쿼리 키를 관리하고 있습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// entities/post/api/queries.ts - 현재 구조 (분산형)</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> postQueries <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  all<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;posts&quot;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token function-variable function">list</span><span class="token operator">:</span> <span class="token punctuation">(</span>params<span class="token operator">:</span> PostsParams<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
</span><span class="code-line">    <span class="token function">queryOptions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">      queryKey<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span>postQueries<span class="token punctuation">.</span>all<span class="token punctuation">,</span> <span class="token string">&quot;list&quot;</span><span class="token punctuation">,</span> params<span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">      <span class="token function-variable function">queryFn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">getPosts</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// entities/user/api/queries.ts - 현재 구조 (분산형)</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> userQueries <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  all<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;users&quot;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// entities/post/api/queries.ts - 현재 구조 (분산형)
export const postQueries = {
  all: [&quot;posts&quot;] as const,
  list: (params: PostsParams) =&gt;
    queryOptions({
      queryKey: [...postQueries.all, &quot;list&quot;, params],
      queryFn: () =&gt; getPosts(params),
    }),
}

// entities/user/api/queries.ts - 현재 구조 (분산형)
export const userQueries = {
  all: [&quot;users&quot;] as const,
  // ...
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 방식은 FSD의 철학과 일치하며 특정 도메인이 폐쇄적으로 진화할 수있고, API가 도메인별로 크게 달라질 때도 유연합니다.
하지만 &quot;모든 entities의 list key는 <code>list</code>로, detail key는 <code>detail</code>로 통일되어야 한다&quot; 같은 공통 규칙이 분산되어있어 일관성 관리가 어렵고, 기획이나 정책이 변경되어 공통적으로 변경 사항이 적용되어야 하는 경우에도 모든 entities 폴더를 뒤져야 합니다.</p>
<p><strong>고려 중인 중앙화 구조 (Shared 일관성)</strong>
그래서 아래와 같은 중앙화 구조를 생각해 보았습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// shared/api/query-keys.ts - 중앙화 예시</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> queryKeys <span class="token operator">=</span> <span class="token punctuation">{</span>
</span><span class="code-line">  posts<span class="token operator">:</span> <span class="token punctuation">{</span>
</span><span class="code-line">    all<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;posts&quot;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token function-variable function">list</span><span class="token operator">:</span> <span class="token punctuation">(</span>params<span class="token operator">:</span> PostsParams<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span>queryKeys<span class="token punctuation">.</span>posts<span class="token punctuation">.</span>all<span class="token punctuation">,</span> <span class="token string">&quot;list&quot;</span><span class="token punctuation">,</span> params<span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">// ...</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  users<span class="token operator">:</span> <span class="token punctuation">{</span>
</span><span class="code-line">    all<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;users&quot;</span><span class="token punctuation">]</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">// ...</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// shared/api/query-keys.ts - 중앙화 예시
export const queryKeys = {
  posts: {
    all: [&quot;posts&quot;] as const,
    list: (params: PostsParams) =&gt; [...queryKeys.posts.all, &quot;list&quot;, params] as const,
    // ...
  },
  users: {
    all: [&quot;users&quot;] as const,
    // ...
  },
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>특히 프로젝트 규모가 작은데도 파일이 많아지는 것에 대한 부담이 있어 중앙화를 고려해 보았습니다.
분산형의 장점과 중앙화의 장점 중 어떤 것이 더 중요한 가치인지, 프로젝트 규모나 팀 상황 등에 따라 달라지는 명확한 기준이 있을까요?</p>
<h3 id="3-프로젝트의-규모에-따라-fsd-구조를-어떻게-설계하고-결정하는-것이-좋을까요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-프로젝트의-규모에-따라-fsd-구조를-어떻게-설계하고-결정하는-것이-좋을까요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 프로젝트의 규모에 따라 FSD 구조를 어떻게 설계하고 결정하는 것이 좋을까요?</h3>
<p>현재 프로젝트는 Post, Comment, Tag, User 등의 도메인만 있는 작은 규모입니다.
FSD를 적용하고 있으나, 각 레이어의 책임을 철저히 지키다 보니 구조가 지나치게 세분화되어 오버 엔지니어링처럼 느껴지는 지점이 있습니다.</p>
<p><strong>현재 구조의 문제 인식</strong></p>
<p>예를 들어, <code>features/post</code>만 보더라도 UI, Model, Lib, API 등의 레이어가 세분화되면서, 단순히 &quot;게시물 추가&quot; 기능을 수정하려 해도 여러 폴더를 빈번하게 오가야 하는 비효율이 발생하고 있습니다.</p>
<ul>
<li><code>features/post/ui/</code> (AddForm, EditForm 등 10+ 파일)</li>
<li><code>features/post/lib/</code> (useAddForm, useSearch 등 10+ 파일)</li>
<li><code>features/post/api/</code> (mutations, queries 파일)</li>
<li><code>features/post/model/</code> (types 파일)</li>
</ul>
<p>FSD의 철학을 따르자면 레이어별 책임을 분리하기 위해 이러한 세분화는 자연스럽지만, 프로젝트 초기에는 파일 탐색 비용이 가독성 향상 효과를 상회하는 것 같습니다.</p>
<p><strong>생각해본 구조 확장 전략 (점진적 적용)</strong></p>
<p>저는 프로젝트 규모에 따라 FSD 구조를 점진적으로 확장하는 것이 정답이라고 생각합니다.</p>
<ul>
<li>작은 규모: segments 계층을 생략한 평면적 관리 (<code>features/post/AddForm.tsx</code>, <code>features/post/useAddForm.ts</code> 등)</li>
<li>중간 규모: 현재와 같은 세분화 구조 (<code>features/post/ui/</code>, <code>features/post/lib/</code> 등)</li>
<li>큰 규모: 하위 그룹핑 도입 (<code>features/post/add-post/ui/</code>, <code>features/post/update-post/lib/</code> 등)</li>
</ul>
<p><strong>현실적인 FSD 구조</strong></p>
<p>프로젝트 규모가 작을 때, FSD의 장점을 유지하면서도 오버 엔지니어링을 피할 수 있는 실용적인 구조는 뭐라고 생각하시는지, 그리고 제가 생각한 규모별 FSD 구조의 문제점은 없는지, 코치님께서 생각하시는 이상적인 구조는 어떤 구조인지 의견을 듣고 싶습니다.</p>
<h3 id="4-fsd-구조에서-에러-핸들링-로직은-어떤-방식으로-계층화하고-분리하는-것이-좋을까요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-fsd-구조에서-에러-핸들링-로직은-어떤-방식으로-계층화하고-분리하는-것이-좋을까요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. FSD 구조에서 에러 핸들링 로직은 어떤 방식으로 계층화하고 분리하는 것이 좋을까요?</h3>
<p>현재 에러 처리가 여러 레이어에 분산되어 있어, 로직 중복 및 일관성 저하 문제가 발생하고 있습니다.
FSD 철학을 유지하면서 에러 처리 전략의 효율성과 중앙 집중도를 높이는 방안에 대해 코치님의 의견을 구하고 싶습니다.</p>
<p><strong>현재의 에러 처리 구조</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// shared/model/error.ts - 에러 타입과 유틸리티</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ApiError</span> <span class="token punctuation">{</span>
</span><span class="code-line">  message<span class="token operator">:</span> <span class="token builtin">string</span>
</span><span class="code-line">  status<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span>
</span><span class="code-line">  code<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> getErrorMessage <span class="token operator">=</span> <span class="token punctuation">(</span>error<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 에러를 문자열로 변환하는 로직</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// features/post/api/mutations.ts - mutation에서 직접 에러 처리</span>
</span><span class="code-line"><span class="token function-variable function">onError</span><span class="token operator">:</span> <span class="token punctuation">(</span>error<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token function">getErrorMessage</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
</span><span class="code-line">  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;게시물 추가 실패:&quot;</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span>
</span><span class="code-line">  useToastStore<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">showToast</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">게시물 추가에 실패했습니다: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token string">&quot;error&quot;</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// shared/model/error.ts - 에러 타입과 유틸리티
export interface ApiError {
  message: string
  status?: number
  code?: string
}

export const getErrorMessage = (error: unknown): string =&gt; {
  // 에러를 문자열로 변환하는 로직
}

// features/post/api/mutations.ts - mutation에서 직접 에러 처리
onError: (error: unknown) =&gt; {
  const message = getErrorMessage(error)
  console.error(&quot;게시물 추가 실패:&quot;, message)
  useToastStore.getState().showToast(`게시물 추가에 실패했습니다: ${message}`, &quot;error&quot;)
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>제가 현재 구조를 선택한 이유는:</p>
<ul>
<li><strong>에러 타입과 유틸리티는 shared에</strong>: 모든 레이어에서 공통으로 사용되므로 shared가 적합하다고 판단했습니다</li>
<li><strong>에러 처리 로직은 각 mutation의 onError에서</strong>: 각 기능마다 에러 처리 방식이 다를 수 있으므로, features 레이어에서 처리하는 게 맞다고 생각했습니다</li>
</ul>
<p><strong>현재 구조의 문제점</strong></p>
<p>하지만 실제로 위 구조를 적용해보니 다음과 같은 문제점을 느낄 수 있었습니다.</p>
<ul>
<li>로직 중복: 모든 <code>mutation.onError</code>에서 <code>getErrorMessage</code> 호출, <code>console.error</code>, <code>useToastStore</code> 표시 등의 패턴이 반복됩니다.</li>
<li>전략 일관성 부족: 네트워크 에러, 비즈니스 로직 에러(예: 권한 없음), 검증 에러 등에 대한 처리 전략이 각 mutation마다 다르게 구현될 수 있습니다.</li>
<li>로깅 전략 분산: 글로벌 에러 로깅 전략을 각 mutation에서 개별적으로 결정해야 하는 문제가 있습니다.</li>
</ul>
<p><strong>이상적인 계층화 전략</strong></p>
<p>FSD 구조의 장점을 최대한 살리면서 에러 핸들링의 효율성과 통제력을 높이는 최적의 계층화 전략은 무엇일까요?</p>
<ul>
<li><strong>공통 처리 계층</strong>: 에러 타입별 처리 전략(예: 401 에러는 로그인 리다이렉트, 403 에러는 권한 없음)과 글로벌 로깅 로직은 어디(shared? app 레이어?)에 정의해야 할까요?</li>
<li><strong>구현 패턴</strong>: 에러 처리 로직을 중앙화 하는 방식과 공통 패턴 훅 추출 방식 중 책임 분리의 관점에서 FSD 철학에 더 적합한 패턴은 무엇일까요?
<ul>
<li>중앙화 방식: <code>shared/api/error-handler.ts</code> 같은 곳에 에러 처리 로직을 중앙화하고, 각 mutation에서는 이 핸들러를 호출만 하는 방식</li>
<li>공통 훅 추출 방식: <code>features</code>에서 처리하되, 중복되는 공통 패턴만 추출하여 <code>shared/lib/useErrorHandler</code>와 같은 훅으로 만들어 사용</li>
</ul>
</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>다솜님 수고하셨습니다.</p>
<p>Q. 여러 도메인의 API 응답을 결합하여 가공한 쿼리는 FSD에서 어떤 레이어에 두는 것이 적절할까요?</p>
<p>entities의 API를 결합한 쿼리는 features/post/api에 둘 것 같아요. 내부에서 가공하는 로직이 분리되거나 재사용될 수 있다면 model에 두고 사용할 수도 있을 것 같고요.
말씀하신대로 features 레이어는 하위 레이어인 엔터티를 소비하며 비즈니스 기능을 조합하는 역할을 할 수 있기 때문에 적합해 보입니다.
FSD는 각 레이어의 의미보다 수직적 의존성 혹은 의존 방향의 일관성이 더 중요한 것 같습니다.
필요한 경우 레이어는 커스텀할 수 있는 부분이라고 생각합니다 :)</p>
<p>Q. 소규모 프로젝트에서는 Query Key를 중앙에서 관리하는 방식이 더 적합할까요, 아니면 도메인별로 분산하여 관리하는 방식이 더 바람직할까요?</p>
<p>말씀하신대로 필요한것은 가까이두는 것이 FSD의 기본적인 철학에 맞는 것 같아요
그러므로 각 레이어에서 가지고 있는 것이 맞는 것 같아요.</p>
<p>다만 중앙화냐 분산화냐 보다도
기본적으로 분산해서 가져가되 왜 중앙화를 해야하는가 이유가 중요할 것 같아요.
코드래밸에서의 일관성을 꼭 중앙화해야만 유지할 수 있는 것은 아닐 것 같습니다.
같이 일하는 사람들끼리 컨벤션으로 만들 수도 있을 것 같아요.
전 이건 컨벤셔으로 충분히 커버할 수 있는 문제라고 생각합니다 :)</p>
<p>Q. 프로젝트의 규모에 따라 FSD 구조를 어떻게 설계하고 결정하는 것이 좋을까요?</p>
<p>소규모라면 차라리 세그먼트를 생략하고 그냥 레이어 밑에 features/post/AddForm.tsx 이렇게
바로 사용하는 것은 저도 완전히 동의합니다.
그러다가 필요에 의해 책임을 분리해야할 이유, 예를들어 재사용이 필요하거나 코드가 너무 길어졌거나 등등이 생기면 그때
세그먼트로 분리할 수 있을 것 같습니다.
필요한 경우 일관성을 위해 ui라는 세그먼트는 따로 폴더로 구분하지말고 각 슬라이스 루트를 사용한다라고 약속해도 될 것 같고요
애초에 소규모건 대규모건 처음에 규모가 판단이 안될때도 이 전략은 유용할 것 같아요 :) 좋은 생각입니다.
FSD를 온전히 그대로 사용하기보다는 커스텀하게 응용하는게 더 좋은 활용법일 것 같습니다.</p>
<p>Q. FSD 구조에서 에러 핸들링 로직은 어떤 방식으로 계층화하고 분리하는 것이 좋을까요?</p>
<p>말씀하신 반복적인 에러처리는 예를들어 뮤테이션의 경우 에러 메시지를 받아서 토스트를 띄우는 함수를 만들어서 재사용할 수 있을 것 같아요.</p>
<p>그리고 네트워크에러는 중앙화가 가능하기때문에 한곳에서 처리하거나 fetch하는 모듈을 정의해서 그곳해서 처리하고 그것을 재사용하는 방법도 있고
추가로 서버단과 약속한 에러타입에 대한 처리도 중앙화할 수 있을 것 같습니다.
그리고 FSD에 적합한 패턴이라고 따로 없을 것 같아요  그저 중앙화된 처리는 말씀하신 대로 shared 하위에 둔다 정도 일 것 같습니다 :)</p>
<p>그리고 React Query에서 중앙화된 에러처리는 QueryCache와 MutationCache를 자주 활용합니다 :)</p>
<p>다솜님은 매 과제마다 아주 깊은 고찰을 하시는 것 같아요!
너무 멋지고 좋은 자세라고 생각합니다.</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 - 고다솜 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 고다솜, [2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 3-3 기능 중심 아키텍처와 프로젝트 폴더 구조 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
