<link rel="preload" as="image" href="https://github.com/user-attachments/assets/4020b148-b2cb-463e-8fe2-6804482f6245"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/dc590169-0963-4c14-8036-29f3beb08704"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/421bbd2b-710c-4a73-9ee8-4caac570cc57"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@ds92ko/" data-discover="true">ds92ko<!-- --> 님의 상세페이지</a> ＞ <!-- -->[2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter4-2/pull/4" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->ds92ko</span><span>2025.12.20</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h1 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h1>
<h2 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h2>
<p><a href="https://ds92ko.github.io/front_7th_chapter4-2/">https://ds92ko.github.io/front_7th_chapter4-2/</a></p>
<h2 id="과제-요구사항"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-요구사항"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 요구사항</h2>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 배포 후 url 제출</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> API 호출 최적화(<code>Promise.all</code> 이해)</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 연산 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 리렌더링 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 시간표 블록 드래그시 렌더링 최적화</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> 시간표 블록 드롭시 렌더링 최적화</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<h2 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h2>
<!-- -->
<p>이번 과제를 진행하면서 성능 최적화를 감각이나 추측이 아닌, 측정 → 원인 파악 → 검증의 흐름으로 접근해보는 경험을 할 수 있었습니다.
그 과정에서 처음 접하거나, 개념적으로만 알고 있다가 실제로 이해하게 된 부분을 정리해 보았습니다.</p>
<h3 id="1-react-devtools-profiler-막연한-버벅임을-선명한-수치로"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-react-devtools-profiler-막연한-버벅임을-선명한-수치로"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. React DevTools Profiler: 막연한 &quot;버벅임&quot;을 선명한 &quot;수치&quot;로</h3>
<p>이전까지는 성능 문제를 단순히 &quot;버벅인다&quot;는 느낌으로만 인지했으나, 이번 과제에서 Profiler를 처음 활용하며 리렌더링의 실체를 시각적으로 확인할 수 있었습니다.</p>
<p>사용법이 생소해 과제 시작 전 발제 자료와 <a href="https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html#reading-performance-data">공식 문서(Introducing the React Profiler)</a>를 정독하며 사용법을 익혔습니다.</p>
<p>컴포넌트별 렌더링 시간과 횟수뿐만 아니라, 어떤 Props나 State 변경이 리렌더링을 유발했는지 정밀하게 추적할 수 있었습니다.
덕분에 불필요한 연산이 발생하는 병목 지점을 빠르게 찾아냈고, 최적화 후 얼마나 개선되었는지를 감각이 아닌 정확한 데이터로 검증할 수 있었습니다.</p>
<p>성능 최적화의 첫 단추는 &quot;추측&quot;이 아니라 도구를 통한 &quot;정확한 분석&quot;임을 깊이 체감했습니다.</p>
<hr/>
<h3 id="2-usedeferredvalue--starttransition-ux-중심의-우선순위-설계"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-usedeferredvalue--starttransition-ux-중심의-우선순위-설계"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. <code>useDeferredValue</code> &amp; <code>startTransition</code>: UX 중심의 우선순위 설계</h3>
<p>React 18의 Concurrent Features를 이번 과제를 통해 처음 접하며, 모든 상태 업데이트가 동일한 긴급도를 가질 필요가 없다는 것을 배웠습니다.</p>
<ul>
<li><code>useDeferredValue</code>: ScheduleTable의 schedules 데이터에 적용했습니다. 드래그 중에는 이전 값을 유지하며 시각적 피드백(transform)에 집중하고, 드래그가 끝난 시점에 최신 데이터로 업데이트되도록 구현했습니다.</li>
<li><code>startTransition</code>: useScheduleBoard 훅 내의 보드 복제, 삭제, 스케줄 삭제 등 무거운 상태 업데이트 로직에 적용하여 메인 스레드가 블로킹되는 현상을 방지했습니다.</li>
</ul>
<p>처음에는 &quot;업데이트를 의도적으로 지연시키는 것이 오히려 사용자 경험을 해치지 않을까?&quot; 하는 걱정이 있었습니다.
하지만 실제 적용 후 테스트해 보니, 드래그 중에는 즉각적인 시각적 반응만 보여주고 무거운 데이터 처리는 뒤로 미루는 방식이 화면 끊김을 없애 훨씬 부드러운 경험을 제공한다는 것을 확인했습니다.
이를 통해 Concurrent Features는 단순한 속도 향상이 아니라, &quot;어떤 것을 먼저 보여줄 것인가&quot;를 결정하는 사용자 경험의 근본적인 개선 도구임을 깨달았습니다.</p>
<hr/>
<h3 id="3-performancenow-마이크로초-단위의-정밀한-성능-진단"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-performancenow-마이크로초-단위의-정밀한-성능-진단"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. <code>performance.now()</code>: 마이크로초 단위의 정밀한 성능 진단</h3>
<p>기존에는 <code>Date.now()</code> 정도만 알고 있었는데, 이번 과제를 통해 <code>performance.now()</code> API를 처음 알게 되었습니다.
발제 때 준일 코치님께서 간단하게 설명 해주셨지만, 잘 이해가 되지 않아 <a href="https://developer.mozilla.org/ko/docs/Web/API/Performance/now">MDN 문서</a>를 찾아 보거나 GPT에게 질문을 하며 학습했습니다.</p>
<ul>
<li><code>Date.now()</code>: 밀리초 단위에 시스템 시계의 영향을 받는다.</li>
<li><code>performance.now()</code>: 페이지 로드 시점을 기준으로 마이크로초 단위의 정밀한 상대 시간을 제공한다.</li>
</ul>
<p><code>cachedFetch</code> 구현 시 캐시 히트 여부에 따른 응답 속도를 로깅하는 데 활용했습니다.
네트워크 요청과 캐시 응답 사이의 압도적인 시간 차이를 눈으로 직접 확인하며, Promise 캐싱이 성능에 얼마나 큰 기여를 하는지 확신할 수 있었습니다. &quot;빨라진 것 같다&quot;는 느낌을 넘어 명확한 수치적 근거를 남길 수 있어 매우 유용했습니다.</p>
<hr/>
<h3 id="4-useautocallback-커스텀-훅-참조-안정성과-최신성의-딜레마를-해결하는-패턴"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-useautocallback-커스텀-훅-참조-안정성과-최신성의-딜레마를-해결하는-패턴"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. <code>useAutoCallback</code> 커스텀 훅: 참조 안정성과 최신성의 딜레마를 해결하는 패턴</h3>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Parameters<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> callbackRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  callbackRef<span class="token punctuation">.</span>current <span class="token operator">=</span> callback<span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Parameters<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> callbackRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const useAutoCallback = &lt;T extends (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;&gt;(callback: T) =&gt; {
  const callbackRef = useRef&lt;T&gt;(callback);
  callbackRef.current = callback;

  return useCallback((...args: Parameters&lt;T&gt;) =&gt; callbackRef.current?.(...args), []);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>발제 때 준일 코치님께서 소개해 주신 <code>useAutoCallback</code> 커스텀 훅을 과제에 적용했습니다.</p>
<ul>
<li><code>useRef</code>를 사용하여 항상 최신 콜백을 저장</li>
<li>외부로 반환하는 <code>useCallback</code>의 의존성 배열은 비워둠으로써 함수 참조값은 영구적으로 고정</li>
<li>고정된 함수 내부에서 <code>callbackRef.current</code>를 호출하여 항상 최신 상태의 클로저에 접근</li>
</ul>
<p>처음에는 익숙하지 않아서인지, 의존성이 코드상에 명시적으로 드러나지 않는다는 점 때문에 &quot;리액트의 선언적 흐름을 해치는 패턴이 아닐까?&quot;하는 강한 거부감이 들었습니다.
하지만 <a href="https://ko.react.dev/learn/react-compiler">React Compiler</a>가 해결하려는 문제를 보면서 이 패턴이 수동 관리의 한계를 극복하는 실용적인 도구임을 깨달았습니다.</p>
<img width="1856" height="628" alt="image" src="https://github.com/user-attachments/assets/4020b148-b2cb-463e-8fe2-6804482f6245"/>
<p>결국 최적화는 &quot;기계적인 문법&quot;보다 &quot;렌더링 원리에 대한 깊은 이해&quot;가 우선되어야 함을 배웠습니다.</p>
<h3 id="5-lighthouse-ci-지속-가능한-성능-관리-시스템-구축"><a class="anchor" aria-hidden="true" tabindex="-1" href="#5-lighthouse-ci-지속-가능한-성능-관리-시스템-구축"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. Lighthouse CI: 지속 가능한 성능 관리 시스템 구축</h3>
<p>지금까지는 브라우저 확장 프로그램으로 수동 측정하던 Lighthouse를 Github Actions 워크플로우에 통합하여, 성능을 시스템적으로 관리하는 경험을 했습니다.
워크플로우와 통합할 수 있다는 점은 챕터 1 테스트 주차 때 알게되었지만, 실제로 적용해 본 것은 이번이 처음이었습니다.</p>
<img width="614" height="842" alt="image" src="https://github.com/user-attachments/assets/dc590169-0963-4c14-8036-29f3beb08704"/>
<ul>
<li><code>.github/workflows/lighthouse.yml</code>을 작성하여 빌드 → 로컬 서버 실행 → Lighthouse 측정 → 결과 리포트(GitHub Issue) 생성의 전체 파이프라인을 자동화했습니다.</li>
<li>Performance, SEO 등의 점수 뿐만 아니라 Core Web Vitals(LCP, INP, CLS) 지표를 자동으로 이슈에 기록하도록 구현했습니다.</li>
<li><code>lighthouserc.js</code> 설정을 통해 성능 임계값을 설정하고, 기준 미달 시 CI를 실패하게 만드는 성능 회귀 감지 기능을 학습했습니다.</li>
</ul>
<p>성능은 한 번의 개선으로 끝나는 것이 아니라, 코드 변화에 따라 지속적으로 감시해야 하는 대상임을 깨달았습니다.
다만, CI 환경에서의 측정은 실제 사용자의 다양한 네트워크 환경과 디바이스 성능을 완벽히 대변할 수 없다는 환경적 한계를 인지했습니다.
이를 통해 진정한 의미의 성능 측정을 위해서는 배포된 프로덕션 환경에서의 모니터링이 병행되어야 함을 배웠습니다.</p>
<h2 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h2>
<!-- -->
<img width="872" height="724" alt="image" src="https://github.com/user-attachments/assets/421bbd2b-710c-4a73-9ee8-4caac570cc57"/>
<h3 id="1-context-provider-전역에서-로컬로-범위-축소"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-context-provider-전역에서-로컬로-범위-축소"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Context Provider: 전역에서 로컬로 범위 축소</h3>
<p>성능 저하의 주범이었던 &quot;전역 Provider&quot;의 범위를 필요한 컴포넌트 하위로 축소하여, 리렌더링의 영향 범위를 최소화했습니다.</p>
<ul>
<li>
<p>Before: 모든 곳에 영향을 주는 전역 Provider
<code>ScheduleDndProvider</code>가 App 최상단에 위치하여, 드래그 앤 드롭 이벤트 발생 시 실제 드래그가 일어나지 않는 다른 시간표까지 모두 리렌더링 범위에 포함되었습니다.</p>
</li>
<li>
<p>After: 필요한 곳에만 위치하는 로컬 Provider
<code>ScheduleDndProvider</code>를 각 <code>ScheduleBoard</code> 내부로 이동시켰습니다.</p>
</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/App.tsx - 최상단은 핵심 전역 설정만 유지</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>ChakraProvider<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>ScheduleProvider<span class="token operator">&gt;</span>
</span><span class="code-line">        <span class="token operator">&lt;</span>SchedulePage <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span><span class="token operator">/</span>ScheduleProvider<span class="token operator">&gt;</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>ChakraProvider<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// src/components/schedule/ScheduleBoard.tsx - 필요한 곳으로 Provider 이동</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleBoard <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tableId<span class="token punctuation">,</span> schedules<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token operator">:</span> ScheduleBoardProps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Stack width<span class="token operator">=</span><span class="token string">&quot;600px&quot;</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* 이제 드래그 관련 컨텍스트는 이 보드 내부에서만 유효함 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>ScheduleDndProvider<span class="token operator">&gt;</span>
</span><span class="code-line">        <span class="token operator">&lt;</span>ScheduleTable
</span><span class="code-line">          schedules<span class="token operator">=</span><span class="token punctuation">{</span>schedules<span class="token punctuation">}</span>
</span><span class="code-line">          tableId<span class="token operator">=</span><span class="token punctuation">{</span>tableId<span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span><span class="token operator">/</span>ScheduleDndProvider<span class="token operator">&gt;</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Stack<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// src/App.tsx - 최상단은 핵심 전역 설정만 유지
function App() {
  return (
    &lt;ChakraProvider&gt;
      &lt;ScheduleProvider&gt;
        &lt;SchedulePage /&gt;
      &lt;/ScheduleProvider&gt;
    &lt;/ChakraProvider&gt;
  );
}

// src/components/schedule/ScheduleBoard.tsx - 필요한 곳으로 Provider 이동
const ScheduleBoard = memo(({ tableId, schedules, ... }: ScheduleBoardProps) =&gt; {
  return (
    &lt;Stack width=&quot;600px&quot;&gt;
      {/* 이제 드래그 관련 컨텍스트는 이 보드 내부에서만 유효함 */}
      &lt;ScheduleDndProvider&gt;
        &lt;ScheduleTable
          schedules={schedules}
          tableId={tableId}
        /&gt;
      &lt;/ScheduleDndProvider&gt;
    &lt;/Stack&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>드래그 이벤트가 발생해도 해당 이벤트를 처리하는 보드 내부 컴포넌트들만 리렌더링됩니다.</li>
<li>다른 보드는 <code>ScheduleDndProvider</code>의 영향을 전혀 받지 않게 되어, 여러 개의 시간표가 존재하더라도 독립적인 성능을 보장할 수 있게 되었습니다.</li>
</ul>
<p>&quot;편리함&quot;을 위해 습관적으로 최상단에 <code>Provider</code>를 배치하는 것이 얼마나 큰 성능 비용을 초래하는지 알게 되었습니다.
Context는 가급적 사용되는 곳과 가장 가까운 부모에 배치해야 한다는 &quot;거리의 중요성&quot;을 깨달았습니다.</p>
<hr/>
<h3 id="2-context-api-cqrs-패턴을-통한-querycommand-분리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-context-api-cqrs-패턴을-통한-querycommand-분리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. Context API: CQRS 패턴을 통한 Query/Command 분리</h3>
<p>단순히 상태를 공유하는 것을 넘어, 상태와 변경 로직의 관심사를 분리하여 렌더링 효율을 극대화했습니다.</p>
<ul>
<li>
<p>Before: 단일 Context의 한계
상태(<code>schedulesMap</code>)와 액션(<code>setSchedulesMap</code>)이 하나의 객체로 묶여 있어, 상태를 변경하는 액션만 필요한 컴포넌트도 불필요하게 상태 변화를 구독해야 했습니다.
<code>value={{ schedulesMap, setSchedulesMap }}</code> 처럼 객체 리터럴을 전달하여, 매 렌더링마다 새로운 참조가 생성되는 구조였습니다.</p>
</li>
<li>
<p>After: CQRS 패턴 적용 (Query/Command 분리)
ScheduleContext: 현재 시간표 데이터 상태만 제공.
ScheduleAction: 상태를 변경하는 함수(<code>setSchedulesMap</code>)만 제공.
참조 최적화: value에 객체가 아닌 값/함수를 직접 전달하여 불필요한 참조 변경을 방지했습니다.</p>
</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 1. Context 분리 정의</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> ScheduleContext <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>ScheduleContextType <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> ScheduleAction <span class="token operator">=</span> <span class="token generic-function"><span class="token function">createContext</span><span class="token generic class-name"><span class="token operator">&lt;</span>ScheduleActionType <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 계층적 Provider 구성</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">ScheduleProvider</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> children <span class="token punctuation">}</span><span class="token operator">:</span> PropsWithChildren<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>schedulesMap<span class="token punctuation">,</span> setSchedulesMap<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span>Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Schedule<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span>dummyScheduleMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>ScheduleAction<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>setSchedulesMap<span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token comment">/* Command: 변경 함수만 전달 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>ScheduleContext<span class="token punctuation">.</span>Provider value<span class="token operator">=</span><span class="token punctuation">{</span>schedulesMap<span class="token punctuation">}</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token comment">/* Query: 상태값만 전달 */</span><span class="token punctuation">}</span>
</span><span class="code-line">        <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">&lt;</span><span class="token operator">/</span>ScheduleContext<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>ScheduleAction<span class="token punctuation">.</span>Provider<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. Context 분리 정의
export const ScheduleContext = createContext&lt;ScheduleContextType | undefined&gt;(undefined);
export const ScheduleAction = createContext&lt;ScheduleActionType | undefined&gt;(undefined);

// 2. 계층적 Provider 구성
export const ScheduleProvider = ({ children }: PropsWithChildren) =&gt; {
  const [schedulesMap, setSchedulesMap] = useState&lt;Record&lt;string, Schedule[]&gt;&gt;(dummyScheduleMap);

  return (
    &lt;ScheduleAction.Provider value={setSchedulesMap}&gt; {/* Command: 변경 함수만 전달 */}
      &lt;ScheduleContext.Provider value={schedulesMap}&gt; {/* Query: 상태값만 전달 */}
        {children}
      &lt;/ScheduleContext.Provider&gt;
    &lt;/ScheduleAction.Provider&gt;
  );
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>불필요한 구독 차단: 액션만 사용하는 컴포넌트는 데이터가 변경되어도 리렌더링되지 않습니다.</li>
<li>참조 안정성: <code>setSchedulesMap</code>은 <code>useState</code>에서 제공하는 안정적인 함수이므로, 이를 구독하는 컴포넌트들의 메모이제이션 성능이 향상되었습니다.</li>
</ul>
<p>상태와 액션을 구조적으로 분리하는 것만으로는 부족하며, **value 자체의 형태(Primitive vs Reference)**가 리액트의 <code>Object.is</code> 비교 알고리즘에 어떤 영향을 미치는지 깊이 이해하게 되었습니다.</p>
<hr/>
<h3 id="3-api-호출-최적화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-api-호출-최적화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. API 호출 최적화</h3>
<p>네트워크 지연 시간을 최소화하기 위해 비동기 로직을 개선하고, 불필요한 중복 요청을 원천 차단하는 시스템을 구축했습니다.</p>
<h4 id="promiseall의-올바른-사용---진정한-병렬-실행"><a class="anchor" aria-hidden="true" tabindex="-1" href="#promiseall의-올바른-사용---진정한-병렬-실행"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Promise.all의 올바른 사용 - 진정한 병렬 실행</h4>
<p>비동기 함수들을 한꺼번에 실행하려 할 때 발생했던 흔한 실수를 바로잡았습니다.</p>
<ul>
<li>Before: <code>Promise.all</code> 내부에서 각 요소에 <code>await</code>를 붙여 사실상 <strong>순차 실행</strong>이 되는 구조였습니다.</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">fetchAllLectures</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
</span><span class="code-line">  <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
</span><span class="code-line">    <span class="token punctuation">(</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#x27;API Call 1&#x27;</span><span class="token punctuation">,</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">fetchMajors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">(</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#x27;API Call 2&#x27;</span><span class="token punctuation">,</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">fetchLiberalArts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token comment">// ... 중복 호출</span>
</span><span class="code-line">  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const fetchAllLectures = async () =&gt;
  await Promise.all([
    (console.log(&#x27;API Call 1&#x27;, performance.now()), await fetchMajors()),
    (console.log(&#x27;API Call 2&#x27;, performance.now()), await fetchLiberalArts()),
    // ... 중복 호출
  ]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>After: <code>await</code>을 제거하고 Promise 객체 자체를 전달하여 브라우저가 동시에 여러 요청을 보낼 수 있도록 <strong>병렬 처리</strong>를 구현했습니다.</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/services/lectureService.ts</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">fetchAllLectures</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
</span><span class="code-line">    <span class="token function">fetchMajors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// await 없이 Promise만 전달</span>
</span><span class="code-line">    <span class="token function">fetchLiberalArts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 병렬 실행</span>
</span><span class="code-line">    <span class="token comment">// ...</span>
</span><span class="code-line">  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> results<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> result<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// src/services/lectureService.ts
export const fetchAllLectures = async () =&gt; {
  const results = await Promise.all([
    fetchMajors(), // await 없이 Promise만 전달
    fetchLiberalArts(), // 병렬 실행
    // ...
  ]);
  return results.flatMap(result =&gt; result.data);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="promise-레벨의-캐싱---cachedfetch-구현"><a class="anchor" aria-hidden="true" tabindex="-1" href="#promise-레벨의-캐싱---cachedfetch-구현"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Promise 레벨의 캐싱 - <code>cachedFetch</code> 구현</h4>
<p>동일한 API를 여러 번 호출할 때 발생하는 네트워크 낭비를 해결하기 위해 캐싱 레이어를 추가했습니다.</p>
<ul>
<li>
<p>Before: 동일한 데이터를 사용하는 여러 컴포넌트가 각각 독립적으로 API를 호출하여 불필요한 트래픽이 발생했습니다.</p>
</li>
<li>
<p>After: Map 객체를 활용하여 이미 진행 중이거나 완료된 Promise 자체를 캐싱하는 <code>cachedFetch</code>를 구현했습니다.
데이터가 아닌 Promise를 캐싱함으로써, 첫 번째 요청이 완료되기 전에 발생하는 중복 호출들까지도 동일한 Promise를 바라보게 설계했습니다.
요청 실패 시에는 캐시를 삭제하여 데이터 정합성을 유지하도록 처리했습니다.</p>
</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/lib/cachedFetch.ts</span>
</span><span class="code-line"><span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>AxiosResponse<span class="token operator">&gt;&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">cachedFetch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>AxiosResponse<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token operator">!</span> <span class="token keyword">as</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>AxiosResponse<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> promise <span class="token operator">=</span> axios<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
</span><span class="code-line">    response <span class="token operator">=&gt;</span> response<span class="token punctuation">,</span>
</span><span class="code-line">    error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">      cache<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 실패 시 캐시 무효화</span>
</span><span class="code-line">      <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// src/lib/cachedFetch.ts
const cache = new Map&lt;string, Promise&lt;AxiosResponse&gt;&gt;();

export function cachedFetch&lt;T&gt;(url: string): Promise&lt;AxiosResponse&lt;T&gt;&gt; {
  if (cache.has(url)) return cache.get(url)! as Promise&lt;AxiosResponse&lt;T&gt;&gt;;

  const promise = axios.get&lt;T&gt;(url).then(
    response =&gt; response,
    error =&gt; {
      cache.delete(url); // 실패 시 캐시 무효화
      throw error;
    },
  );
  cache.set(url, promise);
  return promise;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>기존 6번의 호출을 단 2번의 실제 네트워크 요청으로 압축했습니다.
또한 <code>performance.now()</code>를 통해 캐시 히트 시 응답 속도가 네트워크 요청 대비 압도적으로 빠르다는 것을 수치로 확인했습니다.</p>
<hr/>
<h3 id="4-함수형-업데이트를-통한-의존성-제거-및-참조-안정성-확보"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-함수형-업데이트를-통한-의존성-제거-및-참조-안정성-확보"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. 함수형 업데이트를 통한 의존성 제거 및 참조 안정성 확보</h3>
<p>상태 업데이트 시 외부 상태(<code>schedulesMap</code>)에 대한 직접적인 의존성을 제거하여, 함수가 불필요하게 재생성되는 것을 방지하고 성능을 최적화했습니다.</p>
<ul>
<li>
<p>Before: 외부 상태 직접 참조의 문제점
<code>handleDragEnd</code> 함수 내부에서 <code>schedulesMap</code>을 직접 참조하고 있어, 시간표 데이터가 바뀔 때마다 함수가 매번 새로 생성되어야 했습니다.
이로 인해 이 함수를 Props로 받는 모든 자식 컴포넌트들이 드래그 이벤트와 상관없이 리렌더링되는 성능 저하가 발생했습니다.</p>
</li>
<li>
<p>After: 함수형 업데이트<code>(setState(prev =&gt; ...))</code> 적용
<code>setSchedulesMap</code> 내부에 콜백 함수를 전달하여 이전 상태(prev)를 직접 참조하도록 수정했습니다.
덕분에 함수 외부의 <code>schedulesMap</code> 상태에 의존할 필요가 없어져, <code>useAutoCallback</code>의 의존성 배열을 비우고 함수 참조값을 영구적으로 고정할 수 있었습니다.</p>
</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/contexts/ScheduleDndProvider.tsx</span>
</span><span class="code-line"><span class="token keyword">const</span> handleDragEnd <span class="token operator">=</span> <span class="token function">useAutoCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token operator">:</span> DragEndEvent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> active<span class="token punctuation">,</span> delta <span class="token punctuation">}</span> <span class="token operator">=</span> event<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>tableId<span class="token punctuation">,</span> index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>active<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&#x27;:&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 함수형 업데이트로 이전 상태(prev)를 안전하게 사용</span>
</span><span class="code-line">  <span class="token function">setSchedulesMap</span><span class="token punctuation">(</span>prev <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> schedule <span class="token operator">=</span> prev<span class="token punctuation">[</span>tableId<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token function">Number</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">    <span class="token comment">// ... 로직 수행</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="token keyword">return</span> <span class="token punctuation">{</span>
</span><span class="code-line">      <span class="token operator">...</span>prev<span class="token punctuation">,</span>
</span><span class="code-line">      <span class="token punctuation">[</span>tableId<span class="token punctuation">]</span><span class="token operator">:</span> prev<span class="token punctuation">[</span>tableId<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>targetSchedule<span class="token punctuation">,</span> targetIndex<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">        <span class="token comment">// ... 업데이트 로직</span>
</span><span class="code-line">      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// src/contexts/ScheduleDndProvider.tsx
const handleDragEnd = useAutoCallback((event: DragEndEvent) =&gt; {
  const { active, delta } = event;
  const [tableId, index] = String(active.id).split(&#x27;:&#x27;);

  // 함수형 업데이트로 이전 상태(prev)를 안전하게 사용
  setSchedulesMap(prev =&gt; {
    const schedule = prev[tableId][Number(index)];
    // ... 로직 수행

    return {
      ...prev,
      [tableId]: prev[tableId].map((targetSchedule, targetIndex) =&gt; {
        // ... 업데이트 로직
      }),
    };
  });
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>참조 고정: 드래그 이벤트가 수없이 발생해도 handleDragEnd 함수의 참조가 변하지 않아 하위 컴포넌트의 불필요한 리렌더링을 완벽히 차단했습니다.</li>
<li>Stale State 방지: 항상 최신 상태인 prev 값을 기반으로 업데이트하므로, 비동기 상황에서도 데이터 정합성을 보장할 수 있게 되었습니다.</li>
</ul>
<p>상태 업데이트 로직을 짤 때 단순히 값을 넣는 것보다 함수형 업데이트를 활용하는 것이 메모이제이션 전략에 얼마나 큰 유연성을 주는지 깨달았습니다.
최적화는 단순히 훅을 쓰는 것이 아니라, 훅이 잘 작동할 수 있도록 로직의 구조를 설계하는 과정임을 배웠습니다.</p>
<hr/>
<h3 id="5-usememo-무거운-연산의-재사용과-불필요한-재계산-방지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#5-usememo-무거운-연산의-재사용과-불필요한-재계산-방지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. useMemo: 무거운 연산의 재사용과 불필요한 재계산 방지</h3>
<p>매 렌더링 시 반복되던 데이터 필터링 및 변환 로직을 useMemo로 메모이제이션하여 연산 비용을 획기적으로 줄였습니다.</p>
<ul>
<li>
<p>Before: 비효율적인 반복 연산
검색어 입력 등 상태가 바뀔 때마다 수백, 수천 개의 데이터가 포함된 <code>lectures</code> 배열에 대해 <code>filter</code>, <code>map</code>, <code>Set</code> 연산을 매번 수행했습니다.
렌더링과 연산이 결합되어 성능 병목의 원인이 되었습니다.</p>
</li>
<li>
<p>After: 의존성 기반의 연산 결과 캐싱
연산 결과가 바뀌어야 하는 정확한 시점(의존성 배열)을 명시하여, 불필요한 시점에는 캐싱된 값을 재사용하도록 개선했습니다.</p>
</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/components/search/SearchDialog.tsx</span>
</span><span class="code-line"><span class="token comment">// 1. 대량의 데이터 필터링 로직을 메모이제이션</span>
</span><span class="code-line"><span class="token keyword">const</span> filteredLectures <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">filterLectures</span><span class="token punctuation">(</span>lectures<span class="token punctuation">,</span> searchOptions<span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">[</span>lectures<span class="token punctuation">,</span> searchOptions<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// 원본 데이터나 검색 옵션이 바뀔 때만 실행</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 고비용의 데이터 변환(Unique 값 추출) 최적화</span>
</span><span class="code-line"><span class="token keyword">const</span> allMajors <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>lectures<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>lecture <span class="token operator">=&gt;</span> lecture<span class="token punctuation">.</span>major<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">[</span>lectures<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// lectures가 변경되지 않으면 즉시 캐시된 값 반환</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// src/components/schedule/ScheduleTable.tsx</span>
</span><span class="code-line"><span class="token comment">// 3. 지연된 값(deferredSchedules)을 기반으로 한 맵 생성</span>
</span><span class="code-line"><span class="token keyword">const</span> colorsMap <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">createScheduleColorMap</span><span class="token punctuation">(</span>deferredSchedules<span class="token punctuation">)</span><span class="token punctuation">,</span> 
</span><span class="code-line">  <span class="token punctuation">[</span>deferredSchedules<span class="token punctuation">]</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// src/components/search/SearchDialog.tsx
// 1. 대량의 데이터 필터링 로직을 메모이제이션
const filteredLectures = useMemo(
  () =&gt; filterLectures(lectures, searchOptions),
  [lectures, searchOptions], // 원본 데이터나 검색 옵션이 바뀔 때만 실행
);

// 2. 고비용의 데이터 변환(Unique 값 추출) 최적화
const allMajors = useMemo(
  () =&gt; [...new Set(lectures.map(lecture =&gt; lecture.major))],
  [lectures], // lectures가 변경되지 않으면 즉시 캐시된 값 반환
);

// src/components/schedule/ScheduleTable.tsx
// 3. 지연된 값(deferredSchedules)을 기반으로 한 맵 생성
const colorsMap = useMemo(
  () =&gt; createScheduleColorMap(deferredSchedules), 
  [deferredSchedules]
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>연산 비용 절감: 검색 옵션과 무관한 리렌더링 시에는 복잡한 필터링 로직이 실행되지 않아 CPU 점유율을 낮췄습니다.</li>
<li>참조 안정성 유지: <code>useMemo</code>로 반환된 배열이나 객체는 의존성이 바뀌지 않는 한 동일한 참조값을 유지하므로, 이를 Props로 받는 자식 컴포넌트(<code>memo</code> 적용된 컴포넌트)의 불필요한 리렌더링까지 연쇄적으로 방지했습니다.</li>
</ul>
<p><code>useMemo</code>는 단순히 &quot;값을 저장&quot;하는 용도를 넘어, 하위 컴포넌트로 전달되는 객체의 참조를 고정하여 리렌더링 체인을 끊어주는 중요한 역할을 한다는 것을 깨달았습니다.
성능 최적화는 개별 훅의 사용보다 훅들이 서로 얽혀 만드는 &quot;참조의 흐름&quot;을 관리하는 것임을 배웠습니다.</p>
<h2 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h2>
<!-- -->
<h3 id="1-context-api-객체-참조-최적화와-cqrs-패턴의-완성"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-context-api-객체-참조-최적화와-cqrs-패턴의-완성"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Context API: 객체 참조 최적화와 CQRS 패턴의 완성</h3>
<p>상태와 변경 로직을 분리하는 것에서 나아가, Context에 전달되는 value의 데이터 형태를 최적화하여 렌더링 성능을 개선했습니다.</p>
<pre class="language-diff"><code class="language-diff code-highlight"><span class="code-line">return (
</span><span class="code-line deleted"><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  &lt;ScheduleAction.Provider value={{ setSchedulesMap }}&gt;
</span></span></span><span class="code-line inserted"><span class="token deleted-sign deleted"><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &lt;ScheduleAction.Provider value={setSchedulesMap}&gt;
</span></span></span><span class="code-line deleted"><span class="token inserted-sign inserted"><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    &lt;ScheduleContext.Provider value={{ schedulesMap }}&gt;
</span></span></span><span class="code-line inserted"><span class="token deleted-sign deleted"><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    &lt;ScheduleContext.Provider value={schedulesMap}&gt;
</span></span></span><span class="code-line"><span class="token inserted-sign inserted"><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     {children}
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">   &lt;/ScheduleContext.Provider&gt;
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"> &lt;/ScheduleAction.Provider&gt;
</span></span></span><span class="code-line"><span class="token unchanged"><span class="token line"></span></span>);
</span></code><div class="copied" data-code="return (
-  &lt;ScheduleAction.Provider value={{ setSchedulesMap }}&gt;
+  &lt;ScheduleAction.Provider value={setSchedulesMap}&gt;
-    &lt;ScheduleContext.Provider value={{ schedulesMap }}&gt;
+    &lt;ScheduleContext.Provider value={schedulesMap}&gt;
      {children}
    &lt;/ScheduleContext.Provider&gt;
  &lt;/ScheduleAction.Provider&gt;
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<ul>
<li>객체 리터럴의 함정: 기존처럼 <code>value={{ schedulesMap }}</code>과 같이 객체 형태로 전달하면, 내부 값이 변하지 않더라도 매 렌더링마다 새로운 객체 참조가 생성되어 구독 중인 모든 하위 컴포넌트가 불필요하게 리렌더링되는 문제가 있었습니다.</li>
<li>참조 안정성 확보: value를 직접 값(원시값/함수) 형태로 전달하도록 변경했습니다. 이렇게 하면 <code>schedulesMap</code>이나 <code>setSchedulesMap</code> 자체가 실제로 바뀌지 않는 한 참조가 동일하게 유지되어 최적화 효과를 극대화할 수 있습니다.</li>
</ul>
<p>상태와 액션을 단순히 분리하는 구조적 설계뿐만 아니라, <strong>참조 무결성</strong>을 지키기 위해 전달하는 데이터의 형태까지 세밀하게 고려해야 진정한 최적화가 완성된다는 것을 깨달았습니다.</p>
<hr/>
<h3 id="2-reactmemo-컴포넌트-세분화와-메모이제이션의-시너지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-reactmemo-컴포넌트-세분화와-메모이제이션의-시너지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. <code>React.memo</code>: 컴포넌트 세분화와 메모이제이션의 시너지</h3>
<p>그동안 실무에서 <code>memo</code>를 잘 사용하지 않았는데, 이번 과제를 통해 <code>memo</code>가 업데이트가 잦은 환경에서 얼마나 큰 성능 이득을 주는지 <code>ScheduleGrid</code>에 적용하며 실감했습니다.</p>
<ul>
<li>
<p>Before: 데이터 변경에 휩쓸리는 정적 UI
<code>ScheduleTable</code> 내부에 시간표 그리드가 인라인으로 포함되어 있었습니다.
이로 인해 드래그 중 <code>schedules</code> 상태가 미세하게 변경될 때마다, 아무런 변화가 없는 배경 그리드까지 통째로 리렌더링되는 비효율이 발생했습니다.</p>
</li>
<li>
<p>After: 정적 UI의 컴포넌트 추출 및 메모이제이션
변경이 없는 그리드 부분을 <code>ScheduleGrid</code>로 별도 추출하고 <code>memo</code>를 적용했습니다.</p>
</li>
</ul>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 1. 부모 컴포넌트: 업데이트가 빈번한 schedules를 관리</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleTable <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> tableId<span class="token punctuation">,</span> schedules<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token operator">:</span> Props<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Box<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* ScheduleGrid는 memo 덕분에 부모가 리렌더링되어도 유지됨 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>ScheduleGrid onScheduleTimeClick<span class="token operator">=</span><span class="token punctuation">{</span>onScheduleTimeClick<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span>deferredSchedules<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>schedule<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
</span><span class="code-line">        <span class="token operator">&lt;</span>ScheduleItem key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>schedule<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Box<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 자식 컴포넌트: 정적인 배경 그리드</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleGrid <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> onScheduleTimeClick <span class="token punctuation">}</span><span class="token operator">:</span> ScheduleGridProps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Grid<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* 한 번 렌더링되면 props 변경 전까지 리렌더링 차단 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token constant">DAY_LABELS</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>day <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
</span><span class="code-line">        <span class="token operator">&lt;</span>GridItem key<span class="token operator">=</span><span class="token punctuation">{</span>day<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>day<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>GridItem<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Grid<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. 부모 컴포넌트: 업데이트가 빈번한 schedules를 관리
const ScheduleTable = memo(({ tableId, schedules, ... }: Props) =&gt; {
  return (
    &lt;Box&gt;
      {/* ScheduleGrid는 memo 덕분에 부모가 리렌더링되어도 유지됨 */}
      &lt;ScheduleGrid onScheduleTimeClick={onScheduleTimeClick} /&gt;
      {deferredSchedules.map((schedule, index) =&gt; (
        &lt;ScheduleItem key={index} {...schedule} /&gt;
      ))}
    &lt;/Box&gt;
  );
});

// 2. 자식 컴포넌트: 정적인 배경 그리드
const ScheduleGrid = memo(({ onScheduleTimeClick }: ScheduleGridProps) =&gt; {
  return (
    &lt;Grid&gt;
      {/* 한 번 렌더링되면 props 변경 전까지 리렌더링 차단 */}
      {DAY_LABELS.map(day =&gt; (
        &lt;GridItem key={day}&gt;{day}&lt;/GridItem&gt;
      ))}
    &lt;/Grid&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>드래그 중 수많은 상태 업데이트가 발생해도 배경 그리드는 <code>memo</code> 덕분에 단 한 번의 리렌더링도 발생하지 않는 것을 확인했습니다.
또한 <code>SearchDialog</code>의 각 폼 컨트롤들을 개별 <code>memo</code>로 감싸, 옵션 하나를 바꿀 때 해당 컴포넌트만 정밀하게 리렌더링되도록 최적화한 과정에서도 <code>memo</code>의 위력을 체감했습니다.</p>
<p>&quot;변하는 것&quot;과 &quot;변하지 않는 것&quot;을 명확히 구분하여 컴포넌트를 설계하는 것이 최적화의 핵심임을 배웠습니다.</p>
<hr/>
<h3 id="3-조건부-렌더링-무거운-컴포넌트의-생명주기-제어"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-조건부-렌더링-무거운-컴포넌트의-생명주기-제어"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 조건부 렌더링: 무거운 컴포넌트의 생명주기 제어</h3>
<p>시간표의 각 일정(<code>ScheduleItem</code>)마다 포함된 <code>Popover</code>가 닫혀 있을 때도 리소스를 점유하던 문제를 해결하며, 컴포넌트의 존재 유무가 성능에 미치는 영향을 학습했습니다.</p>
<ul>
<li>
<p>Before: 보이지 않는 UI의 리소스 점유
모든 일정에 <code>Popover</code>가 감싸져 있어, 사용자가 열지 않은 상태에서도 수십 개의 <code>Popover</code> 컴포넌트가 메모리에 올라가 있었습니다.
이로 인해 시간표 데이터 변경 시, 화면에 보이지 않는 <code>Popover</code> 내부 콘텐츠까지 함께 리렌더링되는 비효율이 발생했습니다.</p>
</li>
<li>
<p>After: isOpen 기반의 지연 렌더링(Lazy Loading)
재윤에게 얻은 꿀팁으로 <code>isOpen</code> 상태에 따른 조건부 렌더링을 적용했습니다.
또한 Chakra UI의 <code>isLazy</code>, <code>lazyBehavior=&quot;unmount&quot;</code> 옵션을 적용했습니다.</p>
</li>
</ul>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// src/components/schedule/ScheduleItem.tsx</span>
</span><span class="code-line"><span class="token keyword">const</span> ScheduleItem <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> data<span class="token punctuation">,</span> bg<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token operator">:</span> ScheduleItemProps<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> isOpen<span class="token punctuation">,</span> onToggle<span class="token punctuation">,</span> onClose <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useDisclosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 열려 있을 때만 Popover 관련 무거운 로직을 수행하고, 닫히면 언마운트 처리</span>
</span><span class="code-line">  <span class="token keyword">return</span> isOpen <span class="token operator">?</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token operator">&lt;</span>Popover isOpen<span class="token operator">=</span><span class="token punctuation">{</span>isOpen<span class="token punctuation">}</span> onClose<span class="token operator">=</span><span class="token punctuation">{</span>onClose<span class="token punctuation">}</span> isLazy lazyBehavior<span class="token operator">=</span><span class="token string">&quot;unmount&quot;</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>PopoverTrigger<span class="token operator">&gt;</span><span class="token punctuation">{</span>content<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>PopoverTrigger<span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span>PopoverContent<span class="token operator">&gt;</span>
</span><span class="code-line">        <span class="token operator">&lt;</span>ScheduleDetailContent data<span class="token operator">=</span><span class="token punctuation">{</span>data<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</span><span class="code-line">      <span class="token operator">&lt;</span><span class="token operator">/</span>PopoverContent<span class="token operator">&gt;</span>
</span><span class="code-line">    <span class="token operator">&lt;</span><span class="token operator">/</span>Popover<span class="token operator">&gt;</span>
</span><span class="code-line">  <span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>
</span><span class="code-line">    content <span class="token comment">// 평상시에는 순수 일정 뷰만 렌더링</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// src/components/schedule/ScheduleItem.tsx
const ScheduleItem = memo(({ id, data, bg, ... }: ScheduleItemProps) =&gt; {
  const { isOpen, onToggle, onClose } = useDisclosure();

  // 열려 있을 때만 Popover 관련 무거운 로직을 수행하고, 닫히면 언마운트 처리
  return isOpen ? (
    &lt;Popover isOpen={isOpen} onClose={onClose} isLazy lazyBehavior=&quot;unmount&quot;&gt;
      &lt;PopoverTrigger&gt;{content}&lt;/PopoverTrigger&gt;
      &lt;PopoverContent&gt;
        &lt;ScheduleDetailContent data={data} /&gt;
      &lt;/PopoverContent&gt;
    &lt;/Popover&gt;
  ) : (
    content // 평상시에는 순수 일정 뷰만 렌더링
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>조건부 렌더링 적용으로 열리지 않은 팝업은 DOM에 존재하지 않게 되어 메모리 사용량이 줄어들고, 부모의 리렌더링 전파 범위가 획기적으로 좁아졌습니다.</p>
<p>단순히 CSS(display: none)로 컴포넌트를 가리는 것과 컴포넌트 트리에서 아예 제거(Unmount)하는 것의 결정적인 성능 차이를 이해했습니다.
&quot;언제 렌더링할 것인가&quot;뿐만 아니라 &quot;언제 렌더링하지 않을 것인가&quot;를 결정하는 것이 고도화된 최적화의 시작임을 깨달았습니다.</p>
<h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<!-- -->
<p>발제 때 공개 처형(?)을 당해서 너무 부끄러웠는데, 오히려 그 덕에 &quot;이번에는 진짜 제대로 파헤쳐 보자&quot;는 강력한 동기부여가 된 것 같습니다 ㅎㅎ
평소 실무에서 우선순위에 밀려 놓치고 있었던 성능 최적화의 기술적 갈증을 이번 기회에 아낌없이 풀 수 있었습니다.
코드 레벨의 세밀한 기법부터 시스템적인 모니터링까지, 5년간 고민했던 숙제들을 한 번에 해결한 것 같은 쾌감을 느꼈습니다.</p>
<p>특히 좋았던 점은 &quot;이러면 빨라지겠지?&quot; 라는 막연한 추측이 아닌 <strong>측정 → 원인 파악 → 검증</strong> 사이클을 몸소 체험하며 최적화에 대한 자신감을 얻은 부분이었습니다.</p>
<p>마지막 과제까지 정말 하나도 쉬운 게 없었지만, 덕분에 10주간 정말 많이 배웠고, 성장할 수 있었습니다.
그동안 정말 감사했습니다. 고생하셨습니다!</p>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<!-- -->
<h3 id="1-useautocallback-패턴의-프로덕션-적용-가능성"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-useautocallback-패턴의-프로덕션-적용-가능성"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. <code>useAutoCallback</code> 패턴의 프로덕션 적용 가능성</h3>
<p>현재 적용한 <code>useAutoCallback</code> 훅을 <code>useCallback</code>의 의존성 배열 문제를 해결하는 실용적인 패턴으로 이해해도 될까요?
그리고 실제 프로덕션 환경에서 사용해도 안전한지 궁금합니다!
특히 <code>useRef</code>를 사용하여 최신 콜백을 참조하는 방식이 React의 모범 사례와 일치하는지, 그리고 React Compiler가 도입되면 이런 패턴이 불필요해질지 의견을 듣고 싶습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> useAutoCallback <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Parameters<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> callbackRef <span class="token operator">=</span> <span class="token generic-function"><span class="token function">useRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  callbackRef<span class="token punctuation">.</span>current <span class="token operator">=</span> callback<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Parameters<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> callbackRef<span class="token punctuation">.</span>current<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const useAutoCallback = &lt;T extends (...args: Parameters&lt;T&gt;) =&gt; ReturnType&lt;T&gt;&gt;(callback: T) =&gt; {
  const callbackRef = useRef&lt;T&gt;(callback);
  callbackRef.current = callback;
  return useCallback((...args: Parameters&lt;T&gt;) =&gt; callbackRef.current?.(...args), []);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="2-context-분리-구조의-확장성과-대안"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-context-분리-구조의-확장성과-대안"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. Context 분리 구조의 확장성과 대안</h3>
<p>Context를 상태와 액션으로 분리한 구조가 적절한지, 그리고 더 나은 대안이 있는지 조언을 받고 싶습니다.
현재는 <code>useScheduleContext</code>와 <code>useScheduleAction</code>을 별도로 호출해야 하는데, 이를 하나의 훅으로 통합하면서도 리렌더링을 최적화할 수 있는 방법이 있을까요?
Redux의 <code>useSelector</code> 패턴처럼 선택적으로 상태를 구독하는 방식이 더 나을지, 아니면 현재 구조가 더 적절한지 실무 경험을 바탕으로 의견을 듣고 싶습니다.</p>
<h3 id="3-usedeferredvalue-vs-starttransition-선택-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-usedeferredvalue-vs-starttransition-선택-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. <code>useDeferredValue</code> vs <code>startTransition</code> 선택 기준</h3>
<p><code>useDeferredValue</code>를 <code>schedules</code>에 적용한 것이 적절한 선택이었는지, 그리고 드래그 중 렌더링 최적화를 위해 다른 방법을 고려해야 할지 의견을 듣고 싶습니다.
<code>useDeferredValue</code>와 <code>useTransition</code>/<code>startTransition</code>의 차이점과 각각의 사용 시점, 그리고 드래그 앤 드롭 같은 인터랙션에서는 어떤 것이 더 적합한지 구체적인 가이드라인이 있을까요?</p>
<h3 id="4-성능-최적화의-우선순위와-측정-방법"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-성능-최적화의-우선순위와-측정-방법"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. 성능 최적화의 우선순위와 측정 방법</h3>
<p>여러 최적화 기법을 적용했는데, 실제로 어떤 최적화가 가장 큰 효과를 가져다주는지 궁금합니다.
API 캐싱, 연산 메모이제이션, 리렌더링 최적화 중 어떤 것이 가장 중요할까요?
그리고 실무에서는 어떤 최적화부터 시작하는 것이 좋을지, React DevTools Profiler나 다른 도구를 활용하여 정량적으로 효과를 측정하는 방법이 있을지 조언을 받고 싶습니다.</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>고생하셨습니다! 다솜님</p>
<p>리액트 내부 코드 관점에서 성능적인 부분들을 잘 챙겨서 봐주신 것 같아요.
아마 리액트 내부 코드를 직접 작성하면서 공부했던 내용들의 연장선상으로 볼 수 있을 것 같은데요. 값에 따라 우선순위를 조절하고 여러 디버깅, 성능 도구들을 활용해서 측정해보는 경험이 매우 좋아보입니다. 실제로 현업에서도 사용하는 방식이기도 하구요. 최근 컴파일러에서 많은 부분들을 해주기 때문에 의미가 조금 희석될 수 있지만, 그럼에도 의미가 있을거에요.
개발자 도구에서 메모이제이션 되는것들이 시각화되니까 그런것들을 목적에 맞게 보면 좋을것 같구요.</p>
<blockquote>
<ol>
<li>useAutoCallback 패턴의 프로덕션 적용 가능성</li>
</ol>
</blockquote>
<p>말씀대로 컴파일러에서 커버가 가능한 부분일 수 있을 것 같은데요!
비슷한 얘기일것 같은데 최근 추가된 요거! 한번 보시면 좋을것 같습니다.
<a href="https://ko.react.dev/reference/react/useEffectEvent">https://ko.react.dev/reference/react/useEffectEvent</a></p>
<blockquote>
<ol start="2">
<li>Context 분리 구조의 확장성과 대안</li>
</ol>
</blockquote>
<p>지금의 구조도 나쁘지 않은 것 같아요. 실제 더 나은 개선법들이 궁금하다면 이전에 말씀드렸었던 리액트 훅을 활용한 마이크로 상태관리 라는 책 또는 zustand나 jotai의 내부 구현을 봐봐도 좋을것 같아요!</p>
<blockquote>
<ol start="3">
<li>useDeferredValue vs startTransition 선택 기준</li>
</ol>
</blockquote>
<p>둘의 사용 사례는 명확하게 다른걸로 알고 있습니다. 값이냐 아니냐라는 기준으로요. 결국 레인 내에서 우선순위를 다르게 가져가고 렌더링에서 다르게 처리하지만, 과하게 사용하면 오히려 성능적인 이점을 줄이기 어렵다고 해서 잘 선별해서 골라서 사용해야 한다고 알고 있어요. 사실 엄청 큰 기대하는 만큼의 성능 개선이 있을까 싶기도하구요.. 선택에 대해서 더 궁금하다면 관련해서 가이드 문서를 보면 충분히 비교가 될 것 같아요!</p>
<blockquote>
<ol start="4">
<li>성능 최적화의 우선순위와 측정 방법</li>
</ol>
</blockquote>
<p>과한 최적화는 디버깅을 어렵게합니다. 특히 FE측의 최적화들, 메모이제이션들에 해당되는 부분들은 그런거같아요. 미연에 방지할 수 있는 너무 명백한 부분에 대해서만 먼저 대응하고 성능적인 이슈가 발생했을 때 그 후에 대응을 하는게 필요합니다. 뭐가 더 유의미하고 하다기보다는 문제가 생길때 대응을 하는 방식을 검토한다고 보면 좋을것 같아요.
모든 최적화는 문제를 명확하게 하고 진행이 되어야 합니다. 말씀해주신 프로파일러나 크롬 개발자도구의 퍼포먼스 탭같은 것들을 기준으로 우선 파악을 하고 명확하게 한다음 수정하고 검토하는 반복을 거치면서 개선하시면 좋을것 같아요.</p>
<p>오늘 내로 채점을 마쳐야 해서 시간에 쫓기고 있는데..  혹시나 답변이 조금 모호하거나 더 알고 싶은 내용이 있다면 편하게 알려주세요! 10주간 고생 정말 많이 하셨습니다. 앞으로도 화이팅입니다~~</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 - 고다솜 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 고다솜, [2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 - 고다솜 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 고다솜님이 제출한 [2팀 고다솜] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-RTTRX4Ru.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
