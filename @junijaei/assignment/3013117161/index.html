<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@junijaei/" data-discover="true">junijaei<!-- --> 님의 상세페이지</a> ＞ <!-- -->[2팀 전희재] Chapter2-2. 나만의 React 만들기</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[2팀 전희재] Chapter2-2. 나만의 React 만들기</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->junijaei</span><span>2025.11.15</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://junijaei.github.io/front_7th_chapter2-2/">https://junijaei.github.io/front_7th_chapter2-2/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="phase-1-vnode와-기초-유틸리티"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-1-vnode와-기초-유틸리티"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 1: VNode와 기초 유틸리티</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/elements.ts</code>: <code>createElement</code>, <code>normalizeNode</code>, <code>createChildPath</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/validators.ts</code>: <code>isEmptyValue</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/equals.ts</code>: <code>shallowEquals</code>, <code>deepEquals</code></li>
</ul>
<h4 id="phase-2-컨텍스트와-루트-초기화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-2-컨텍스트와-루트-초기화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 2: 컨텍스트와 루트 초기화</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/types.ts</code>: VNode/Instance/Context 타입 선언</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 루트/훅 컨텍스트와 경로 스택 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/setup.ts</code>: 컨테이너 초기화, 컨텍스트 리셋, 루트 렌더 트리거</li>
</ul>
<h4 id="phase-3-dom-인터페이스-구축"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-3-dom-인터페이스-구축"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 3: DOM 인터페이스 구축</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: 속성/스타일/이벤트 적용 규칙, DOM 노드 탐색/삽입/제거</li>
</ul>
<h4 id="phase-4-렌더-스케줄링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-4-렌더-스케줄링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 4: 렌더 스케줄링</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/enqueue.ts</code>: <code>enqueue</code>, <code>withEnqueue</code>로 마이크로태스크 큐 구성</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/render.ts</code>: <code>render</code>, <code>enqueueRender</code>로 루트 렌더 사이클 구현</li>
</ul>
<h4 id="phase-5-reconciliation"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-5-reconciliation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 5: Reconciliation</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/reconciler.ts</code>: 마운트/업데이트/언마운트, 자식 비교, key/anchor 처리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: Reconciliation에서 사용할 DOM 재배치 보조 함수 확인</li>
</ul>
<h4 id="phase-6-기본-hook-시스템"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-6-기본-hook-시스템"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 6: 기본 Hook 시스템</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/hooks.ts</code>: 훅 상태 저장, <code>useState</code>, <code>useEffect</code>, cleanup/queue 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 훅 커서 증가, 방문 경로 기록, 미사용 훅 정리</li>
</ul>
<p><strong>기본 과제 완료 기준</strong>: <code>basic.equals.test.tsx</code>, <code>basic.mini-react.test.tsx</code> 전부 통과</p>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<h4 id="phase-7-확장-hook--hoc"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-7-확장-hook--hoc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 7: 확장 Hook &amp; HOC</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useRef.ts</code>: ref 객체 유지</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useMemo.ts</code>, <code>hooks/useCallback.ts</code>: shallow 비교 기반 메모이제이션</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useDeepMemo.ts</code>, <code>hooks/useAutoCallback.ts</code>: deep 비교/자동 콜백 헬퍼</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hocs/memo.ts</code>, <code>hocs/deepMemo.ts</code>: props 비교 기반 컴포넌트 메모이제이션</li>
</ul>
<hr/>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p>이번 과제는 스스로 진행 단계를 나눠서 진행해보았다.</p>
<ol>
<li><strong>AI로 처음부터 끝까지 구현하기</strong></li>
<li><strong>구현된 내용을 바탕으로 개념 학습</strong></li>
<li><strong>리셋 후 처음부터 다시 구현하기</strong></li>
</ol>
<p>AI로 먼저 구현해본 이유는 처음부터 직접 구현하기엔 과제를 통과하지 못할까봐 걱정이 되어서였다.
이전 과제에서는 실제 동작 원리를 제대로 이해하지 못한 채 통과에만 급급해 코드를 구현했다가 코드 퀄리티를 신경쓰지 못했었다.
이번에는 간단하게라도 개념 학습을 한 뒤에 처음부터 다시 구현하는 방향을 선택했다.</p>
<hr/>
<h3 id="1-ai로-처음부터-끝까지-구현하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-ai로-처음부터-끝까지-구현하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. AI로 처음부터 끝까지 구현하기</h3>
<p><code>소요시간: 1시간</code></p>
<p>우선 Claude code init 명령어를 실행해 전체 프로젝트를 파악하게끔 했다.
AI에게 테스트 코드 범위를 작게 나눠 지정했고, 해당 테스트를 통과할때까지 기능을 구현해달라고 요청했다.
작업 과정에서 최대한 과제 설명에 적힌 phase를 따라가려 했으며 규모가 작은 기능에서 규모가 큰 기능 순서로 진행했다.
주석과 제공된 과제 문서를 최대한 참고해 구현해달라 하니 큰 문제없이 과제에 통과했다.</p>
<hr/>
<h3 id="2-구현된-내용을-바탕으로-개념-학습"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-구현된-내용을-바탕으로-개념-학습"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 구현된 내용을 바탕으로 개념 학습</h3>
<p><code>소요시간: 하루</code></p>
<p>코드를 분석하기에 앞서, 과제 문서를 다시 읽으며 리액트의 기본 원리를 익혔고, 학습하다 모르는 부분이 나오면 해당 용어를 정리하며 학습했다.</p>
<h4 id="새롭게-익힌-사전-지식"><a class="anchor" aria-hidden="true" tabindex="-1" href="#새롭게-익힌-사전-지식"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>새롭게 익힌 사전 지식</h4>
<p><strong>웹 컴포넌트와 그 종류 (Custom Element, HTML template, Shadow Dom)</strong></p>
<ul>
<li><strong>Custom Element</strong>: 기본 HTML 요소들을 상속받아 사용자가 새롭게 정의한 컴포넌트 클래스</li>
<li><strong>HTML template, slot</strong>: <code>&lt;template&gt;</code>은 렌더되지 않는 정적 DOM 구조 저장용 컨테이너, <code>&lt;slot&gt;</code>은 <code>Shadow DOM</code> 내부에 외부 자식을 투입하는 지점
<ul>
<li>(template과 slot은 Vue를 통해 먼저 접했던 단어들이라서, 굉장히 신기했다! 실제 Vue 구현에 웹 컴포넌트가 사용되었나 찾아봤는데, 그렇지는 않고 이름만 따왔다고 한다.)</li>
</ul>
</li>
<li><strong>Shadow DOM</strong>: HTML 요소 내부에 외부와 격리되어 독립적으로 존재하는 DOM 트리</li>
</ul>
<p><strong>React의 렌더링 알고리즘</strong></p>
<ul>
<li><strong>Reconciliation</strong>: 재조정. React의 Virtual DOM과 실제 DOM 트리를 비교하여 변경지점을 찾아내는 알고리즘. React의 Reconciliation에는 몇가지 특징이 있다.
<ul>
<li>완벽한 비교보다는 휴리스틱을 이용한 성능 최적화</li>
<li>노드의 타입이 다르면 노드를 완전히 교체한다.</li>
<li>타입이 같으면 자식 노드를 재귀적으로 비교한다.</li>
<li>자식 노드들은 key로 식별하여 효율적으로 업데이트된다.</li>
<li>위 내용들은 <a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3/files#diff-8d50c579a499434fe5b97e7b577e2d523461d8d9a71f3d49f80f79fa76e38d0d">packages/react/src/core/reconciler.ts</a>에 구현함.</li>
</ul>
</li>
<li><strong>Fiber</strong>: 기존의 스택 기반 reconciler를 대체해 React 16에 도입된 렌더링 방식. UI 렌더링 작업을 분할해 우선순위를 조절하며 중단과 재개가 가능한 비동기 렌더링을 제공.
<ul>
<li>Fiber Node: React 컴포넌트 및 요소를 나타내는 단위 객체</li>
<li>Fiber Tree: 현재의 상태를 나타내는 <code>current</code> 트리와 업데이트 중인 상태인 <code>work-in-progress</code> 트리가 서로 교차 사용됨.</li>
<li>스케줄링: 우선순위가 높은 작업을 먼저 처리하며, 필요시 작업을 중단했다 나중에 이어갈 수 있음.</li>
<li>렌더와 커밋 단계: 렌더 단계에서 DOM 트리 생성 -&gt; 커밋 단계에서 실제 DOM에 반영</li>
<li>Fiber는 구현하지 못함..! 현재 코드는 Stack reconciler 기반 구현, Fiber로 구현하려면 children 자료구조가 LinkedList 형식이어야 함.</li>
</ul>
</li>
</ul>
<p>참고자료</p>
<ul>
<li><a href="https://www.chan9yu.dev/posts/react-core-deep-dive">리액트를 까본 사람 손 🙋 (Virtual DOM부터 Fiber까지)</a></li>
<li><a href="https://developer.mozilla.org/ko/docs/Web/API/Web_components/Using_custom_elements">사용자 정의 요소 사용하기</a></li>
<li><a href="https://blog.revillweb.com/open-vs-closed-shadow-dom-9f3d7427d1af">Open vs. Closed Shadow DOM</a></li>
<li>과제 글들</li>
</ul>
<hr/>
<h3 id="3-리셋-후-처음부터-다시-구현하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-리셋-후-처음부터-다시-구현하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 리셋 후 처음부터 다시 구현하기</h3>
<p><code>소요시간: 3~4일</code></p>
<p>기본적인 지식만 익힌 후에 바로 개발에 착수했다.
더 디테일한 내용들은 직접 코드를 구현하면서 익히는게 학습에 더 도움이 될 것 같다는 판단때문이었다.
물론 100% 직접 구현은 아니고, AI에게 힌트를 많이 받았다.</p>
<p>내가 선택한 작업 방식은 다음과 같았다.</p>
<ol>
<li>AI에게 내가 구현하고 싶은 코드의 <strong>가이드 문서를 요청</strong>한다.
<ul>
<li>이때 코드 전체를 답해주기보단 동작 원리와 흐름에 대한 설명에 집중해달라고 요청했다.</li>
</ul>
</li>
<li><strong>직접 구현</strong>한 뒤, 구현한 부분에 해당하는 <strong>테스트를 계속 실행</strong>해보며 잘못 구현된 부분을 수정한다.</li>
<li>AI에게 내가 구현한 코드에 대한 <strong>피드백을 요청</strong>한다.
<ul>
<li>이때 일관적인 문서 퀄리티를 위해 <a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3/files#diff-5d8940c0f91db5d1d850f3eca8d85a636a8ea25a71a34e1b23fc2bed6a7ab59a">피드백 문서 생성 에이전트</a>를 생성했다.</li>
<li>피드백 문서의 양식은 간단하게 <code>현재 코드</code>, <code>잘 구현한 점</code>, <code>개선 사항</code>, <code>앞으로의 방향</code>을 작성하도록 했다.</li>
</ul>
</li>
<li>피드백 문서를 읽고 이해가 안되는 부분이 있다면 <strong>추가 질문</strong>을 한다.</li>
<li>피드백 문서 생성 에이전트가 <strong>추가 질문에 대한 답을 문서 하단에 추가</strong>한다.</li>
</ol>
<p>처음부터 위의 방식으로 가야겠다고 정한 건 아니었고, 과제를 하며 프로세스를 다듬다보니 지금의 단계적 방식이 자리 잡게 됐다.
현실적인 개발 기한을 맞추면서도 AI 의존도를 낮추려는 나름대로의 시도였다.
예상 밖의 효과도 있었다.
구현 과정에서 혼란스러웠던 개념, 판단 근거, 수정 내역 등이 문서 형태로 축적되면서 당시의 사고 과정이 자연스럽게 기록됐다.
학습 흐름 전체가 기록으로 남아 이후 회고글에도 활용할 수 있게 되었다는 게 가장 만족스러운 포인트였다.</p>
<hr/>
<h2 id="아하-모먼트-a-ha-moment"><a class="anchor" aria-hidden="true" tabindex="-1" href="#아하-모먼트-a-ha-moment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>아하! 모먼트 (A-ha! Moment)</h2>
<h3 id="1-훅과-훅-커서---react-hook의-작동-원리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-훅과-훅-커서---react-hook의-작동-원리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 훅과 훅 커서 - React Hook의 작동 원리</h3>
<p>Hook의 내부 구현에 대해 깊게 생각해본 적이 없었다.
막연하게 &quot;뭔가 복잡한 로직&quot;을 쓸 거라고 생각했어서, <code>context</code>라는 전역 변수에 값을 할당하는 방식이란걸 알게 됐을 때 신기했다.</p>
<h4 id="-hook-storage의-구조"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-hook-storage의-구조"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>💡 Hook Storage의 구조</h4>
<p>구현을 통해 알게 된 Hook의 실제 구조는 다음과 같다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// context.hooks.state의 구조</span>
</span><span class="code-line">context<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>state <span class="token operator">=</span> Map<span class="token operator">&lt;</span>path<span class="token punctuation">,</span> hookArray<span class="token operator">&gt;</span>
</span><span class="code-line"><span class="token comment">// 예시:</span>
</span><span class="code-line"><span class="token comment">// &quot;Parent&quot; → [nameState, ageState]</span>
</span><span class="code-line"><span class="token comment">// &quot;Parent.c0&quot; → [postState]</span>
</span></code><div class="copied" data-code="// context.hooks.state의 구조
context.hooks.state = Map&lt;path, hookArray&gt;
// 예시:
// &quot;Parent&quot; → [nameState, ageState]
// &quot;Parent.c0&quot; → [postState]
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>핵심 개념:</strong></p>
<ul>
<li><code>context.hooks.state</code>는 <strong>Map</strong> 구조</li>
<li><strong>Key</strong>: 컴포넌트의 고유 경로(path)</li>
<li><strong>Value</strong>: 해당 컴포넌트의 Hook 배열</li>
<li><strong>Cursor</strong>: 현재 어떤 Hook을 실행 중인지 추적하는 인덱스</li>
</ul>
<blockquote>
<p>💭 <strong>개인적인 팁</strong>: <code>hooks.state</code>를 &quot;Hook Storage&quot;라고 생각하니 훨씬 이해가 쉬웠다. 말 그대로 Hook 값들을 저장하는 창고 역할이기 때문이다.</p>
</blockquote>
<hr/>
<h4 id="-실행-흐름-예시"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-실행-흐름-예시"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>📖 실행 흐름 예시</h4>
<p>다음과 같은 컴포넌트 구조가 있다고 가정했을 때:</p>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Parent</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Child</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Parent</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="&lt;Parent&gt;
  &lt;Child /&gt;
  &lt;Child /&gt;
&lt;/Parent&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// Parent.tsx</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#x27;&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// Child.tsx</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>post<span class="token punctuation">,</span> setPost<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&#x27;&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>post<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// Parent.tsx
function Parent() {
  const [name, setName] = useState(&#x27;&#x27;);
  const [age, setAge] = useState(0);
  return &lt;div&gt;{children}&lt;/div&gt;;
}

// Child.tsx
function Child() {
  const [post, setPost] = useState(&#x27;&#x27;);
  return &lt;div&gt;{post}&lt;/div&gt;;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h5 id="전체-실행-순서"><a class="anchor" aria-hidden="true" tabindex="-1" href="#전체-실행-순서"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>전체 실행 순서</h5>
<pre><code class="code-highlight"><span class="code-line">1️⃣ Parent 컴포넌트 렌더링 시작
</span><span class="code-line">   │
</span><span class="code-line">   ├─ Hook Storage 조회: path = &quot;Parent&quot;
</span><span class="code-line">   │  └─ Hook 배열 반환: [name, age]
</span><span class="code-line">   │
</span><span class="code-line">   ├─ Cursor 초기화: 0
</span><span class="code-line">   │
</span><span class="code-line">   ├─ useState() 호출 #1
</span><span class="code-line">   │  ├─ cursor = 0 → hooks[0] = name
</span><span class="code-line">   │  └─ cursor 증가 → 1
</span><span class="code-line">   │
</span><span class="code-line">   ├─ useState() 호출 #2
</span><span class="code-line">   │  ├─ cursor = 1 → hooks[1] = age
</span><span class="code-line">   │  └─ cursor 증가 → 2
</span><span class="code-line">   │
</span><span class="code-line">   └─ 자식 컴포넌트 렌더링 시작
</span><span class="code-line">       │
</span><span class="code-line">       2️⃣ Child 컴포넌트 #1 렌더링
</span><span class="code-line">          │
</span><span class="code-line">          ├─ Hook Storage 조회: path = &quot;Parent.c0&quot;
</span><span class="code-line">          │  └─ Hook 배열 반환: [post]
</span><span class="code-line">          │
</span><span class="code-line">          ├─ Cursor 초기화: 0
</span><span class="code-line">          │
</span><span class="code-line">          └─ useState() 호출 #1
</span><span class="code-line">             ├─ cursor = 0 → hooks[0] = post
</span><span class="code-line">             └─ cursor 증가 → 1
</span><span class="code-line">
</span><span class="code-line">       3️⃣ Child 컴포넌트 #2 렌더링
</span><span class="code-line">          │
</span><span class="code-line">          ├─ Hook Storage 조회: path = &quot;Parent.c1&quot;
</span><span class="code-line">          │  └─ Hook 배열 반환: [post]
</span><span class="code-line">          │
</span><span class="code-line">          ├─ Cursor 초기화: 0
</span><span class="code-line">          │
</span><span class="code-line">          └─ useState() 호출 #1
</span><span class="code-line">             ├─ cursor = 0 → hooks[0] = post
</span><span class="code-line">             └─ cursor 증가 → 1
</span></code><div class="copied" data-code="1️⃣ Parent 컴포넌트 렌더링 시작
   │
   ├─ Hook Storage 조회: path = &quot;Parent&quot;
   │  └─ Hook 배열 반환: [name, age]
   │
   ├─ Cursor 초기화: 0
   │
   ├─ useState() 호출 #1
   │  ├─ cursor = 0 → hooks[0] = name
   │  └─ cursor 증가 → 1
   │
   ├─ useState() 호출 #2
   │  ├─ cursor = 1 → hooks[1] = age
   │  └─ cursor 증가 → 2
   │
   └─ 자식 컴포넌트 렌더링 시작
       │
       2️⃣ Child 컴포넌트 #1 렌더링
          │
          ├─ Hook Storage 조회: path = &quot;Parent.c0&quot;
          │  └─ Hook 배열 반환: [post]
          │
          ├─ Cursor 초기화: 0
          │
          └─ useState() 호출 #1
             ├─ cursor = 0 → hooks[0] = post
             └─ cursor 증가 → 1

       3️⃣ Child 컴포넌트 #2 렌더링
          │
          ├─ Hook Storage 조회: path = &quot;Parent.c1&quot;
          │  └─ Hook 배열 반환: [post]
          │
          ├─ Cursor 초기화: 0
          │
          └─ useState() 호출 #1
             ├─ cursor = 0 → hooks[0] = post
             └─ cursor 증가 → 1
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>중요한 점:</strong></p>
<ul>
<li>각 컴포넌트 인스턴스는 <strong>독립적인 path</strong>를 가짐</li>
<li>같은 Child 컴포넌트라도 <code>Parent.c0</code>, <code>Parent.c1</code>로 구분됨</li>
<li>따라서 두 Child는 서로 다른 Hook 배열을 가짐</li>
</ul>
<hr/>
<h4 id="-react-hook의-규칙과-그-이유"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-react-hook의-규칙과-그-이유"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>🚨 React Hook의 규칙과 그 이유</h4>
<p>React Hook에는 엄격한 규칙이 있다.</p>
<blockquote>
<ol>
<li>반복문, 조건문, 중첩 함수 내부에서는 Hook을 호출하면 안 된다.</li>
<li>React 함수 컴포넌트 또는 커스텀 Hook 내부에서만 Hook을 호출해야 한다.</li>
</ol>
</blockquote>
<p>처음 React를 배울 때는 이 규칙을 그냥 암기해야 할 규칙으로만 받아들이고, 별다른 의문점을 갖지 않았었다.
하지만 직접 구현해보고, 이 규칙이 <strong>필연적인 설계 제약</strong>이라는 걸 깨달았다.</p>
<h5 id="만약-조건문에서-hook을-사용하게-된다면"><a class="anchor" aria-hidden="true" tabindex="-1" href="#만약-조건문에서-hook을-사용하게-된다면"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>만약 조건문에서 Hook을 사용하게 된다면,</h5>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span> condition <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> setA<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cursor = 0</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> setB<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cursor = 1 (조건부!)</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>c<span class="token punctuation">,</span> setC<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cursor = 1 또는 2 (불확실!)</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function Component({ condition }) {
  const [a, setA] = useState(1);  // cursor = 0

  if (condition) {
    const [b, setB] = useState(2);  // cursor = 1 (조건부!)
  }

  const [c, setC] = useState(3);  // cursor = 1 또는 2 (불확실!)
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>첫 렌더링 (condition = true)</strong></p>
<ul>
<li>Hook 배열: <code>[a, b, c]</code></li>
<li>cursor 순서: <code>0 → 1 → 2</code></li>
</ul>
<p><strong>재렌더링 (condition = false)</strong></p>
<ul>
<li>Hook 배열: <code>[a, c]</code> (b가 스킵됨!)</li>
<li>cursor 순서: <code>0 → 1</code></li>
<li>⚠️ <strong>문제</strong>: <code>c</code>가 cursor 1 위치에서 호출되지만, 배열의 1번 위치에는 이전에 <code>b</code> 값이 저장되어 있음!</li>
</ul>
<p><strong>결과</strong>: Hook의 값이 뒤섞여서 완전히 망가진다.</p>
<hr/>
<h4 id="-hook이-동작하는-핵심-원리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-hook이-동작하는-핵심-원리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>✅ Hook이 동작하는 핵심 원리</h4>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 매 렌더링마다:</span>
</span><span class="code-line"><span class="token number">1.</span> 컴포넌트 <span class="token function">경로</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span>로 Hook Storage에서 배열을 가져옴
</span><span class="code-line"><span class="token number">2.</span> cursor를 <span class="token number">0</span>으로 초기화
</span><span class="code-line"><span class="token number">3.</span> Hook이 호출될 때마다<span class="token operator">:</span>
</span><span class="code-line">   <span class="token operator">-</span> hooks<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span>에서 값을 읽거나 저장
</span><span class="code-line">   <span class="token operator">-</span> cursor를 <span class="token number">1</span> 증가
</span><span class="code-line"><span class="token number">4.</span> 항상 같은 순서로 호출되어야 cursor가 올바른 위치를 가리킴
</span></code><div class="copied" data-code="// 매 렌더링마다:
1. 컴포넌트 경로(path)로 Hook Storage에서 배열을 가져옴
2. cursor를 0으로 초기화
3. Hook이 호출될 때마다:
   - hooks[cursor]에서 값을 읽거나 저장
   - cursor를 1 증가
4. 항상 같은 순서로 호출되어야 cursor가 올바른 위치를 가리킴
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>참고 자료</strong>: <a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays - Rudi Yardley (Medium)</a></p>
<hr/>
<h3 id="2-key를-통한-컴포넌트-식별과-재조정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-key를-통한-컴포넌트-식별과-재조정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. key를 통한 컴포넌트 식별과 재조정</h3>
<p>Hook과 마찬가지로 key에 대해서도
&quot;왜 난수값을 쓰면 안 되는지&quot;, &quot;배열 렌더링 시 key를 넣지 않으면 어떤 문제가 발생하는지&quot; 제대로 알지 못했다.
그냥 &quot;렌더링 효율이 낮아진다&quot;고만 알고 있었을 뿐, 구체적인 동작 원리는 몰랐다.</p>
<h4 id="-key의-역할"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-key의-역할"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>💡 key의 역할</h4>
<p>React의 reconciliation 과정에서 key는 <strong>같은 컴포넌트 인스턴스인지 판별</strong>하는 기준이다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// reconcileChildren에서 key 매칭</span>
</span><span class="code-line"><span class="token keyword">const</span> oldChildrenMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> Instance<span class="token operator">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">oldChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> key <span class="token operator">=</span> child<span class="token punctuation">.</span>key <span class="token operator">??</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key가 없으면 index 사용</span>
</span><span class="code-line">  oldChildrenMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 새 자식 처리 시</span>
</span><span class="code-line"><span class="token keyword">const</span> key <span class="token operator">=</span> newChild<span class="token punctuation">.</span>key <span class="token operator">??</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> oldChild <span class="token operator">=</span> oldChildrenMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key로 이전 인스턴스 찾기</span>
</span></code><div class="copied" data-code="// reconcileChildren에서 key 매칭
const oldChildrenMap = new Map&lt;string, Instance&gt;();
oldChildren.forEach((child, index) =&gt; {
  const key = child.key ?? String(index);  // key가 없으면 index 사용
  oldChildrenMap.set(key, child);
});

// 새 자식 처리 시
const key = newChild.key ?? String(index);
const oldChild = oldChildrenMap.get(key);  // key로 이전 인스턴스 찾기
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>핵심 동작:</strong></p>
<ul>
<li>같은 key를 가진 oldChild를 찾으면 → <strong>update</strong> (기존 DOM 재사용)</li>
<li>못 찾으면 → <strong>mount</strong> (새 DOM 생성)</li>
<li>남은 oldChild는 → <strong>unmount</strong> (DOM 제거)</li>
</ul>
<hr/>
<h4 id="-key가-없거나-index를-사용하는-경우의-문제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-key가-없거나-index를-사용하는-경우의-문제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>❌ key가 없거나 index를 사용하는 경우의 문제</h4>
<h5 id="사례-1-key를-아예-안-쓰는-경우"><a class="anchor" aria-hidden="true" tabindex="-1" href="#사례-1-key를-아예-안-쓰는-경우"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>사례 1: key를 아예 안 쓰는 경우</h5>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token comment">// ❌ key 없음</span>
</span><span class="code-line"><span class="token punctuation">{</span>items<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token arrow operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span> <span class="token attr-name">name</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 내부적으로는 index가 key로 사용됨</span>
</span><span class="code-line"><span class="token comment">// key = &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...</span>
</span></code><div class="copied" data-code="// ❌ key 없음
{items.map(item =&gt; &lt;Item name={item.name} /&gt;)}

// 내부적으로는 index가 key로 사용됨
// key = &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ...
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>초기 상태</strong>: <code>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></p>
<pre><code class="code-highlight"><span class="code-line">key=&quot;0&quot; → A
</span><span class="code-line">key=&quot;1&quot; → B
</span><span class="code-line">key=&quot;2&quot; → C
</span></code><div class="copied" data-code="key=&quot;0&quot; → A
key=&quot;1&quot; → B
key=&quot;2&quot; → C
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>맨 앞에 &quot;D&quot; 추가</strong>: <code>[&quot;D&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</code></p>
<pre><code class="code-highlight"><span class="code-line">key=&quot;0&quot; → D (이전: A)  ❌ A를 D로 update
</span><span class="code-line">key=&quot;1&quot; → A (이전: B)  ❌ B를 A로 update
</span><span class="code-line">key=&quot;2&quot; → B (이전: C)  ❌ C를 B로 update
</span><span class="code-line">key=&quot;3&quot; → C (새로 추가) ✅ C를 mount
</span></code><div class="copied" data-code="key=&quot;0&quot; → D (이전: A)  ❌ A를 D로 update
key=&quot;1&quot; → A (이전: B)  ❌ B를 A로 update
key=&quot;2&quot; → B (이전: C)  ❌ C를 B로 update
key=&quot;3&quot; → C (새로 추가) ✅ C를 mount
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>문제점:</strong></p>
<ul>
<li>실제로는 D만 추가하면 되는데, A, B, C를 전부 업데이트함</li>
<li>컴포넌트 state가 뒤섞임 (A의 state가 D로 이동)</li>
<li>성능 낭비</li>
</ul>
<hr/>
<h5 id="사례-2-난수값을-key로-쓰는-경우"><a class="anchor" aria-hidden="true" tabindex="-1" href="#사례-2-난수값을-key로-쓰는-경우"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>사례 2: 난수값을 key로 쓰는 경우</h5>
<pre class="language-jsx"><code class="language-jsx code-highlight"><span class="code-line"><span class="token comment">// ❌ 매 렌더링마다 새로운 난수</span>
</span><span class="code-line"><span class="token punctuation">{</span>items<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token arrow operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Item</span></span> <span class="token attr-name">key</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token known-class-name class-name">Math</span><span class="token punctuation">.</span><span class="token method function property-access">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token attr-name">name</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>item<span class="token punctuation">.</span><span class="token property-access">name</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// ❌ 매 렌더링마다 새로운 난수
{items.map(item =&gt; &lt;Item key={Math.random()} name={item.name} /&gt;)}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>첫 렌더링</strong>:</p>
<pre><code class="code-highlight"><span class="code-line">key=&quot;0.abc123&quot; → A
</span><span class="code-line">key=&quot;0.def456&quot; → B
</span></code><div class="copied" data-code="key=&quot;0.abc123&quot; → A
key=&quot;0.def456&quot; → B
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>재렌더링</strong> (아무 변경 없음):</p>
<pre><code class="code-highlight"><span class="code-line">key=&quot;0.xyz789&quot; → A (새 난수!)
</span><span class="code-line">key=&quot;0.qwe012&quot; → B (새 난수!)
</span></code><div class="copied" data-code="key=&quot;0.xyz789&quot; → A (새 난수!)
key=&quot;0.qwe012&quot; → B (새 난수!)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>결과:</strong></p>
<ul>
<li>key가 매번 바뀌므로 React는 &quot;완전히 다른 컴포넌트&quot;로 인식</li>
<li>기존 A, B를 unmount하고 새로 mount</li>
<li>컴포넌트 state 완전히 초기화됨</li>
<li>성능 최악</li>
</ul>
<hr/>
<h4 id="-현재-구현에서의-key-처리-흐름"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-현재-구현에서의-key-처리-흐름"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>📊 현재 구현에서의 key 처리 흐름</h4>
<pre><code class="code-highlight"><span class="code-line">reconcileChildren 호출
</span><span class="code-line">   │
</span><span class="code-line">   1️⃣ oldChildren을 key로 Map 생성
</span><span class="code-line">      │
</span><span class="code-line">      ├─ key=&quot;1&quot; → instanceA
</span><span class="code-line">      ├─ key=&quot;2&quot; → instanceB
</span><span class="code-line">      └─ Map 생성 완료
</span><span class="code-line">
</span><span class="code-line">   2️⃣ newChildren 순회 (정방향)
</span><span class="code-line">      │
</span><span class="code-line">      ├─ newChild: {id: 3, name: &quot;D&quot;}
</span><span class="code-line">      │  │
</span><span class="code-line">      │  ├─ key=&quot;3&quot;으로 Map 조회
</span><span class="code-line">      │  ├─ 못 찾음 (새로운 요소)
</span><span class="code-line">      │  └─ mount() 호출 → instanceD 생성
</span><span class="code-line">      │
</span><span class="code-line">      ├─ newChild: {id: 1, name: &quot;A&quot;}
</span><span class="code-line">      │  │
</span><span class="code-line">      │  ├─ key=&quot;1&quot;로 Map 조회
</span><span class="code-line">      │  ├─ 찾음! instanceA 존재
</span><span class="code-line">      │  ├─ update() 호출 → instanceA 업데이트
</span><span class="code-line">      │  └─ Map에서 key=&quot;1&quot; 제거
</span><span class="code-line">      │
</span><span class="code-line">      └─ newChild: {id: 2, name: &quot;B&quot;}
</span><span class="code-line">         │
</span><span class="code-line">         ├─ key=&quot;2&quot;로 Map 조회
</span><span class="code-line">         ├─ 찾음! instanceB 존재
</span><span class="code-line">         ├─ update() 호출 → instanceB 업데이트
</span><span class="code-line">         └─ Map에서 key=&quot;2&quot; 제거
</span><span class="code-line">
</span><span class="code-line">   3️⃣ 남은 oldChildren unmount
</span><span class="code-line">      │
</span><span class="code-line">      ├─ Map에 남은 요소 확인
</span><span class="code-line">      ├─ 남은 요소 없음 (모두 재사용됨)
</span><span class="code-line">      └─ 건너뛰기
</span><span class="code-line">
</span><span class="code-line">   4️⃣ DOM 위치 조정 (역순)
</span><span class="code-line">      │
</span><span class="code-line">      ├─ i=2: instanceB 처리
</span><span class="code-line">      │  ├─ anchor = null (마지막 요소)
</span><span class="code-line">      │  ├─ insertInstance(parentDom, instanceB, null)
</span><span class="code-line">      │  └─ anchor = B의 DOM
</span><span class="code-line">      │
</span><span class="code-line">      ├─ i=1: instanceA 처리
</span><span class="code-line">      │  ├─ anchor = B의 DOM
</span><span class="code-line">      │  ├─ insertInstance(parentDom, instanceA, anchor)
</span><span class="code-line">      │  └─ anchor = A의 DOM
</span><span class="code-line">      │
</span><span class="code-line">      └─ i=0: instanceD 처리
</span><span class="code-line">         ├─ anchor = A의 DOM
</span><span class="code-line">         ├─ insertInstance(parentDom, instanceD, anchor)
</span><span class="code-line">         └─ anchor = D의 DOM
</span><span class="code-line">
</span><span class="code-line">   ✅ 최종 DOM 순서: D → A → B
</span></code><div class="copied" data-code="reconcileChildren 호출
   │
   1️⃣ oldChildren을 key로 Map 생성
      │
      ├─ key=&quot;1&quot; → instanceA
      ├─ key=&quot;2&quot; → instanceB
      └─ Map 생성 완료

   2️⃣ newChildren 순회 (정방향)
      │
      ├─ newChild: {id: 3, name: &quot;D&quot;}
      │  │
      │  ├─ key=&quot;3&quot;으로 Map 조회
      │  ├─ 못 찾음 (새로운 요소)
      │  └─ mount() 호출 → instanceD 생성
      │
      ├─ newChild: {id: 1, name: &quot;A&quot;}
      │  │
      │  ├─ key=&quot;1&quot;로 Map 조회
      │  ├─ 찾음! instanceA 존재
      │  ├─ update() 호출 → instanceA 업데이트
      │  └─ Map에서 key=&quot;1&quot; 제거
      │
      └─ newChild: {id: 2, name: &quot;B&quot;}
         │
         ├─ key=&quot;2&quot;로 Map 조회
         ├─ 찾음! instanceB 존재
         ├─ update() 호출 → instanceB 업데이트
         └─ Map에서 key=&quot;2&quot; 제거

   3️⃣ 남은 oldChildren unmount
      │
      ├─ Map에 남은 요소 확인
      ├─ 남은 요소 없음 (모두 재사용됨)
      └─ 건너뛰기

   4️⃣ DOM 위치 조정 (역순)
      │
      ├─ i=2: instanceB 처리
      │  ├─ anchor = null (마지막 요소)
      │  ├─ insertInstance(parentDom, instanceB, null)
      │  └─ anchor = B의 DOM
      │
      ├─ i=1: instanceA 처리
      │  ├─ anchor = B의 DOM
      │  ├─ insertInstance(parentDom, instanceA, anchor)
      │  └─ anchor = A의 DOM
      │
      └─ i=0: instanceD 처리
         ├─ anchor = A의 DOM
         ├─ insertInstance(parentDom, instanceD, anchor)
         └─ anchor = D의 DOM

   ✅ 최종 DOM 순서: D → A → B
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-reconcilechildren-구현-방식---index-기반-vs-key-기반-map"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-reconcilechildren-구현-방식---index-기반-vs-key-기반-map"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. reconcileChildren 구현 방식 - index 기반 vs key 기반 Map</h3>
<p>reconcileChildren을 구현할 때 렌더링 순서가 꼬이는 문제가 계속 생겨서 해당 부분을 수정하다보니 로직이 많이 복잡해졌다. 이렇게 하는게 맞나 싶어 AI가 구현해줬던 <a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3/commits/5ca4f8e8f2335e7b80858f3bd3939386f690b1cd">이전 커밋</a>을 확인해보니 훨씬 단순한 코드로도 모든 테스트를 통과했다.
두 구현의 실제 차이가 무엇인지 궁금해서 분석해봤다.</p>
<hr/>
<h4 id="이전-커밋---index-기반-매칭"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이전-커밋---index-기반-매칭"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이전 커밋 - index 기반 매칭</h4>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// reconcileChildren - 단순히 index로 old/new를 1:1 매칭</span>
</span><span class="code-line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> oldChild <span class="token operator">=</span> oldChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> newChild <span class="token operator">=</span> newChildren<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token function">reconcile</span><span class="token punctuation">(</span>parentDom<span class="token punctuation">,</span> oldChild<span class="token punctuation">,</span> newChild<span class="token punctuation">,</span> childPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// reconcileChildren - 단순히 index로 old/new를 1:1 매칭
for (let i = 0; i &lt; maxLength; i++) {
  const oldChild = oldChildren[i] || null;
  const newChild = newChildren[i] || null;
  reconcile(parentDom, oldChild, newChild, childPath);
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>oldChildren[0]과 newChildren[0]을 비교하고, [1]과 [1]을 비교하는 방식이다.</p>
<h4 id="왜-테스트를-통과했나"><a class="anchor" aria-hidden="true" tabindex="-1" href="#왜-테스트를-통과했나"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>왜 테스트를 통과했나?</h4>
<p><code>reconcile</code> 함수 내부에서 key가 다르면 unmount → mount 하는 로직이 있다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// reconcile 내부</span>
</span><span class="code-line"><span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">.</span>node<span class="token punctuation">.</span>type <span class="token operator">!==</span> node<span class="token punctuation">.</span>type <span class="token operator">||</span> instance<span class="token punctuation">.</span>key <span class="token operator">!==</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">removeInstance</span><span class="token punctuation">(</span>parentDom<span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token function">mount</span><span class="token punctuation">(</span>parentDom<span class="token punctuation">,</span> node<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// reconcile 내부
if (instance.node.type !== node.type || instance.key !== node.key) {
  removeInstance(parentDom, instance);
  return mount(parentDom, node, path);
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>그래서 <code>[A, B, C]</code> → <code>[B, C, A]</code>로 재정렬하면:</p>
<ul>
<li>oldChildren[0] (A) vs newChildren[0] (B) → key 다름 → A 제거, B 새로 생성</li>
<li>결과적으로 DOM에는 <code>[B, C, A]</code>가 올바르게 렌더링됨</li>
</ul>
<p>기존 테스트는 이렇게 작성되어 있었다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token function">expect</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>list<span class="token punctuation">.</span>children<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toEqual</span><span class="token punctuation">(</span><span class="token punctuation">[</span>initialOrder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> initialOrder<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> initialOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="expect([...list.children]).toEqual([initialOrder[1], initialOrder[2], initialOrder[0]]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 테스트도 DOM 참조를 비교하는 것처럼 보이지만, <code>toEqual</code>은 <strong>deep equality</strong>를 사용한다. DOM 객체끼리 비교할 때는 내부 속성들을 재귀적으로 비교하는데, 새로 생성된 DOM이라도 같은 태그, 같은 텍스트를 가지면 통과할 수 있다.</p>
<hr/>
<h3 id="dom-재사용-여부를-확인하는-테스트-작성"><a class="anchor" aria-hidden="true" tabindex="-1" href="#dom-재사용-여부를-확인하는-테스트-작성"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>DOM 재사용 여부를 확인하는 테스트 작성</h3>
<p>정확히 같은 DOM 객체인지 확인하려면 <code>toBe</code>(참조 비교, === 연산자)를 사용해야 한다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token function">it</span><span class="token punctuation">(</span><span class="token string">&quot;key가 있으면 DOM 객체 참조가 유지된다&quot;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>List <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> container<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> list <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;#keyed-list&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> initialOrder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>list<span class="token punctuation">.</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [A, B, C] DOM 참조 저장</span>
</span><span class="code-line">
</span><span class="code-line">  reorder<span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [A, B, C] → [B, C, A]</span>
</span><span class="code-line">  <span class="token keyword">await</span> <span class="token function">flushMicrotasks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> afterOrder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>list<span class="token punctuation">.</span>children<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// toBe는 === 연산자로 참조 동등성 검사</span>
</span><span class="code-line">  <span class="token function">expect</span><span class="token punctuation">(</span>afterOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>initialOrder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 새 위치의 B === 원래 B?</span>
</span><span class="code-line">  <span class="token function">expect</span><span class="token punctuation">(</span>afterOrder<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>initialOrder<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 새 위치의 C === 원래 C?</span>
</span><span class="code-line">  <span class="token function">expect</span><span class="token punctuation">(</span>afterOrder<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toBe</span><span class="token punctuation">(</span>initialOrder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 새 위치의 A === 원래 A?</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="it(&quot;key가 있으면 DOM 객체 참조가 유지된다&quot;, async () =&gt; {
  setup(&lt;List /&gt;, container);
  const list = container.querySelector(&quot;#keyed-list&quot;);
  const initialOrder = [...list.children]; // [A, B, C] DOM 참조 저장

  reorder!(); // [A, B, C] → [B, C, A]
  await flushMicrotasks();
  const afterOrder = [...list.children];

  // toBe는 === 연산자로 참조 동등성 검사
  expect(afterOrder[0]).toBe(initialOrder[1]); // 새 위치의 B === 원래 B?
  expect(afterOrder[1]).toBe(initialOrder[2]); // 새 위치의 C === 원래 C?
  expect(afterOrder[2]).toBe(initialOrder[0]); // 새 위치의 A === 원래 A?
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>테스트 결과:</strong></p>
<ul>
<li>이전 커밋: ❌ FAILED - DOM이 재생성됨</li>
<li>현재 구현: ✅ PASSED - DOM이 재사용됨</li>
</ul>
<hr/>
<h3 id="왜-이전-커밋은-dom을-재사용하지-못했나"><a class="anchor" aria-hidden="true" tabindex="-1" href="#왜-이전-커밋은-dom을-재사용하지-못했나"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>왜 이전 커밋은 DOM을 재사용하지 못했나?</h3>
<p><code>[A, B, C]</code> → <code>[B, C, A]</code> 재정렬 시:</p>
<pre><code class="code-highlight"><span class="code-line">oldChildren[0] (A) vs newChildren[0] (B) → key 다름 → A 제거, B 새로 생성
</span><span class="code-line">oldChildren[1] (B) vs newChildren[1] (C) → key 다름 → B 제거, C 새로 생성
</span><span class="code-line">oldChildren[2] (C) vs newChildren[2] (A) → key 다름 → C 제거, A 새로 생성
</span></code><div class="copied" data-code="oldChildren[0] (A) vs newChildren[0] (B) → key 다름 → A 제거, B 새로 생성
oldChildren[1] (B) vs newChildren[1] (C) → key 다름 → B 제거, C 새로 생성
oldChildren[2] (C) vs newChildren[2] (A) → key 다름 → C 제거, A 새로 생성
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>index로 매칭하니까 순서가 바뀌면 올바른 Instance를 찾지 못한다.</p>
<hr/>
<h3 id="현재-구현---key-기반-map-매칭"><a class="anchor" aria-hidden="true" tabindex="-1" href="#현재-구현---key-기반-map-매칭"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>현재 구현 - key 기반 Map 매칭</h3>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 1. oldChildren을 key로 Map 생성</span>
</span><span class="code-line"><span class="token keyword">const</span> oldChildrenMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">oldChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> key <span class="token operator">=</span> child<span class="token punctuation">.</span>key <span class="token operator">??</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  oldChildrenMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. newChildren 순회하며 key로 매칭</span>
</span><span class="code-line">newChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>newChild<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> key <span class="token operator">=</span> newChild<span class="token punctuation">.</span>key <span class="token operator">??</span> <span class="token function">String</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> oldChild <span class="token operator">=</span> oldChildrenMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// O(1) 조회</span>
</span><span class="code-line">  <span class="token comment">// oldChild가 있으면 update, 없으면 mount</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. oldChildren을 key로 Map 생성
const oldChildrenMap = new Map();
oldChildren.forEach((child, index) =&gt; {
  const key = child.key ?? String(index);
  oldChildrenMap.set(key, child);
});

// 2. newChildren 순회하며 key로 매칭
newChildren.forEach((newChild, index) =&gt; {
  const key = newChild.key ?? String(index);
  const oldChild = oldChildrenMap.get(key); // O(1) 조회
  // oldChild가 있으면 update, 없으면 mount
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>key로 조회하니까 <code>[B, C, A]</code>에서 B를 처리할 때 oldChildrenMap에서 key=&quot;b&quot;인 instanceB를 찾아서 재사용한다.</p>
<p>그리고 마지막에 역순으로 DOM을 삽입한다:</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 4. DOM 위치 조정 (역순으로)</span>
</span><span class="code-line"><span class="token keyword">let</span> anchor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> instances<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token function">insertInstance</span><span class="token punctuation">(</span>parentDom<span class="token punctuation">,</span> instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> anchor<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  anchor <span class="token operator">=</span> <span class="token function">getFirstDom</span><span class="token punctuation">(</span>instances<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// 4. DOM 위치 조정 (역순으로)
let anchor = null;
for (let i = instances.length - 1; i &gt;= 0; i--) {
  insertInstance(parentDom, instances[i], anchor);
  anchor = getFirstDom(instances[i]);
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>역순으로 처리하면 이전에 삽입한 요소를 anchor로 사용할 수 있어서 <code>insertBefore</code>로 올바른 순서를 보장한다.</p>
<hr/>
<h2 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h2>
<p>이번 과제를 통해 가장 크게 느낀 점은 <strong>원리를 알면 더 잘 쓸 수 있다</strong>는 것이다.</p>
<p>이전에는 리액트의 규칙들(Hook 순서 유지, key 필수 등)을 그냥 &quot;해야 하는 것&quot;으로만 받아들였는데,
동작 원리를 이해하니 해당 규칙이 생기게 된 이유까지 이해할 수 있게 됐다.</p>
<p>특히 인상 깊었던 것들은 다음과 같다.</p>
<ul>
<li><strong>Hook이 배열과 cursor로 관리</strong>된다는 사실</li>
<li><strong>key가 O(1) Map 조회로 성능을 최적화</strong>한다는 점</li>
<li><strong>reconciliation이 휴리스틱으로 복잡도를 O(n)으로 낮춘다</strong>는 원리</li>
</ul>
<hr/>
<h2 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h2>
<h3 id="리팩토링이-필요한-부분"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리팩토링이-필요한-부분"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리팩토링이 필요한 부분</h3>
<ul>
<li><code>updateDomProps</code>에서 이벤트 핸들러, 일반 속성, style 처리가 섞여 있어 분리하면 좋을 것 같음</li>
<li>타입 캐스팅(<code>as Instance</code>, <code>as VNode[]</code>)이 많아서 타입 안전성 개선 여지 있음</li>
</ul>
<hr/>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<ul>
<li>아하 모먼트 3번에 작성했던 reconcileChild에 대해 질문드리고 싶습니다.
<ul>
<li>지금 구현한 접근 방향이 맞는지, 리액트의 철학에 따르는지가 궁금합니다.</li>
<li>역순으로 anchor를 정하는 방법 외에도 많은 방법이 있을 것 같습니다. 현재는 코드를 구현하다보니 로직이 너무 복잡해진 것 같은데, 이게 리팩토링이 안되어서 그렇게 보이는건지, 아니면 더 나은 방안이 있을지 궁금합니다.</li>
</ul>
</li>
</ul></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 희재님! 5주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!</p>
<blockquote>
<p>지금 구현한 접근 방향이 맞는지, 리액트의 철학에 따르는지가 궁금합니다.</p>
</blockquote>
<p>정상적으로 동작하면 접근 방향은 동일한거겠죠 ㅎㅎ?
마찬가지로 리액트의 척할에 따른 인터페이스이기 때문에 마찬가지로 철학에도 적합하다고 생각해요.</p>
<p>다만 조금 더 고민해보면 좋을 점은, react는 모노레포로 패키지를 관리하고, 각각의 패키지를 조합해서 구현하고 있어요. DOM을 다루는 부분을 아예 별도로 관리하는 방식이랄까.</p>
<p>이런 관점에서 생각했을 때, 어떻게 코드를 분리하면 좋을지 고민해보시면 좋답니다!</p>
<blockquote>
<p>역순으로 anchor를 정하는 방법 외에도 많은 방법이 있을 것 같습니다. 현재는 코드를 구현하다보니 로직이 너무 복잡해진 것 같은데, 이게 리팩토링이 안되어서 그렇게 보이는건지, 아니면 더 나은 방안이 있을지 궁금합니다.</p>
</blockquote>
<p>복잡할 수 밖에 없는 로직이라고 생각해요 ㅎㅎ 실제 리액트는 훨씬 더 복잡한데, 그 중의 핵심 개념을 최대한 압축한거니까요. 희재님이 상상하는 &quot;복잡하지 않은 모습&quot;은 어떤 모습일까요?</p>
<p>현재 코드를 리팩토링하고 구조화를 잘 한다고 해도 최소한의 복잡도는 있을 수 밖에 없는.. 그런 내용들이라고 생각합니다 ㅠㅠ</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[2팀 전희재] Chapter2-2. 나만의 React 만들기 - 전희재 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 전희재님이 제출한 [2팀 전희재] Chapter2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 전희재, [2팀 전희재] Chapter2-2. 나만의 React 만들기, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[2팀 전희재] Chapter2-2. 나만의 React 만들기 - 전희재 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 전희재님이 제출한 [2팀 전희재] Chapter2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[2팀 전희재] Chapter2-2. 나만의 React 만들기 - 전희재 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 전희재님이 제출한 [2팀 전희재] Chapter2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
