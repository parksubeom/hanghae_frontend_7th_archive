<link rel="preload" as="image" href="https://github.com/user-attachments/assets/a1569610-d79c-46c4-be0b-60b5589888cf"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/25512028-a3fe-4565-9265-858708bb5329"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/84828cf7-611e-48c2-80a6-93f0e843ed35"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/0ad98f25-5c25-4e47-a4aa-8359bcd2a139"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@parksubeom/" data-discover="true">parksubeom<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter3-2/pull/31" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->parksubeom</span><span>2025.12.02</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><p><a href="https://parksubeom.github.io/front_7th_chapter3-2/">배포링크:advanced</a></p>
<p>[구조 변경]</p>
<ul>
<li>FSD 폴더 구조 초기화 (shared, entities, widgets)</li>
<li>공통 타입과 유틸리티 함수를 <code>shared</code> 레이어로 이동</li>
</ul>
<p>[Entities]</p>
<ul>
<li><code>ProductCard</code> UI 생성 및 도메인 로직(재고 확인) 캡슐화</li>
<li>장바구니 계산 로직을 <code>entities/cart/lib</code>으로 분리</li>
</ul>
<p>[Widgets]</p>
<ul>
<li><code>Header</code> 위젯 추출: UI 렌더링과 상태 분리</li>
<li><code>ProductList</code> 위젯 추출: 목록 렌더링 및 검색 결과 없음 처리 분리</li>
<li><code>CartSidebar</code> 위젯 추출: 자율적인 가격 계산 로직 구현</li>
</ul>
<p>[리팩토링]</p>
<ul>
<li>App.tsx의 원시 JSX 코드를 위젯 컴포넌트 조합으로 교체</li>
<li>애플리케이션 전체의 가격 표기 방식 표준화</li>
<li>UI 컴포넌트의 TSX 확장자 관련 에러 수정</li>
</ul>
<h2 id="과제의-핵심취지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제의-핵심취지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제의 핵심취지</h2>
<ul>
<li>React의 hook 이해하기</li>
<li>함수형 프로그래밍에 대한 이해</li>
<li>액션과 순수함수의 분리</li>
</ul>
<h2 id="과제에서-꼭-알아가길-바라는-점"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제에서-꼭-알아가길-바라는-점"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제에서 꼭 알아가길 바라는 점</h2>
<ul>
<li>엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup</li>
<li>엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()</li>
<li>엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등</li>
<li>엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart) vs capaitalize(str)</li>
</ul>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<ul class="contains-task-list">
<li>
<p>Component에서 비즈니스 로직을 분리하기</p>
</li>
<li>
<p>비즈니스 로직에서 특정 엔티티만 다루는 계산을 분리하기</p>
</li>
<li>
<p>뷰데이터와 엔티티데이터의 분리에 대한 이해</p>
</li>
<li>
<p>entities -&gt; features -&gt; UI 계층에 대한 이해</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 함수는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 Component와 UI를 다루는 Component는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 데이터 흐름에 맞는 계층구조를 이루고 의존성이 맞게 작성이 되었나요?</p>
</li>
</ul>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<ul class="contains-task-list">
<li>
<p>이번 심화과제는 Context나 Jotai를 사용해서 Props drilling을 없애는 것입니다.</p>
</li>
<li>
<p>어떤 props는 남겨야 하는지, 어떤 props는 제거해야 하는지에 대한 기준을 세워보세요.</p>
</li>
<li>
<p>Context나 Jotai를 사용하여 상태를 관리하는 방법을 익히고, 이를 통해 컴포넌트 간의 데이터 전달을 효율적으로 처리할 수 있습니다.</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Context나 Jotai를 사용해서 전역상태관리를 구축했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전역상태관리를 통해 domain custom hook을 적절하게 리팩토링 했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 도메인 컴포넌트에 도메인 props는 남기고 props drilling을 유발하는 불필요한 props는 잘 제거했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전체적으로 분리와 재조립이 더 수월해진 결합도가 낮아진 코드가 되었나요?</p>
</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<h3 id="리팩토링-청사진"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리팩토링-청사진"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리팩토링 청사진</h3>
<p>제가 집중한 이번 리팩토링의 핵심 목적은 <strong>수직적 분리</strong> 와 <strong>수평적 분리</strong> 를 통해 입체적인 코드 구조를 만드는 것입니다.</p>
<h3 id="수직적-분리-레이어-위계"><a class="anchor" aria-hidden="true" tabindex="-1" href="#수직적-분리-레이어-위계"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>수직적 분리 (레이어 위계)</h3>
<pre><code class="code-highlight"><span class="code-line">Widgets (조립)
</span><span class="code-line">   ↓
</span><span class="code-line">Features (액션)
</span><span class="code-line">   ↓
</span><span class="code-line">Entities (데이터)
</span><span class="code-line">   ↓
</span><span class="code-line">Shared (공통)
</span></code><div class="copied" data-code="Widgets (조립)
   ↓
Features (액션)
   ↓
Entities (데이터)
   ↓
Shared (공통)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>상위 레이어만 하위 레이어를 참조할 수 있는 <strong>단방향 의존성 규칙</strong> 을 세워 데이터 흐름을 통제했습니다.</p>
<h3 id="수평적-분리-내부-역할"><a class="anchor" aria-hidden="true" tabindex="-1" href="#수평적-분리-내부-역할"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>수평적 분리 (내부 역할)</h3>
<p>각 폴더 내부에서 책임을 다시 분리합니다:</p>
<pre><code class="code-highlight"><span class="code-line">feature/cart/
</span><span class="code-line">├── ui/          # 사용자 액션 (View)
</span><span class="code-line">├── model/       # 상태 관리 (State)
</span><span class="code-line">└── lib/         # 순수 계산 (Logic)
</span></code><div class="copied" data-code="feature/cart/
├── ui/          # 사용자 액션 (View)
├── model/       # 상태 관리 (State)
└── lib/         # 순수 계산 (Logic)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이는 함수형 프로그래밍의 <strong>&quot;데이터와 로직의 분리&quot;</strong> 원칙을 파일 시스템에 적용한 것입니다.</p>
<h3 id="입체적-메트릭스"><a class="anchor" aria-hidden="true" tabindex="-1" href="#입체적-메트릭스"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>입체적 메트릭스</h3>
<p>수직과 수평을 조합하면, 코드의 위치만으로도 <strong>&quot;어떤 계층의, 어떤 역할&quot;</strong> 인지 즉시 파악할 수 있습니다:</p>
<ul>
<li><code>widgets/ProductList/ui</code> → 상위 레이어의 UI 조립</li>
<li><code>features/cart/model</code> → 중간 레이어의 상태 관리</li>
<li><code>entities/cart/lib</code> → 하위 레이어의 순수 계산 로직</li>
</ul>
<p>이 구조는 파일 경로 자체가 명세서 역할을 합니다.</p>
<h3 id="시행착오-수평적-분리에-대한-오해"><a class="anchor" aria-hidden="true" tabindex="-1" href="#시행착오-수평적-분리에-대한-오해"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>시행착오: 수평적 분리에 대한 오해</h3>
<p>처음에는 FSD의 레이어 구조만 이해했습니다. 그래서 단순히</p>
<ul>
<li>Entities = 데이터</li>
<li>Features = 액션</li>
<li>Shared = 계산</li>
</ul>
<p>이렇게 함수형 프로그래밍의 3단계 분리(데이터, 계산, 액션)와 1:1로 매핑된다고 생각했습니다.</p>
<p><strong>하지만 이건 잘못된 이해였습니다.</strong></p>
<img width="822" height="420" alt="image" src="https://github.com/user-attachments/assets/a1569610-d79c-46c4-be0b-60b5589888cf"/>
<img width="822" height="420" alt="image" src="https://github.com/user-attachments/assets/25512028-a3fe-4565-9265-858708bb5329"/>
<img width="822" height="420" alt="image" src="https://github.com/user-attachments/assets/84828cf7-611e-48c2-80a6-93f0e843ed35"/>
<img width="822" height="218" alt="image" src="https://github.com/user-attachments/assets/0ad98f25-5c25-4e47-a4aa-8359bcd2a139"/>
<p>영서님과의 대화를 통해 깨달은 것은:</p>
<ul>
<li>
<p><strong>수직적 분리(Layer)</strong>: &#x27;권력(의존성)&#x27;을 기준으로 나눈다</p>
<ul>
<li>누가 누구를 참조할 수 있는가?</li>
</ul>
</li>
<li>
<p><strong>수평적 분리(Slice)</strong>: &#x27;주제(도메인)&#x27;를 기준으로 나눈다</p>
<ul>
<li>product, cart, user 등</li>
</ul>
</li>
<li>
<p><strong>내부 분리(Segment)</strong>: &#x27;직무(역할)&#x27;를 기준으로 나눈다</p>
<ul>
<li>ui, model, lib 등</li>
</ul>
</li>
</ul>
<p>코드를 분리할 때는 <strong>&quot;이건 어떤 Layer의 어떤 Slice에 있는 어떤 Segment가 해야 할 일인지&quot;</strong> 를 생각하면 됩니다.</p>
<p>예를 들어, 장바구니 총합 계산 로직은:</p>
<ul>
<li>Layer: <code>entities</code> (데이터 레이어)</li>
<li>Slice: <code>cart</code> (장바구니 도메인)</li>
<li>Segment: <code>lib</code> (순수 계산 로직)
→ <code>entities/cart/lib/calculateCartTotal.ts</code></li>
</ul>
<p>FSD 설계 + 함수형 프로그래밍은 <strong>3차원 좌표계</strong> 처럼 코드의 정확한 위치를 지정하는 시스템같다고 느껴졌습니다.</p>
<h3 id="설계-의사결정-과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#설계-의사결정-과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>설계 의사결정 과정</h3>
<p>폴더 구조의 큰 틀은 FSD 공식 문서와 레퍼런스를 통해 파악했지만, 실제로 중요한 것은 <strong>&quot;어떤 설계를 선택할 것인가&quot;</strong> 에 대한 의사결정이었습니다.</p>
<p>예를 들어:</p>
<ul>
<li><code>calculateCartTotal</code> 로직을 <code>entities/cart/lib</code>에 둘 것인가, <code>shared/lib</code>에 둘 것인가?</li>
<li><code>ProductCard</code>의 재고 확인 로직은 컴포넌트 내부에 둘 것인가, 별도 lib로 분리할 것인가?</li>
<li><code>onAddToCart</code> 핸들러는 어느 레이어가 소유해야 하는가?</li>
</ul>
<p>이런 질문들은 정답이 명확하지 않았고, 각 선택마다 트레이드오프가 있었습니다.
<a href="https://velog.io/@teo/functional-programming">함수형 프로그래밍 블로그</a> 와 <a href="https://velog.io/@teo/fsd">FSD 설계 블로그</a>를 정독한 후 →</p>
<ul>
<li>특정 도메인에 강하게 결합된 로직은 해당 Entity에 두는 것이 응집도가 높다</li>
<li>범용적으로 쓰이는 유틸리티만 Shared로 올린다</li>
<li>Feature 레이어 없이 Entity가 액션을 소유하면 재사용성이 떨어진다</li>
</ul>
<p>이런 인사이트를 얻을 수 있었고, <strong>설계 결정의 타당성을 검증</strong> 할 수 있었습니다.</p>
<p>결국 좋은 아키텍처는 폴더를 어떻게 나누느냐의 문제가 아니라, <strong>&quot;왜 이렇게 나눴는가&quot;를 설명할 수 있는가</strong> 의 문제라는 것을 배웠습니다.</p>
<hr/>
<h3 id="과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제를 하면서 내가 알게된 점, 좋았던 점은 무엇인가요?</h3>


<h2 id="fsd-패턴-폴더-구조가-곧-명세서다-screaming-architecture"><a class="anchor" aria-hidden="true" tabindex="-1" href="#fsd-패턴-폴더-구조가-곧-명세서다-screaming-architecture"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FSD 패턴: 폴더 구조가 곧 명세서다 [Screaming Architecture]</h2>
<p>로버트 C. 마틴(Uncle Bob)이 주창한 &quot;Screaming Architecture&quot; 개념이 있습니다.</p>
<blockquote>
<p>&quot;프로젝트의 폴더 구조를 봤을 때, &#x27;우리는 리액트를 씁니다!&#x27;라고 소리치지 말고, &#x27;우리는 쇼핑몰입니다!&#x27;라고 소리쳐야 한다.&quot;</p>
</blockquote>
<h3 id="기술이-아닌-비즈니스가-보여야-한다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술이-아닌-비즈니스가-보여야-한다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술이 아닌 비즈니스가 보여야 한다</h3>
<p><strong>기존 구조:</strong></p>
<pre><code class="code-highlight"><span class="code-line">src/
</span><span class="code-line">├── components/
</span><span class="code-line">├── hooks/
</span><span class="code-line">├── utils/
</span><span class="code-line">└── contexts/
</span></code><div class="copied" data-code="src/
├── components/
├── hooks/
├── utils/
└── contexts/
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 구조는 &quot;우리는 리액트를 씁니다!&quot;라고 소리칩니다.</p>
<ul>
<li>컴포넌트를 쓰는구나</li>
<li>훅을 쓰는구나</li>
<li>컨텍스트를 쓰는구나</li>
</ul>
<p><strong>하지만 정작 중요한 질문에는 답하지 못합니다:</strong></p>
<ul>
<li>이게 쇼핑몰인가요? SNS인가요? 투두리스트인가요?</li>
<li>어떤 기능이 있나요?</li>
<li>어떤 데이터를 다루나요?</li>
</ul>
<p><strong>FSD 구조:</strong></p>
<pre><code class="code-highlight"><span class="code-line">src/
</span><span class="code-line">📦advanced
</span><span class="code-line"> ┣ 📂entities           # [도메인 모델] 비즈니스 데이터 &amp; 순수 계산
</span><span class="code-line"> ┃ ┃                    # 원칙: 데이터 구조와 순수 함수만. 상태나 액션을 모름.
</span><span class="code-line"> ┃ ┣ 📂cart             # 장바구니 도메인
</span><span class="code-line"> ┃ ┃ ┣ 📂lib            #   └─ calculateCartTotal (순수 함수)
</span><span class="code-line"> ┃ ┃ ┗ 📂model          #   └─ CartItem 타입
</span><span class="code-line"> ┃ ┣ 📂coupon           # 쿠폰 도메인
</span><span class="code-line"> ┃ ┃ ┣ 📂lib            #   └─ canApplyCoupon (검증 로직)
</span><span class="code-line"> ┃ ┃ ┗ 📂model          #   └─ Coupon 타입
</span><span class="code-line"> ┃ ┗ 📂product          # 상품 도메인
</span><span class="code-line"> ┃ ┃ ┣ 📂lib            #   └─ getRemainingStock (재고 계산)
</span><span class="code-line"> ┃ ┃ ┣ 📂model          #   └─ ProductWithUI 타입
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ ProductCard (멍청한 컴포넌트)
</span><span class="code-line"> ┣ 📂features           # [비즈니스 액션] 사용자 행동 &amp; 상태 관리
</span><span class="code-line"> ┃ ┃                    # 원칙: &#x27;동사(Verb)&#x27;를 담당. Entity와 Shared로 가치 창출.
</span><span class="code-line"> ┃ ┣ 📂app              # 통합 기능
</span><span class="code-line"> ┃ ┃ ┗ 📜useShop.ts     #   └─ Facade Hook (모든 Hook을 하나로 묶음)
</span><span class="code-line"> ┃ ┣ 📂cart             # 장바구니 기능
</span><span class="code-line"> ┃ ┃ ┗ 📂model          #   └─ useCart (담기/삭제/수량 변경)
</span><span class="code-line"> ┃ ┣ 📂coupon           # 쿠폰 기능
</span><span class="code-line"> ┃ ┃ ┣ 📂model          #   ├─ useCoupons (CRUD 로직)
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ CouponManagementForm (입력/검증 UI)
</span><span class="code-line"> ┃ ┗ 📂product          # 상품 기능
</span><span class="code-line"> ┃ ┃ ┣ 📂model          #   ├─ useProducts (CRUD &amp; 동기화)
</span><span class="code-line"> ┃ ┃ ┃ ┣ 📜useProductFilter.ts  #   ├─ 검색/필터링 로직
</span><span class="code-line"> ┃ ┃ ┃ ┗ 📜useProductForm.ts    #   └─ 폼 상태 (Headless)
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ ProductManagementForm (입력 폼)
</span><span class="code-line"> ┣ 📂shared             # [인프라] 도메인을 모르는 범용 도구
</span><span class="code-line"> ┃ ┃                    # 원칙: 프로젝트 공용. 비즈니스(쇼핑몰)를 전혀 모름.
</span><span class="code-line"> ┃ ┣ 📂lib              # 범용 함수 &amp; 훅
</span><span class="code-line"> ┃ ┃ ┣ 📜format.ts          #   ├─ 포맷터 (순수 함수)
</span><span class="code-line"> ┃ ┃ ┣ 📜useDebounce.ts     #   ├─ UI 최적화 (시간 지연)
</span><span class="code-line"> ┃ ┃ ┣ 📜useLocalStorage.ts #   ├─ 저장소 추상화
</span><span class="code-line"> ┃ ┃ ┣ 📜useNotification.ts #   ├─ 알림 (레거시)
</span><span class="code-line"> ┃ ┃ ┗ 📜useNotificationSystem.ts # └─ 알림 (개선)
</span><span class="code-line"> ┃ ┣ 📂model            # 범용 데이터
</span><span class="code-line"> ┃ ┃ ┗ 📜types.ts           #   └─ Notification 등 공용 타입
</span><span class="code-line"> ┃ ┗ 📂ui               # 범용 UI
</span><span class="code-line"> ┃ ┃ ┗ 📜NotificationSystem.ts #   └─ 알림 렌더러
</span><span class="code-line"> ┣ 📂widgets            # [조립] 독립적인 UI 블록
</span><span class="code-line"> ┃ ┃                    # 원칙: Entity + Feature를 조립해 완성된 덩어리 생성.
</span><span class="code-line"> ┃ ┣ 📂AdminDashboard   # 관리자 패널
</span><span class="code-line"> ┃ ┃ ┗ 📂ui
</span><span class="code-line"> ┃ ┃ ┃ ┣ 📜CouponListGrid.tsx   # ├─ 쿠폰 목록 그리드
</span><span class="code-line"> ┃ ┃ ┃ ┣ 📜ProductListTable.tsx # ├─ 상품 목록 테이블
</span><span class="code-line"> ┃ ┃ ┃ ┗ 📜index.tsx            # └─ 위젯 진입점
</span><span class="code-line"> ┃ ┣ 📂CartSidebar      # 장바구니 사이드바
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ 결제 정보 포함
</span><span class="code-line"> ┃ ┣ 📂Header           # 헤더
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ 네비게이션, 카트 아이콘
</span><span class="code-line"> ┃ ┗ 📂ProductList      # 상품 목록
</span><span class="code-line"> ┃ ┃ ┗ 📂ui             #   └─ 검색 결과 표시
</span><span class="code-line"> ┣ 📂__tests__          # 테스트
</span><span class="code-line"> ┃ ┗ 📜origin.test.tsx  #   └─ 통합 테스트 (E2E)
</span><span class="code-line"> ┣ 📜App.tsx            # [페이지] 레이어 조립 &amp; 데이터 주입
</span><span class="code-line"> ┃                      # 원칙: 로직 없음. useShop 호출 → Widget 주입만.
</span><span class="code-line"> ┗ 📜main.tsx           # 앱 진입점
</span></code><div class="copied" data-code="src/
📦advanced
 ┣ 📂entities           # [도메인 모델] 비즈니스 데이터 &amp; 순수 계산
 ┃ ┃                    # 원칙: 데이터 구조와 순수 함수만. 상태나 액션을 모름.
 ┃ ┣ 📂cart             # 장바구니 도메인
 ┃ ┃ ┣ 📂lib            #   └─ calculateCartTotal (순수 함수)
 ┃ ┃ ┗ 📂model          #   └─ CartItem 타입
 ┃ ┣ 📂coupon           # 쿠폰 도메인
 ┃ ┃ ┣ 📂lib            #   └─ canApplyCoupon (검증 로직)
 ┃ ┃ ┗ 📂model          #   └─ Coupon 타입
 ┃ ┗ 📂product          # 상품 도메인
 ┃ ┃ ┣ 📂lib            #   └─ getRemainingStock (재고 계산)
 ┃ ┃ ┣ 📂model          #   └─ ProductWithUI 타입
 ┃ ┃ ┗ 📂ui             #   └─ ProductCard (멍청한 컴포넌트)
 ┣ 📂features           # [비즈니스 액션] 사용자 행동 &amp; 상태 관리
 ┃ ┃                    # 원칙: &#x27;동사(Verb)&#x27;를 담당. Entity와 Shared로 가치 창출.
 ┃ ┣ 📂app              # 통합 기능
 ┃ ┃ ┗ 📜useShop.ts     #   └─ Facade Hook (모든 Hook을 하나로 묶음)
 ┃ ┣ 📂cart             # 장바구니 기능
 ┃ ┃ ┗ 📂model          #   └─ useCart (담기/삭제/수량 변경)
 ┃ ┣ 📂coupon           # 쿠폰 기능
 ┃ ┃ ┣ 📂model          #   ├─ useCoupons (CRUD 로직)
 ┃ ┃ ┗ 📂ui             #   └─ CouponManagementForm (입력/검증 UI)
 ┃ ┗ 📂product          # 상품 기능
 ┃ ┃ ┣ 📂model          #   ├─ useProducts (CRUD &amp; 동기화)
 ┃ ┃ ┃ ┣ 📜useProductFilter.ts  #   ├─ 검색/필터링 로직
 ┃ ┃ ┃ ┗ 📜useProductForm.ts    #   └─ 폼 상태 (Headless)
 ┃ ┃ ┗ 📂ui             #   └─ ProductManagementForm (입력 폼)
 ┣ 📂shared             # [인프라] 도메인을 모르는 범용 도구
 ┃ ┃                    # 원칙: 프로젝트 공용. 비즈니스(쇼핑몰)를 전혀 모름.
 ┃ ┣ 📂lib              # 범용 함수 &amp; 훅
 ┃ ┃ ┣ 📜format.ts          #   ├─ 포맷터 (순수 함수)
 ┃ ┃ ┣ 📜useDebounce.ts     #   ├─ UI 최적화 (시간 지연)
 ┃ ┃ ┣ 📜useLocalStorage.ts #   ├─ 저장소 추상화
 ┃ ┃ ┣ 📜useNotification.ts #   ├─ 알림 (레거시)
 ┃ ┃ ┗ 📜useNotificationSystem.ts # └─ 알림 (개선)
 ┃ ┣ 📂model            # 범용 데이터
 ┃ ┃ ┗ 📜types.ts           #   └─ Notification 등 공용 타입
 ┃ ┗ 📂ui               # 범용 UI
 ┃ ┃ ┗ 📜NotificationSystem.ts #   └─ 알림 렌더러
 ┣ 📂widgets            # [조립] 독립적인 UI 블록
 ┃ ┃                    # 원칙: Entity + Feature를 조립해 완성된 덩어리 생성.
 ┃ ┣ 📂AdminDashboard   # 관리자 패널
 ┃ ┃ ┗ 📂ui
 ┃ ┃ ┃ ┣ 📜CouponListGrid.tsx   # ├─ 쿠폰 목록 그리드
 ┃ ┃ ┃ ┣ 📜ProductListTable.tsx # ├─ 상품 목록 테이블
 ┃ ┃ ┃ ┗ 📜index.tsx            # └─ 위젯 진입점
 ┃ ┣ 📂CartSidebar      # 장바구니 사이드바
 ┃ ┃ ┗ 📂ui             #   └─ 결제 정보 포함
 ┃ ┣ 📂Header           # 헤더
 ┃ ┃ ┗ 📂ui             #   └─ 네비게이션, 카트 아이콘
 ┃ ┗ 📂ProductList      # 상품 목록
 ┃ ┃ ┗ 📂ui             #   └─ 검색 결과 표시
 ┣ 📂__tests__          # 테스트
 ┃ ┗ 📜origin.test.tsx  #   └─ 통합 테스트 (E2E)
 ┣ 📜App.tsx            # [페이지] 레이어 조립 &amp; 데이터 주입
 ┃                      # 원칙: 로직 없음. useShop 호출 → Widget 주입만.
 ┗ 📜main.tsx           # 앱 진입점
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이 구조는 &quot;우리는 쇼핑몰입니다!&quot;라고 소리칩니다.</p>
<ul>
<li>상품이 있구나</li>
<li>장바구니가 있구나</li>
<li>쿠폰을 적용할 수 있구나</li>
<li>결제 기능이 있구나</li>
</ul>
<p><strong>폴더 이름만 봐도 기획서의 목차가 보입니다.</strong></p>
<p>FSD는 기술 스택이 아닌 비즈니스 도메인이 앞으로 나옵니다.</p>
<h2 id="레이어-자체가-기능-명세서"><a class="anchor" aria-hidden="true" tabindex="-1" href="#레이어-자체가-기능-명세서"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>레이어 자체가 기능 명세서</h2>
<p>FSD의 각 폴더는 기획서의 섹션과 정확히 매칭됩니다.</p>



































<table><thead><tr><th>FSD 레이어</th><th>기획서/명세서의 항목</th><th>우리 프로젝트의 실제 폴더 (예시)</th></tr></thead><tbody><tr><td>Pages</td><td>사이트맵 / 라우팅</td><td>App.tsx (현재 메인)</td></tr><tr><td>Widgets</td><td>와이어프레임 (UI 블록)</td><td>widgets/Header, widgets/ProductList, widgets/CartSidebar, widgets/AdminDashboard</td></tr><tr><td>Features</td><td>유저 스토리 (비즈니스 액션)</td><td>features/cart (담기/수량변경), features/product (상품 CRUD), features/coupon (쿠폰 적용)</td></tr><tr><td>Entities</td><td>도메인 모델 (데이터 구조)</td><td>entities/product (ProductCard, 재고파악), entities/cart (가격계산)</td></tr><tr><td>Shared</td><td>인프라 / 공통 규약</td><td>shared/model (types.ts), shared/lib (format.ts, useNotification)</td></tr></tbody></table>
<p>특히 <code>features</code> 폴더는 그 자체로 &quot;이 애플리케이션이 수행할 수 있는 동작 목록&quot;입니다.</p>
<p>신규 입사자가 왔을 때, 두꺼운 위키 문서를 던져주는 것보다 <code>src/features</code> 폴더를 열어보라고 하는 게 훨씬 빠르고 정확합니다.</p>
<h2 id="강제된-의존성-규칙이-곧-설계도"><a class="anchor" aria-hidden="true" tabindex="-1" href="#강제된-의존성-규칙이-곧-설계도"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>강제된 의존성 규칙이 곧 설계도</h2>
<p>일반적인 프로젝트에서는 개발자마다 &quot;이 코드를 어디에 둘까?&quot;에 대한 기준이 달라 스파게티가 되기 쉽습니다. 하지만 FSD는 <strong>상위 레이어만 하위 레이어를 참조할 수 있다</strong>는 엄격한 규칙이 있습니다.</p>
<p>이 규칙 자체가 &quot;코드의 흐름도&quot; 역할을 합니다:</p>
<ul>
<li>Widget을 보면 → &quot;아, 이 기능(Feature)과 저 데이터(Entity)를 조립했구나.&quot;</li>
<li>Feature를 보면 → &quot;아, 이 데이터(Entity)를 조작하는구나.&quot;</li>
</ul>
<p>폴더 위치만으로도 데이터의 흐름과 의존 관계를 파악할 수 있습니다. 폴더구조가 하나의 명세로 사용된다는 게 신기하고 충격이었습니다.</p>
<hr/>
<h2 id="fsd-구조--함수형-프로그래밍-기반의-코드로-찢는과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#fsd-구조--함수형-프로그래밍-기반의-코드로-찢는과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FSD 구조 + 함수형 프로그래밍 기반의 코드로 찢는과정</h2>
<p>리팩토링을 진행하면서 가장 어려웠던 건 <strong>&quot;이 코드를 어느 폴더에 넣을까?&quot;</strong> 였습니다.<br/>
이 코드가 어느 레이어에 속해야 하며, 뷰데이터인지, 엔티티데이터인지 액션인가? 계산인가? 등 컴포넌트를 찢는 과정에 명확한 기준이 필요했습니다.
5가지 원칙을 세우고, 원칙에 의해서 판단 후 파일을 분리했습니다.</p>
<h2 id="1-이-코드가-외부환경을-바꾸는가-액션-vs-계산의-분리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-이-코드가-외부환경을-바꾸는가-액션-vs-계산의-분리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. &quot;이 코드가 외부환경을 바꾸는가?&quot; (액션 vs 계산의 분리)</h2>
<h3 id="함수형-프로그래밍의-제1원칙"><a class="anchor" aria-hidden="true" tabindex="-1" href="#함수형-프로그래밍의-제1원칙"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>함수형 프로그래밍의 제1원칙</h3>
<p>가장 먼저 적용한 기준입니다. 코드를 분리할 때 가장 중점적으로 적용한 원칙입니다.</p>
<p><strong>질문:</strong></p>
<blockquote>
<p>&quot;이 함수를 100번 실행하면 외부 세상(DB, 화면, 전역변수)에 영향을 미치는가?&quot;</p>
</blockquote>
<p><strong>분리 기준:</strong></p>
<ul>
<li>
<p><strong>NO (순수함):</strong> 입력만 같으면 결과가 늘 같고, 아무것도 안 건드린다.<br/>
→ <strong>lib (Entities/Shared)</strong> 으로 격리</p>
<ul>
<li>예: <code>calculateCartTotal</code>, <code>formatCurrency</code>, <code>canApplyCoupon</code></li>
</ul>
</li>
<li>
<p><strong>YES (부수효과):</strong> 상태를 바꾸거나(<code>setState</code>), 저장하거나(<code>localStorage</code>), 화면을 그린다.<br/>
→ <strong>model (Hook) 또는 ui (Component)</strong> 에 남김</p>
<ul>
<li>예: <code>addToCart</code>, <code>useLocalStorage</code></li>
</ul>
</li>
</ul>
<p><strong>왜 중요한가?</strong><br/>
순수 함수는 테스트하기 쉽고, 재사용하기 좋고, 버그가 적습니다.<br/>
lib 폴더만 열면 &quot;아, 이건 어디든 가져다 써도 계산함수구나&quot;라는 생각이 듭니다.</p>
<hr/>
<h2 id="2-이-코드는-쇼핑몰이라는-사실을-아는가-도메인-지식-유무"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-이-코드는-쇼핑몰이라는-사실을-아는가-도메인-지식-유무"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. &quot;이 코드는 &#x27;쇼핑몰&#x27;이라는 사실을 아는가?&quot; (도메인 지식 유무)</h2>
<h3 id="fsd-레이어-결정-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#fsd-레이어-결정-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>FSD 레이어 결정 기준</h3>
<p>코드가 비즈니스(도메인)와 얼마나 얽혀있는지 봤습니다.</p>
<p><strong>질문:</strong></p>
<blockquote>
<p>&quot;이 코드를 떼어내서 다른 서비스에 가져가면 에러 없이 작동하는가?&quot;</p>
</blockquote>
<p><strong>분리 기준:</strong></p>
<ul>
<li>
<p><strong>YES (작동함):</strong> 도메인을 모르는 멍청한 도구다.<br/>
→ <strong>Shared</strong></p>
<ul>
<li>예: <code>useLocalStorage</code> (저장만 함), <code>useDebounce</code> (시간만 끔), <code>formatCurrency</code> (숫자만 바꿈)</li>
</ul>
</li>
<li>
<p><strong>NO (에러남):</strong> &#x27;상품&#x27;, &#x27;쿠폰&#x27; 같은 단어를 알아야 한다.<br/>
→ <strong>Entities / Features</strong></p>
<ul>
<li>예: <code>ProductCard</code>, <code>useCart</code></li>
</ul>
</li>
</ul>
<p><strong>왜 중요한가?</strong><br/>
Shared는 다른 프로젝트에서도 복붙할 수 있는 &quot;범용 인프라&quot;입니다.<br/>
반면 Entities/Features는 &quot;이 쇼핑몰만의 고유한 지식&quot;입니다.<br/>
이 경계가 명확해야 코드를 재사용하거나 교체하기 쉬워집니다.</p>
<hr/>
<h2 id="3-책임이-너무-무겁지-않은가-단일-책임-원칙"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-책임이-너무-무겁지-않은가-단일-책임-원칙"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. &quot;책임이 너무 무겁지 않은가?&quot; (단일 책임 원칙)</h2>
<h3 id="컴포넌트-분할-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#컴포넌트-분할-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>컴포넌트 분할 기준</h3>
<p><code>AdminDashboard</code>나 <code>App.tsx</code>를 찢을 때 적용한 기준입니다.</p>
<p><strong>질문:</strong></p>
<blockquote>
<p>&quot;이 컴포넌트가 변경되어야 하는 이유가 2개 이상인가?&quot;</p>
</blockquote>
<p><strong>분리 기준:</strong></p>
<ul>
<li>
<p><code>App.tsx</code>는 &quot;라우팅/배치&quot;가 바뀌면 수정되어야 하는데, &quot;검색 로직&quot; 때문에도 수정되어야 했다.<br/>
→ <strong>분리 대상</strong></p>
</li>
<li>
<p><code>AdminDashboard</code>는 &quot;레이아웃&quot; 때문에 수정되어야 하는데, &quot;상품 입력 폼의 유효성 검사&quot; 때문에도 수정되어야 했다.<br/>
→ <strong>ProductManagementForm</strong>으로 분리</p>
</li>
</ul>
<p><strong>왜 중요한가?</strong><br/>
하나의 파일이 여러 이유로 수정되면, 팀원들끼리 Git 충돌이 나고, 버그 수정 시 예상치 못한 부분이 깨집니다.<br/>
&quot;한 가지 이유로만 변경되는 파일&quot;은 안전하고 예측 가능합니다.</p>
<hr/>
<h2 id="4-구현how인가-의도what인가-추상화-레벨"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-구현how인가-의도what인가-추상화-레벨"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. &quot;구현(How)인가, 의도(What)인가?&quot; (추상화 레벨)</h2>
<h3 id="훅hook-분리-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#훅hook-분리-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>훅(Hook) 분리 기준</h3>
<p><code>useCart</code> 내부를 정리할 때 쓴 기준입니다.</p>
<p><strong>질문:</strong></p>
<blockquote>
<p>&quot;이 코드가 &#x27;무엇을 하는지&#x27; 설명하는가, &#x27;어떻게 하는지&#x27; 구구절절 설명하는가?&quot;</p>
</blockquote>
<p><strong>분리 기준:</strong></p>
<ul>
<li>
<p><strong>Before:</strong> <code>localStorage.getItem(&#x27;cart&#x27;)... JSON.parse...</code><br/>
→ 이건 &quot;어떻게(How)&quot;에 집착하는 저수준 코드</p>
</li>
<li>
<p><strong>Action:</strong> 저수준 코드를 <code>useLocalStorage</code>로 숨김</p>
</li>
<li>
<p><strong>After:</strong> <code>usePersist(&quot;cart&quot;)</code><br/>
→ &quot;저장한다(What)&quot;는 의도만 남김<br/>
→ <strong>비즈니스 로직이 선명해짐</strong></p>
</li>
</ul>
<p><strong>왜 중요한가?</strong><br/>
비즈니스 로직에 <code>JSON.parse</code>, <code>try-catch</code> 같은 저수준 코드가 섞이면 &quot;진짜 중요한 로직&quot;이 묻힙니다.<br/>
추상화를 통해 &quot;쿠폰을 적용한다&quot;, &quot;장바구니에 담는다&quot; 같은 <strong>비즈니스 언어</strong>만 남겨야 합니다.</p>
<hr/>
<h2 id="5-자주-함께-바뀌는가-응집도"><a class="anchor" aria-hidden="true" tabindex="-1" href="#5-자주-함께-바뀌는가-응집도"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. &quot;자주 함께 바뀌는가?&quot; (응집도)</h2>
<h3 id="파일-위치-선정-기준"><a class="anchor" aria-hidden="true" tabindex="-1" href="#파일-위치-선정-기준"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>파일 위치 선정 기준</h3>
<p>타입(<code>types.ts</code>)을 찢어서 각 폴더에 넣을 때 쓴 기준입니다.</p>
<p><strong>질문:</strong></p>
<blockquote>
<p>&quot;Product 타입이 바뀌면 누가 가장 귀찮은가?&quot;</p>
</blockquote>
<p><strong>분리 기준:</strong></p>
<ul>
<li>
<p><code>Product</code> 타입이 바뀌면 <code>ProductCard</code>와 <code>useProducts</code>가 귀찮아진다.<br/>
→ 그들 곁(<code>entities/product</code>)에 둔다.</p>
</li>
<li>
<p>서로 관련 없는 코드들이 한 파일(<code>shared/types.ts</code>)에 모여 있으면, 하나 고칠 때마다 부가적인 수정소요가 생긴다.<br/>
→ <strong>찢는다</strong></p>
</li>
</ul>
<p><strong>왜 중요한가?</strong><br/>
&quot;함께 변경되는 것은 함께 둔다&quot;는 원칙은 개발 속도를 올립니다.<br/>
<code>Product</code> 관련 코드를 수정할 때, <code>entities/product</code> 폴더만 열면 모든 게 거기 있습니다.<br/>
여러 폴더를 헤매지 않아도 됩니다.</p>
<hr/>
<h2 id="5가지-원칙-요약표"><a class="anchor" aria-hidden="true" tabindex="-1" href="#5가지-원칙-요약표"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5가지 원칙 요약표</h2>



































<table><thead><tr><th>상황</th><th>질문</th><th>결정 (Action)</th></tr></thead><tbody><tr><td><strong>로직</strong></td><td>결과가 늘 같은가?</td><td>✅ → <code>lib</code> (순수함수)<br/>❌ → <code>hook</code> (액션)</td></tr><tr><td><strong>위치</strong></td><td>쇼핑몰인 걸 아는가?</td><td>✅ → <code>Entities/Features</code><br/>❌ → <code>Shared</code></td></tr><tr><td><strong>UI</strong></td><td>역할이 2개 이상인가?</td><td>✅ → 하위 컴포넌트로 분리 (Form, List)</td></tr><tr><td><strong>상태</strong></td><td>구체적 구현인가?</td><td>✅ → 커스텀 훅으로 추상화 (<code>useLocalStorage</code>)</td></tr><tr><td><strong>데이터</strong></td><td>누구랑 친한가?</td><td>친한 애 옆(<code>model</code>)으로 이동</td></tr></tbody></table>
<hr/>
<h2 id="1-전역-상태-관리-도입-배경-props-drilling-지옥-탈출기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-전역-상태-관리-도입-배경-props-drilling-지옥-탈출기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 전역 상태 관리 도입 배경: &quot;Props Drilling 지옥 탈출기&quot;</h2> <h3 id="-마주한-한계-the-pain-points"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-마주한-한계-the-pain-points"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>① 마주한 한계 (The Pain Points)</h3> <p>FSD 아키텍처를 도입해 폴더 구조는 깔끔해졌지만, <strong>데이터 흐름(Data Flow)</strong>은 여전히 복잡했습니다. 특히 <code>App.tsx</code>에서 정의된 상태와 핸들러가 말단 컴포넌트까지 전달되는 과정에서 <strong>&#x27;Props Drilling&#x27;</strong> 문제가 심각하게 대두되었습니다.</p> <h4 id="택배-기사가-되어버린-중간-컴포넌트들"><a class="anchor" aria-hidden="true" tabindex="-1" href="#택배-기사가-되어버린-중간-컴포넌트들"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>&quot;택배 기사가 되어버린 중간 컴포넌트들&quot;</h4> <p>가장 대표적인 예시는 <code>addNotification</code> 함수였습니다.</p> <ul> <li><strong>정의:</strong> 최상위 <code>App.tsx</code></li> <li><strong>사용:</strong> 저 깊은 곳의 <code>ProductManagementForm</code> (상품 추가 실패 시 알림)</li> <li><strong>경로:</strong> <code>App</code> → <code>AdminDashboard</code> → <code>ProductManagementForm</code></li> </ul> <p>이 과정에서 <code>AdminDashboard</code>는 본인이 알림 기능을 쓰지도 않으면서, 단지 자식에게 넘겨주기 위해 Props 인터페이스에 <code>onNotification</code>을 정의해야 했습니다. 이는 <strong>불필요한 결합도(Coupling)</strong>를 높이고 코드를 지저분하게 만들었습니다.</p>
<h4 id="거대한-허브가-된-apptsx"><a class="anchor" aria-hidden="true" tabindex="-1" href="#거대한-허브가-된-apptsx"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>거대한 허브가 된 App.tsx</h4> <p>모든 도메인 상태(<code>cart</code>, <code>products</code>, <code>coupons</code>)를 <code>App.tsx</code>가 관리하다 보니, <code>App</code> 컴포넌트는 UI 렌더링보다는 <strong>데이터를 엮어주는 작업</strong>에 치중하게 되었습니다. 이는 &quot;페이지 레이아웃&quot;이라는 본연의 책임에서 벗어난 것이었습니다.</p> <h3 id="-해결책-zustand-도입과-제어의-역전"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-해결책-zustand-도입과-제어의-역전"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>② 해결책: Zustand 도입과 제어의 역전</h3> <p>이러한 문제를 해결하기 위해 <strong>Zustand</strong>를 도입하여 상태 관리의 패러다임을 전환했습니다.</p> <ul> <li><strong>Before (Push 방식):</strong> 부모가 자식에게 데이터를 억지로 밀어넣음 (Props)</li> <li><strong>After (Pull 방식):</strong> 필요한 컴포넌트가 전역 스토어에서 직접 데이터를 가져다 씀 (Subscribe)</li> </ul> <p><strong>결과:</strong></p> <ul> <li><code>App.tsx</code>는 더 이상 상태 관리자가 아닌, <strong>순수한 조립자(Assembler)</strong>가 되었습니다.</li> <li>중간 컴포넌트들은 &#x27;택배 기사&#x27; 역할에서 해방되어 본연의 UI 로직에만 집중할 수 있게 되었습니다.</li> </ul> <hr/> <h2 id="2-기술적-도전-전역-상태-도입과-테스트-격리-문제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-기술적-도전-전역-상태-도입과-테스트-격리-문제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 기술적 도전: 전역 상태 도입과 테스트 격리 문제</h2> <p>하지만 전역 상태 관리를 도입하여 구조를 개선하자마자, 예상치 못한 <strong>새로운 문제</strong>가 발생했습니다.</p> <h3 id="-문제-상황-problem"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-문제-상황-problem"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>① 문제 상황 (Problem)</h3> <p>알림 시스템(<code>Notification</code>)을 <code>useState</code> 기반의 지역 상태에서 <code>Zustand</code> 기반의 전역 상태로 리팩토링한 직후, 기존에 잘 통과하던 통합 테스트(<code>origin.test.tsx</code>)가 실패하는 현상이 발생했습니다.</p> <blockquote> <p>&quot;알림이 하나만 떠야 하는데 여러 개가 발견됨 -&gt; Notification관련 파일을 뒤져봐도 여러 개가 보이게 될만한 코드는 없는데? -&gt; 알림이 남아있나? -&gt; App컴포넌트가 언마운트 될 때 같이 사라질텐데? -&gt; 어? 근데 이제는 Notification상태를 Zustand로 관리하고, Zustand 스토어는 컴포넌트 외부에 있으니까 같은 생명주기를 공유하지 않는건가?&quot;</p> </blockquote> <h3 id="-원인-분석-및-추론-reasoning"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-원인-분석-및-추론-reasoning"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>② 원인 분석 및 추론 (Reasoning)</h3> <p>디버깅 결과, 원인은 <strong>지역 상태와 전역 상태의 &#x27;생명주기(Lifecycle)&#x27; 차이</strong>에 있었습니다.</p> <p><strong>전역 상태 관리 전 (<code>useState</code>):</strong></p> <ul> <li>컴포넌트 인스턴스에 종속됩니다.</li> <li>테스트가 끝날 때마다 <code>App</code> 컴포넌트가 언마운트되면서 상태도 함께 메모리에서 소멸합니다.</li> <li><strong>결과:</strong> 매 테스트는 항상 깨끗한 상태에서 시작했습니다.</li> </ul> <p><strong>전역 상태 관리 후 (<code>Zustand</code>):</strong></p> <ul> <li>스토어는 컴포넌트 외부(모듈 스코프)에 존재합니다(Singleton).</li> <li>컴포넌트가 언마운트되어도 스토어의 데이터는 메모리에 그대로 남아있습니다.</li> <li><strong>결과:</strong> 앞선 테스트 케이스에서 생성된 알림 데이터가 지워지지 않고 다음 테스트 케이스로 넘어가는 <strong>&#x27;상태 오염&#x27;</strong> 이 발생했습니다.</li> </ul>
<p><strong>왜 문제가 되었는가?</strong></p> <pre><code class="code-highlight"><span class="code-line">[1번째 테스트] 쿠폰 적용 → 알림 1개 생성 → 테스트 종료   └─&gt; Zustand 스토어에는 알림 1개가 남아있음 (좀비 데이터)
</span></code><p><code>[2번째 테스트] 할인 적용 → 알림 1개 생성 (예상)   └─&gt; 실제로는 알림 2개가 표시됨 (이전 알림 + 새 알림)   └─&gt; ❌ 테스트 실패: &quot;알림요소 중복&quot; </code></p><div class="copied" data-code="[1번째 테스트] 쿠폰 적용 → 알림 1개 생성 → 테스트 종료   └─&gt; Zustand 스토어에는 알림 1개가 남아있음 (좀비 데이터)
[2번째 테스트] 할인 적용 → 알림 1개 생성 (예상)   └─&gt; 실제로는 알림 2개가 표시됨 (이전 알림 + 새 알림)   └─&gt; ❌ 테스트 실패: &quot;알림요소 중복&quot; "><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre> <h3 id="-해결-방법-solution"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-해결-방법-solution"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>③ 해결 방법 (Solution)</h3> <p>이 문제를 해결하기 위해 <strong>&#x27;마운트 시 초기화(Reset on Mount)&#x27;</strong> 전략을 선택했습니다.</p> <p><strong>접근법:</strong></p>
<p><code>App.tsx</code>가 마운트되는 시점(<code>useEffect</code>)에 전역 알림 스토어를 빈 배열로 강제 초기화했습니다.</p> <pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// src/App.tsx useEffect(() =&gt; {   // 앱이 시작될 때(혹은 테스트가 새로 시작될 때) 스토어를 초기화하여 좀비 데이터를 방지함   useNotificationStore.setState({ notifications: [] }); }, []); </span></span></code><div class="copied" data-code="// src/App.tsx useEffect(() =&gt; {   // 앱이 시작될 때(혹은 테스트가 새로 시작될 때) 스토어를 초기화하여 좀비 데이터를 방지함   useNotificationStore.setState({ notifications: [] }); }, []); "><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre> <p><strong>선택 근거:</strong></p> <p>언마운트 시점의 <code>cleanup</code> 함수를 활용할 수도 있었으나, 테스트 도중 에러 발생 등으로 비정상 종료될 경우 뒷정리가 실행되지 않을 위험이 있습니다.</p> <p>반면, <strong>마운트 시점의 초기화는 이전 상황과 관계없이 현재 실행 환경의 순수성을 확실하게 보장</strong>합니다.</p> <p><strong>부가적인 효과:</strong></p> <p>실제 사용자 경험에서도 페이지 새로고침 시 이전 세션의 불필요한 알림이 남지 않도록 하는 UX 개선 효과를 얻었습니다.</p> <h3 id="-배운-점-lesson-learned"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-배운-점-lesson-learned"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>④ 배운 점 (Lesson Learned)</h3> <p>전역 상태 관리 라이브러리를 도입할 때는 단순히 &quot;편리함&quot;만 생각해서는 안 된다는 것을 깨달았습니다.</p> <ul> <li> <p><strong>싱글톤은 자유로운 만큼 책임이 따른다:</strong></p>
<p>전역 스토어는 컴포넌트 경계를 넘어 데이터를 공유할 수 있지만, 그만큼 <strong>생명주기 관리의 책임</strong>도 개발자에게 넘어옵니다.</p> </li> <li> <p><strong>테스트의 중요성:</strong></p>
<p>&quot;왜 예전엔 되던 테스트가 갑자기 깨지지?&quot; 즉, 회귀 테스트를 실패하게 되면서 수정 직후 빠르게 문제를 파악할 수 있고 해당 문제에 대한 즉각적인 고민과 해결이 가능해서 너무 좋았습니다.</p> </li> </ul> <p>이 조치를 통해 <strong>전역 상태를 사용하면서도 각 테스트 케이스의 독립성을 보장</strong>할 수 있었고, 코드의 신뢰성을 유지할 수 있었습니다.</p><p></p>
<h3 id="이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제에서 내가 제일 신경 쓴 부분은 무엇인가요?</h3>
<p>이번 과제를 진행하며 가장 신경쓰고, 또 고민했던 부분은 단순한 코드 이동이 아니라 <strong>&quot;설계 원칙의 적용&quot;</strong> 과정이었습니다. 특히 제가 가장 공을 들였던 부분은 <strong>&#x27;FP의 순수성&#x27;</strong> 과 <strong>&#x27;FSD의 위계질서&#x27;</strong> 를 실제 코드에 녹여내는 것이었습니다.</p>
<h3 id="1-액션action과-계산calculation의-엄격한-분리-fp"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-액션action과-계산calculation의-엄격한-분리-fp"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 액션(Action)과 계산(Calculation)의 엄격한 분리 (FP)</h3>
<p>가장 공을 들인 부분은 컴포넌트와 훅에 뒤섞여 있던 비즈니스 로직을 <strong>&#x27;부수 효과가 없는 순수 함수(계산)&#x27;</strong> 와 <strong>&#x27;상태를 변경하는 함수(액션)&#x27;</strong> 로 명확히 구분하는 것이었습니다.</p>
<p><strong>Before:</strong><br/>
<code>formatPrice</code>나 <code>applyCoupon</code> 같은 함수들이 내부에서 전역 상태(<code>isAdmin</code>)나 컴포넌트 상태(<code>cart</code>)를 직접 참조(암묵적 입력)하고 있어 테스트가 불가능했습니다.</p>
<p><strong>After:</strong></p>
<ul>
<li>
<p><strong>계산:</strong> <code>entities/**/lib</code> 폴더로 추출하여 외부 의존성을 모두 제거하고 인자(Explicit Input)만으로 동작하도록 리팩토링했습니다.<br/>
예: <code>canApplyCoupon</code>, <code>calculateCartTotal</code></p>
</li>
<li>
<p><strong>액션:</strong> 상태 변경이나 사이드 이펙트는 <code>features/**/model</code>의 Custom Hook에 위임하여, 계산 로직을 호출하고 결과를 반영하는 역할만 수행하도록 했습니다.</p>
</li>
</ul>
<p>이를 통해 <strong>비즈니스 로직의 테스트 용이성을 확보</strong> 하고, UI 컴포넌트가 로직에 종속되지 않도록 만들었습니다.</p>
<h3 id="2-fsd-아키텍처의-의존성-규칙-준수와-응집도-강화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-fsd-아키텍처의-의존성-규칙-준수와-응집도-강화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. FSD 아키텍처의 &#x27;의존성 규칙&#x27; 준수와 &#x27;응집도&#x27; 강화</h3>
<p>단순히 파일을 폴더에 나누는 것을 넘어, <strong>&quot;각 레이어가 서로를 어떻게 참조해야 하는가&quot;</strong> 에 대한 규칙을 세우고 지키는 데 집중했습니다.
FSD 아키텍처로 보여지는것보다 각가의 레이어의 위계가 확실히 정립되고, 관련있는 파일끼리 최대한 모아서 높은 응집도의 구조가 되도록 노력했습니다.</p>
<p><strong>Shared:</strong><br/>
도메인을 모르는 순수 도구(<code>useLocalStorage</code>, <code>useDebounce</code>)로 정의하여 범용성을 확보했습니다.</p>
<p><strong>Features:</strong><br/>
<code>useCart</code>가 <code>useProducts</code>의 데이터가 필요할 때, 인자로 주입받거나 전역 스토어를 구독하게 하여 결합도를 낮췄습니다.</p>
<p><strong>Widgets:</strong><br/>
<code>AdminDashboard</code> 같은 거대 컴포넌트를 <code>ProductManagementForm</code>(Feature UI)과 <code>ProductListTable</code>(Sub-Widget)로 쪼개어, 위젯이 <strong>&#x27;직접 그리기&#x27;보다는 &#x27;조립하기&#x27;</strong> 에 집중하도록 설계했습니다.</p>
<h3 id="3-전역-상태zustand-도입과-생명주기-관리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-전역-상태zustand-도입과-생명주기-관리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 전역 상태(Zustand) 도입과 생명주기 관리</h3>
<p><code>useState</code>에서 <code>Zustand</code>로 마이그레이션하며 발생한 테스트 격리 문제를 해결하는 과정에 깊은 고민을 담았습니다.</p>
<ul>
<li>컴포넌트가 언마운트되어도 메모리에 남는 전역 스토어의 특성 때문에 통합 테스트가 실패하는 현상을 겪었습니다.</li>
<li>이를 해결하기 위해 <code>App.tsx</code> 마운트 시점에 스토어를 강제로 초기화하는 전략을 사용하여, <strong>전역 상태의 편리함과 테스트 환경의 독립성을 모두 확보했습니다.</strong></li>
</ul>
<hr/>
<h3 id="이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제를 통해 앞으로 해보고 싶은게 있다면 알려주세요!</h3>
<h3 id="server-state와-client-state의-분리"><a class="anchor" aria-hidden="true" tabindex="-1" href="#server-state와-client-state의-분리"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Server State와 Client State의 분리</h3>
<p>이번 과제에서는 <code>localStorage</code>를 사용하여 클라이언트 사이드에서 데이터를 저장했습니다. 하지만 실제 서비스 환경을 고려하여, <strong>React Query(TanStack Query)</strong> 를 도입해 비동기 데이터와 UI 상태를 FSD 아키텍처 안에서 어떻게 효율적으로 관리할지 고민해보고 경험해보고 싶습니다.</p>
<p><strong>이번 과제를 통해 얻은 가장 큰 깨달음:</strong></p>
<blockquote>
<p>&quot;좋은 아키텍처는 코드의 위치가 곧 의도를 말한다.&quot;</p>
</blockquote>
<p>FSD와 FP 원칙을 적용하면서, <strong>폴더 구조 자체가 하나의 명세서이자 설계도</strong> 가 될 수 있다는 것을 체감했습니다. 비록 모든 폴더 구조가 FSD 일수도 없고, 항상 정답도 아니지만 FSD 경험을 토대로 더 복잡한 비즈니스 로직과 사용자 경험을 다루는 프로젝트에 도전하고 싶습니다.
무엇보다 어떤 설계나 디자인 패턴이 좋아보여서 따라하고 적용하는게 중요한게 아닌, 어떤 관점과 기준에서 내 프로젝트에 적용했고 그 적용한 이유를 설명가능하며 그 이유가 나의 팀원과 조직을 설득시킬 수 있는지 여부가 더 중요하다고 느꼈습니다.
세상엔 정말 많은 패턴과 설계방법, 프로그래밍 패러다임이 존재하며 이번 FSD + FP는 좋은 경험이였지만 &quot;항상 이 설계, 이 방법으로 프로그래밍 하겠어&quot; 라는 생각으로 매몰되지는 말아야지 생각했습니다.</p>
<h3 id="리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문 편하게 남겨주세요 :)</h3>
<h3 id="1-아키텍처-및-구조-관점-fsd"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-아키텍처-및-구조-관점-fsd"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 아키텍처 및 구조 관점 (FSD)</h3>
<p><strong>Q. Feature와 Entity의 경계 및 위젯의 역할 축소에 대해 의견이 궁금합니다.</strong>
이번 리팩토링에서 장바구니 계산 로직(<code>calculateCartTotal</code>)은 <code>entities</code>로, 상태 관리(<code>useCart</code>)는 <code>features</code>로 분리했습니다.
특히 <code>AdminDashboard</code> 위젯이 가지고 있던 폼 상태와 유효성 검사 로직까지 <code>features</code> 레이어(<code>ProductManagementForm</code> 등)로 내리면서 위젯이 오로지 조립 역할만 하게 되었는데요.
이 구조가 FSD의 의도에 부합하는지, 혹은 위젯이 너무 껍데기만 남은 것은 아닌지 아키텍처 관점에서의 피드백이 궁금합니다.</p>
<h3 id="2-상태-관리-및-동기화-관점-zustand--sync"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-상태-관리-및-동기화-관점-zustand--sync"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 상태 관리 및 동기화 관점 (Zustand &amp; Sync)</h3>
<p><strong>Q. App.tsx에서의 수동 데이터 동기화 패턴이 적절한지 궁금합니다.</strong>
Zustand의 <code>persist</code> 미들웨어를 사용하는 대신, <code>persist</code>를 제거하고 <code>App.tsx</code>에서 <code>useEffect</code>를 통해 로컬스토리지와 스토어를 수동으로 동기화하는 방식을 택했습니다.
이는 테스트 환경에서의 격리와 레거시 데이터 호환성을 확보하기 위함이었는데요. 이 패턴이 장기적인 유지보수 측면에서도 유효할지, 혹은 더 나은 대안이 있을지 의견이 궁금합니다.</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 수범님! 7주차 과제 잘 진행해주셨네요. 압도적인 회고에 놀랐습니다 ㅎㅎ 고생하셨습니다~!!</p>
<p>Q1) 아키텍처 및 구조 관점 (FSD)
Feature와 Entity의 경계 및 위젯의 역할 축소에 대해 의견이 궁금합니다.
이번 리팩토링에서 장바구니 계산 로직(calculateCartTotal)은 entities로, 상태 관리(useCart)는 features로 분리했습니다.
특히 AdminDashboard 위젯이 가지고 있던 폼 상태와 유효성 검사 로직까지 features 레이어(ProductManagementForm 등)로 내리면서 위젯이 오로지 조립 역할만 하게 되었는데요.
이 구조가 FSD의 의도에 부합하는지, 혹은 위젯이 너무 껍데기만 남은 것은 아닌지 아키텍처 관점에서의 피드백이 궁금합니다.</p>
<p>A1)
굳이 FSD에 부합할 필요가 있을까요?
저는 Entity가 &quot;리액트에 의존적이지 않은 코드&quot; 라고 정의해야 제일 편하다고 생각해요 ㅎㅎ
말씀해주신 것 처럼 순수한 계산 로직이 entity에 있으면 좋달까!?
feature도 적절하게 분리해주신 것 같습니다.</p>
<p>다만, FSD에 너무 집착하진 않았으면 좋겠어요.
FSD는 관심사를 분리하는 일종의 패턴이고, 이 패턴 자체가 굉장히 복잡합니다.</p>
<p>위젯은 뭐.. 없어도 되는 레이어라고 생각합니다 ㅎㅎ
개인적으로 entities와 features를 합쳐도 무방하지 않나!? 라고 생각해요!</p>
<hr/>
<p>Q2) 상태 관리 및 동기화 관점 (Zustand &amp; Sync)
App.tsx에서의 수동 데이터 동기화 패턴이 적절한지 궁금합니다.
Zustand의 persist 미들웨어를 사용하는 대신, persist를 제거하고 App.tsx에서 useEffect를 통해 로컬스토리지와 스토어를 수동으로 동기화하는 방식을 택했습니다.
이는 테스트 환경에서의 격리와 레거시 데이터 호환성을 확보하기 위함이었는데요. 이 패턴이 장기적인 유지보수 측면에서도 유효할지, 혹은 더 나은 대안이 있을지 의견이 궁금합니다.</p>
<p>음.. 일단 제일 큰 문제는 최초에 렌더링할 때 storage의 값을 사용할 수 없다는 점인데요, 이건 추후에 발목을 잡을 수 있답니다 ㅎㅎ
그냥 persist 미들웨어를 사용하고, 이 때 테스트를 어떻게 작성하면 좋을지 알아보는게 더 좋지 않을까요?</p>
<p>레거시 데이터 호환성은... 어떤 레거시를 이야기하는지 잘 모르겠네요..!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 박수범 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 박수범, [5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 박수범 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 박수범 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
