<link rel="preload" as="image" href="https://github.com/user-attachments/assets/67f4cb51-da9a-44ff-ba4b-90ef7d84f8e4"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/b39eb5df-62a5-4ee2-bdbc-057742fff5d6"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/813a97ad-fe48-4bcc-a1d8-61ec29e85219"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/9000597b-bd6c-47b0-a081-b4594f648db1"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/a61d7692-ae9f-4a57-b021-95945ee5f4ff"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/81975216-83ff-4eeb-a32f-c5498a53cf5f"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/e357db7d-12ed-4bf8-b02c-5c36d59a8d30"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/112484bc-10c8-4f77-bdfd-4af9096bbb9a"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/cbf711b0-204e-4de7-bd75-d1fb114e5606"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/d6908b52-b295-4744-922e-77394234a723"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@parksubeom/" data-discover="true">parksubeom<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter4-2/pull/6" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->parksubeom</span><span>2025.12.21</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h1 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h1>
<p><a href="https://parksubeom.github.io/front_7th_chapter4-2/">배포주소</a></p>
<h2 id="과제-요구사항"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-요구사항"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 요구사항</h2>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 배포 후 url 제출</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> API 호출 최적화(<code>Promise.all</code> 이해)긴</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 연산 최적화</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> SearchDialog 불필요한 리렌더링 최적화</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 시간표 블록 드래그시 렌더링 최적화</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 시간표 블록 드롭시 렌더링 최적화</p>
</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<details>
<summary><h2 id="1일차--검색-다이얼로그searchdialog-최적화"><a aria-hidden="true" tabindex="-1" href="#1일차--검색-다이얼로그searchdialog-최적화"><span class="icon icon-link"></span></a>1일차 : 검색 다이얼로그(SearchDialog) 최적화</h2></summary>
<h2 id="성능-개선-api-호출-병렬화-및-중복-제거"><a aria-hidden="true" tabindex="-1" href="#성능-개선-api-호출-병렬화-및-중복-제거"><span class="icon icon-link"></span></a>성능 개선: API 호출 병렬화 및 중복 제거</h2>
<h3 id="1-문제-분석"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>직렬 처리:</strong> <code>Promise.all</code> 내부에 <code>await</code> 키워드를 사용하여 API가 순차적으로 호출됨. 앞선 요청이 끝나야 다음 요청이 시작되는 비효율적인 대기 시간 발생.</li>
<li><strong>불필요한 중복 호출:</strong> 동일한 리소스(<code>fetchMajors</code>, <code>fetchLiberalArts</code>)를 3번씩 중복 호출하여 총 6번의 불필요한 네트워크 트래픽 발생.</li>
<li><strong>영향:</strong> 메인 콘텐츠 렌더링(LCP)이 API 응답 시간의 총합만큼 지연됨 (LCP: 2.89s 측정).</li>
</ul>
<h3 id="2-코드-변경-사항"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 현재 코드: await를 만나서 API 1번 끝나야 2번 호출 (순차적)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">fetchAllLectures</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#x27;API Call 1&#x27;</span><span class="token punctuation">,</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">fetchMajors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">(</span><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#x27;API Call 2&#x27;</span><span class="token punctuation">,</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">fetchLiberalArts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token comment">// ... 반복 (총 6번 호출) ...</span>
</span><span class="code-line"><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 현재 코드: await를 만나서 API 1번 끝나야 2번 호출 (순차적)
const fetchAllLectures = async () =&gt; await Promise.all([
  (console.log(&#x27;API Call 1&#x27;, performance.now()), await fetchMajors()),
  (console.log(&#x27;API Call 2&#x27;, performance.now()), await fetchLiberalArts()),
  // ... 반복 (총 6번 호출) ...
]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 수정된 fetchAllLectures: 불필요한 중복 제거 및 병렬 호출</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">fetchAllLectures</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> start <span class="token operator">=</span> performance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#x27;API 호출 시작: &#x27;</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 1. Promise 객체를 먼저 생성 (호출 시작)</span>
</span><span class="code-line">  <span class="token keyword">const</span> majorsPromise <span class="token operator">=</span> <span class="token function">fetchMajors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> liberalArtsPromise <span class="token operator">=</span> <span class="token function">fetchLiberalArts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 2. Promise.all로 두 요청이 모두 끝날 때까지 병렬 대기</span>
</span><span class="code-line">  <span class="token keyword">const</span> results <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token builtin">Promise</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
</span><span class="code-line">    majorsPromise<span class="token punctuation">,</span>
</span><span class="code-line">    liberalArtsPromise
</span><span class="code-line">  <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// ... 로그 출력 ...</span>
</span><span class="code-line">  <span class="token keyword">return</span> results<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 수정된 fetchAllLectures: 불필요한 중복 제거 및 병렬 호출
const fetchAllLectures = async () =&gt; {
  const start = performance.now();
  console.log(&#x27;API 호출 시작: &#x27;, start);

  // 1. Promise 객체를 먼저 생성 (호출 시작)
  const majorsPromise = fetchMajors();
  const liberalArtsPromise = fetchLiberalArts();

  // 2. Promise.all로 두 요청이 모두 끝날 때까지 병렬 대기
  const results = await Promise.all([
    majorsPromise,
    liberalArtsPromise
  ]);

  // ... 로그 출력 ...
  return results;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-개선-방안"><a aria-hidden="true" tabindex="-1" href="#3-개선-방안"><span class="icon icon-link"></span></a>3. 개선 방안</h3>
<ul>
<li><strong>병렬 처리:</strong> 프로미스를 즉시 실행시키고, <code>Promise.all</code>로 동시에 대기하여 전체 소요 시간을 가장 느린 요청 하나의 시간으로 단축.</li>
<li><strong>중복 제거:</strong> 실제 필요한 <code>전공</code>과 <code>교양</code> 데이터만 1회씩 호출.</li>
</ul>
<h3 id="4-개선-근거"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>자바스크립트 비동기 처리:</strong> 네트워크 대기 시간 동안 메인 스레드를 차단하지 않고 병렬로 요청을 처리하는 자바스크립트의 특성을 활용.</li>
<li><strong>리소스 효율성:</strong> 불필요한 네트워크 대역폭 낭비를 줄이고, 클라이언트의 메모리 사용량을 최적화함.</li>
</ul>
<h3 id="5-예상-효과"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>네트워크 순차 대기 현상 제거로 초기 로딩 속도 획기적 단축 예상.</li>
<li>중복 호출 제거로 서버 부하 감소 및 사용자 경험 개선.</li>
</ul>
<hr/>
<h2 id="성능-개선-검색-필터링-연산-메모이제이션"><a aria-hidden="true" tabindex="-1" href="#성능-개선-검색-필터링-연산-메모이제이션"><span class="icon icon-link"></span></a>성능 개선: 검색 필터링 연산 메모이제이션</h2>
<h3 id="1-문제-분석-1"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-1"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>불필요한 재연산:</strong> <code>SearchDialog</code> 컴포넌트 내 <code>getFilteredLectures</code> 함수가 컴포넌트 리렌더링(입력, 스크롤 등)이 발생할 때마다 매번 실행됨.</li>
<li><strong>비용 높은 로직:</strong> 수천 개의 강의 데이터를 대상으로 필터링, 포함 여부 확인, 문자열 파싱 같은 무거운 연산을 반복 수행.</li>
<li><strong>영향:</strong> 검색어를 한 글자 입력할 때마다 메인 스레드가 필터링 연산에 점유되어, 입력 지연 현상이 발생함.</li>
</ul>
<h3 id="2-코드-변경-사항-1"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-1"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 렌더링될 때마다 매번 실행됨</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">getFilteredLectures</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> query <span class="token operator">=</span> <span class="token string">&#x27;&#x27;</span><span class="token punctuation">,</span> credits<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token operator">=</span> searchOptions<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> lectures
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>lecture <span class="token operator">=&gt;</span> <span class="token operator">...</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token comment">// ... 수천 번의 루프와 파싱 작업 ...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line"><span class="token keyword">const</span> filteredLectures <span class="token operator">=</span> <span class="token function">getFilteredLectures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 렌더링될 때마다 매번 실행됨
const getFilteredLectures = () =&gt; {
  const { query = &#x27;&#x27;, credits, ... } = searchOptions;
  return lectures
    .filter(lecture =&gt; ...)
    // ... 수천 번의 루프와 파싱 작업 ...
}
const filteredLectures = getFilteredLectures();
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">import</span> <span class="token punctuation">{</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#x27;react&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 의존성 배열(searchOptions, lectures)이 변할 때만 재계산</span>
</span><span class="code-line"><span class="token keyword">const</span> filteredLectures <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">{</span> query <span class="token operator">=</span> <span class="token string">&#x27;&#x27;</span><span class="token punctuation">,</span> credits<span class="token punctuation">,</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token operator">=</span> searchOptions<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> lectures
</span><span class="code-line">    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>lecture <span class="token operator">=&gt;</span> <span class="token operator">...</span><span class="token punctuation">)</span>
</span><span class="code-line">    <span class="token comment">// ... (동일한 로직) ...</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchOptions<span class="token punctuation">,</span> lectures<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="import { useMemo } from &#x27;react&#x27;;

// 의존성 배열(searchOptions, lectures)이 변할 때만 재계산
const filteredLectures = useMemo(() =&gt; {
  const { query = &#x27;&#x27;, credits, ... } = searchOptions;
  return lectures
    .filter(lecture =&gt; ...)
    // ... (동일한 로직) ...
}, [searchOptions, lectures]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-개선-방안-1"><a aria-hidden="true" tabindex="-1" href="#3-개선-방안-1"><span class="icon icon-link"></span></a>3. 개선 방안</h3>
<ul>
<li><strong>메모이제이션 적용:</strong> <code>useMemo</code> 훅을 사용하여 검색 옵션이나 강의 데이터가 실제로 변경되었을 때만 필터링 로직을 수행하도록 변경.</li>
<li><strong>참조 안정성:</strong> 필터링 결과 배열의 참조값을 유지하여, 하위 컴포넌트의 불필요한 리렌더링 방지 효과도 부수적으로 기대함.</li>
</ul>
<h3 id="4-개선-근거-1"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-1"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>연산 비용 절감:</strong> 문자열 파싱과 대량의 배열 순회는 자바스크립트 메인 스레드에 부담을 주는 작업이므로, 입력과 같은 빈번한 이벤트 시에는 캐싱이 필수적임.</li>
<li><strong>이벤트 루프 차단 방지:</strong> 필터링 연산이 길어지면 메인 스레드가 차단되어 사용자 입력에 대한 반응이 지연되고, INP 점수가 하락함.</li>
</ul>
<h3 id="5-예상-효과-1"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-1"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>검색어 입력 시 발생하는 렉 현상 제거 및 반응성 지표 개선.</li>
<li>메인 스레드 부하 감소로 전반적인 UI 반응성 향상.</li>
</ul>
<hr/>
<h2 id="성능개선-검색-필터-ui-분리-및-불필요한-리렌더링-방지"><a aria-hidden="true" tabindex="-1" href="#성능개선-검색-필터-ui-분리-및-불필요한-리렌더링-방지"><span class="icon icon-link"></span></a>성능개선: 검색 필터 UI 분리 및 불필요한 리렌더링 방지</h2>
<h3 id="1-문제-분석-2"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-2"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>전체 리렌더링 문제:</strong> 무한 스크롤 동작 시 페이지 상태가 변경되면, 상위 컴포넌트인 <code>SearchDialog</code> 전체가 리렌더링되는 구조.</li>
<li><strong>불필요한 렌더링:</strong> 변경 사항이 없는 검색 옵션 영역(입력창, 체크박스 등)까지 매번 재생성되어 자원을 낭비함.</li>
<li><strong>고비용 연산 반복:</strong> 전공 목록 생성 로직과 같은 연산이 렌더링마다 반복 수행됨.</li>
</ul>
<h3 id="2-코드-변경-사항-2"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-2"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>(변경 전)</strong> <code>SearchDialog</code> 내부에 필터 UI가 결합되어 있어 페이지 변경 시 같이 렌더링됨.
<img width="840" height="700" alt="image" src="https://github.com/user-attachments/assets/67f4cb51-da9a-44ff-ba4b-90ef7d84f8e4"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">SearchDialog</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>page<span class="token punctuation">,</span> setPage<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">   
</span><span class="code-line">  <span class="token comment">// 렌더링마다 매번 재연산</span>
</span><span class="code-line">  <span class="token keyword">const</span> allMajors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>lectures<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token function-variable function">changeSearchOption</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 매번 새로운 참조 생성</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* SearchDialog 내부에 필터 UI가 결합되어 있어 page 변경 시 같이 렌더링됨 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token spread operator">...</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="const SearchDialog = () =&gt; {
  const [page, setPage] = useState(1);
   
  // 렌더링마다 매번 재연산
  const allMajors = [...new Set(lectures.map(...))];
  const changeSearchOption = (...) =&gt; { ... }; // 매번 새로운 참조 생성

  return (
      {/* SearchDialog 내부에 필터 UI가 결합되어 있어 page 변경 시 같이 렌더링됨 */}
      ...
  );
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>(변경 후)</strong>
<img width="840" height="750" alt="image" src="https://github.com/user-attachments/assets/b39eb5df-62a5-4ee2-bdbc-057742fff5d6"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 1. 별도 컴포넌트로 분리 및 React.memo 적용</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">SearchFilter</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> searchOptions<span class="token punctuation">,</span> changeSearchOption<span class="token punctuation">,</span> allMajors <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token spread operator">...</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">SearchDialog</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 2. 데이터 연산 최적화 (참조 안정화)</span>
</span><span class="code-line">  <span class="token keyword">const</span> allMajors <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">[</span><span class="token spread operator">...</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>lectures<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token comment">// 3. 핸들러 최적화</span>
</span><span class="code-line">  <span class="token keyword">const</span> changeSearchOption <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">      <span class="token punctuation">{</span><span class="token comment">/* 페이지가 변해도 props가 동일하므로 리렌더링 건너뜀 */</span><span class="token punctuation">}</span>
</span><span class="code-line">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">SearchFilter</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/&gt;</span></span>
</span><span class="code-line">      <span class="token spread operator">...</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// 1. 별도 컴포넌트로 분리 및 React.memo 적용
const SearchFilter = memo(({ searchOptions, changeSearchOption, allMajors }) =&gt; {
  return ...;
});

const SearchDialog = () =&gt; {
  // 2. 데이터 연산 최적화 (참조 안정화)
  const allMajors = useMemo(() =&gt; [...], [lectures]);
  
  // 3. 핸들러 최적화
  const changeSearchOption = useCallback((...) =&gt; { ... }, []);

  return (
      {/* 페이지가 변해도 props가 동일하므로 리렌더링 건너뜀 */}
      &lt;SearchFilter ... /&gt;
      ...
  );
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-개선-방안-2"><a aria-hidden="true" tabindex="-1" href="#3-개선-방안-2"><span class="icon icon-link"></span></a>3. 개선 방안</h3>
<ul>
<li><strong>컴포넌트 분리:</strong> 복잡하고 정적인 검색 필터 UI를 별도 컴포넌트로 분리하여 렌더링 경계를 격리.</li>
<li><strong>React.memo 적용:</strong> 분리된 컴포넌트에 메모이제이션을 적용하여 전달받은 값이 변경되지 않는 한 리렌더링을 방지.</li>
<li><strong>참조 안정성 확보:</strong> <code>useMemo</code>와 <code>useCallback</code>을 사용하여 하위 컴포넌트에 안정적인 참조를 전달.</li>
</ul>
<h3 id="4-개선-근거-2"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-2"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>렌더링 성능:</strong> 무한 스크롤과 같이 빈번하게 상태가 변하는 로직과 정적인 UI를 분리함으로써, 브라우저의 그리기 부하를 줄이고 화면 끊김을 방지.</li>
<li><strong>관심사의 분리:</strong> UI와 비즈니스 로직의 결합도를 낮춰 유지보수성을 향상.</li>
<li><strong>참조 동일성 활용:</strong> React는 값 비교 시 참조 동일성을 사용하므로, 참조를 안정화하면 <code>React.memo</code>의 효과를 극대화할 수 있음.</li>
</ul>
<h3 id="5-예상-효과-2"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-2"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>스크롤 시 검색 필터 영역의 불필요한 리렌더링이 0회로 감소.</li>
<li>복잡한 컴포넌트 구조 단순화로 가독성 및 유지보수성 증대.</li>
<li>메인 스레드 부하 감소로 전반적인 스크롤 성능 향상.</li>
</ul>
<hr/>
<h2 id="문제-수정-콜백-ref-패턴으로-무한-스크롤-초기화-타이밍-이슈-해결"><a aria-hidden="true" tabindex="-1" href="#문제-수정-콜백-ref-패턴으로-무한-스크롤-초기화-타이밍-이슈-해결"><span class="icon icon-link"></span></a>문제 수정: 콜백 Ref 패턴으로 무한 스크롤 초기화 타이밍 이슈 해결</h2>
<h3 id="1-문제-분석-3"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-3"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>타이밍 문제:</strong> 모달의 렌더링 특성상, <code>useEffect</code>가 최초 실행되는 시점에 관찰 대상인 DOM 요소가 아직 생성되지 않아 <code>null</code>인 경우가 발생.</li>
<li><strong>감지되지 않는 업데이트:</strong> 이후 DOM이 생성되어 참조값이 채워지더라도, <code>useRef</code>는 리렌더링을 유발하지 않으므로 <code>useEffect</code>가 이를 인지하지 못하고 옵저버 연결이 누락됨.</li>
<li><strong>영향:</strong> 모달을 처음 열거나 특정 조건에서 무한 스크롤이 작동하지 않는 버그 발생.</li>
</ul>
<h3 id="2-코드-변경-사항-3"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-3"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> loaderRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 변화 감지 불가</span>
</span><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loaderRef<span class="token punctuation">.</span><span class="token property-access">current</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 실행 시점에 null이면 그냥 종료됨</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchInfo<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const loaderRef = useRef(null); // 변화 감지 불가
useEffect(() =&gt; {
  if (!loaderRef.current) return; // 실행 시점에 null이면 그냥 종료됨
}, [searchInfo]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token punctuation">[</span>loader<span class="token punctuation">,</span> setLoader<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// DOM 생성 시 리렌더링 트리거</span>
</span><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>loader<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// loader 상태가 업데이트되면 다시 실행됨</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>loader<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// JSX: ref 속성에 상태 설정 함수 전달</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Box</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>setLoader<span class="token punctuation">}</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/&gt;</span></span>
</span></code><div class="copied" data-code="const [loader, setLoader] = useState(null); // DOM 생성 시 리렌더링 트리거
useEffect(() =&gt; {
  if (!loader) return; // loader 상태가 업데이트되면 다시 실행됨
}, [loader]); 

// JSX: ref 속성에 상태 설정 함수 전달
&lt;Box ref={setLoader} ... /&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>콜백 Ref 패턴:</strong> <code>useRef</code> 대신 <code>useState</code>를 사용하여 DOM 요소의 생성/소멸 생명주기를 상태로 관리.</li>
<li><strong>반응형 옵저버:</strong> DOM 요소가 실제로 화면에 그려지는 시점에 상태가 업데이트되도록 하여, <code>IntersectionObserver</code>가 누락 없이 연결되도록 보장.</li>
</ul>
<h3 id="4-개선-근거-3"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-3"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>React 생명주기:</strong> <code>useRef</code>는 값이 변경되어도 컴포넌트를 다시 그리지 않지만, <code>useState</code>는 상태 변경 시 다시 그리기를 유발하므로 변화를 감지할 수 있음.</li>
<li><strong>콜백 Ref:</strong> JSX의 <code>ref</code> 속성에 함수를 전달하면, DOM이 생성될 때 해당 함수가 호출되어 정확한 타이밍에 상태를 업데이트할 수 있음.</li>
</ul>
<h3 id="5-예상-효과-3"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-3"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>모달을 처음 열 때, 새로고침 할 때 등 모든 상황에서 무한 스크롤 기능이 안정적으로 동작함.</li>
<li>옵저버 연결 실패로 인한 버그가 완전히 제거됨.</li>
</ul>
<hr/>
<h2 id="성능-개선-api-호출-시점-지연"><a aria-hidden="true" tabindex="-1" href="#성능-개선-api-호출-시점-지연"><span class="icon icon-link"></span></a>성능 개선: API 호출 시점 지연</h2>
<h3 id="1-문제-분석-4"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-4"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>이른 데이터 호출:</strong> 컴포넌트가 화면에 나타남과 동시에 대용량 데이터를 즉시 호출함.</li>
<li><strong>리소스 경합:</strong> 페이지 초기 로딩 구간에서 불필요한 네트워크 대역폭과 자원을 점유하여, 주요 콘텐츠 렌더링 성능 저하를 유발함.</li>
<li><strong>사용자 의도 불일치:</strong> 사용자가 검색 버튼을 누르기 전까지는 해당 데이터가 필요하지 않음에도 미리 요청이 발생함.</li>
</ul>
<h3 id="2-코드-변경-사항-4"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-4"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전</strong>
<img width="312" height="236" alt="image" src="https://github.com/user-attachments/assets/813a97ad-fe48-4bcc-a1d8-61ec29e85219"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 컴포넌트 마운트 시 무조건 실행</span>
</span><span class="code-line">  <span class="token function">fetchAllLectures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="useEffect(() =&gt; {
  // 컴포넌트 마운트 시 무조건 실행
  fetchAllLectures().then(...);
}, []);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong>
<img width="312" height="236" alt="image" src="https://github.com/user-attachments/assets/9000597b-bd6c-47b0-a081-b4594f648db1"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 모달이 열리지 않았거나 이미 데이터를 가져온 경우 중단</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searchInfo <span class="token operator">||</span> lectures<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token comment">// 모달이 열리는 순간 데이터 로딩 시작</span>
</span><span class="code-line">  <span class="token function">fetchAllLectures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token method function property-access">then</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>searchInfo<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="useEffect(() =&gt; {
  // 모달이 열리지 않았거나 이미 데이터를 가져온 경우 중단
  if (!searchInfo || lectures.length &gt; 0) return;

  // 모달이 열리는 순간 데이터 로딩 시작
  fetchAllLectures().then(...);
}, [searchInfo]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-1"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-1"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>지연 호출:</strong> 데이터 로딩 시점을 페이지 로드 시점이 아닌 모달이 열리는 시점으로 지연.</li>
<li><strong>조건부 호출:</strong> 이미 로드된 데이터가 있을 경우 API 재요청을 방지하는 간단한 캐싱 로직 적용.</li>
</ul>
<h3 id="4-개선-근거-4"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-4"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>주요 렌더링 경로 최적화:</strong> 초기 렌더링에 필수적이지 않은 네트워크 요청을 미루어 브라우저가 주요 콘텐츠 렌더링에 집중할 수 있도록 함.</li>
<li><strong>필요 시점 로딩:</strong> 사용자의 명확한 의도가 발생한 이후에만 리소스를 요청하여 불필요한 트래픽 및 연산 낭비를 제거함.</li>
</ul>
<h3 id="5-예상-효과-4"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-4"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>초기 페이지 로딩 시 발생하던 네트워크 병목 현상 제거.</li>
<li>LCP(최대 콘텐츠 렌더링 시간) 지표의 유의미한 개선.</li>
<li>사용자 동작 기반 데이터 로딩으로 체감 성능 향상.</li>
</ul>
<hr/>
<h2 id="성능-개선-검색-필터-렌더링-최적화"><a aria-hidden="true" tabindex="-1" href="#성능-개선-검색-필터-렌더링-최적화"><span class="icon icon-link"></span></a>성능 개선: 검색 필터 렌더링 최적화</h2>
<h3 id="1-문제-분석-5"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-5"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>렌더링 차단:</strong> 검색어 입력 시 필터 컴포넌트 전체가 다시 그려짐.</li>
<li><strong>무거운 가상 DOM 생성:</strong> 텍스트 한 글자를 입력할 때마다 수백 개의 체크박스 가상 DOM이 재생성되며 메인 스레드를 점유, 입력 지연이 발생함.</li>
<li><strong>깨진 메모이제이션:</strong> 하위 컴포넌트에 전달되는 이벤트 핸들러가 인라인 함수로 선언되어 렌더링마다 참조값이 변경되고, 이로 인해 <code>React.memo</code>가 작동하지 않음.</li>
</ul>
<h3 id="2-코드-변경-사항-5"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-5"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전</strong>
<img width="1000" height="740" alt="image" src="https://github.com/user-attachments/assets/a61d7692-ae9f-4a57-b021-95945ee5f4ff"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">SearchFilter</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> searchOptions<span class="token punctuation">,</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 1. 거대한 단일 컴포넌트</span>
</span><span class="code-line">  <span class="token comment">// 2. 인라인 핸들러로 인해 매 렌더마다 새로운 함수 생성</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Stack</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Input</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">CheckboxGroup</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">changeSearchOption</span><span class="token punctuation">(</span><span class="token string">&quot;majors&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">        </span><span class="token punctuation">{</span><span class="token comment">/* 수백 개의 전공 리스트가 매번 재생성됨 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">CheckboxGroup</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Stack</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const SearchFilter = memo(({ searchOptions, ... }) =&gt; {
  // 1. 거대한 단일 컴포넌트
  // 2. 인라인 핸들러로 인해 매 렌더마다 새로운 함수 생성
  return (
    &lt;Stack&gt;
      &lt;Input ... /&gt;
      &lt;CheckboxGroup onChange={(v) =&gt; changeSearchOption(&quot;majors&quot;, v)}&gt;
        {/* 수백 개의 전공 리스트가 매번 재생성됨 */}
      &lt;/CheckboxGroup&gt;
    &lt;/Stack&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong>
<img width="1000" height="740" alt="image" src="https://github.com/user-attachments/assets/81975216-83ff-4eeb-a32f-c5498a53cf5f"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 1. 컴포넌트 쪼개기 및 메모이제이션</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">MajorCheckboxGroup</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> majors<span class="token punctuation">,</span> onChange <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">SearchFilter</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> searchOptions<span class="token punctuation">,</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 2. 핸들러 참조 안정화</span>
</span><span class="code-line">  <span class="token keyword">const</span> handleChangeMajors <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">changeSearchOption</span><span class="token punctuation">(</span><span class="token string">&quot;majors&quot;</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span>
</span><span class="code-line">    <span class="token punctuation">[</span><span class="token punctuation">]</span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Stack</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Input</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text"> </span><span class="token punctuation">{</span><span class="token comment">/* 검색어 입력 시 이 부분만 리렌더링 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token punctuation">{</span><span class="token comment">/* props가 변경되지 않아 렌더링 건너뜀 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MajorCheckboxGroup</span></span> <span class="token attr-name">onChange</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleChangeMajors<span class="token punctuation">}</span></span> <span class="token attr-name">...</span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Stack</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. 컴포넌트 쪼개기 및 메모이제이션
const MajorCheckboxGroup = memo(({ majors, onChange }) =&gt; { ... });

const SearchFilter = memo(({ searchOptions, ... }) =&gt; {
  // 2. 핸들러 참조 안정화
  const handleChangeMajors = useCallback(
    (v) =&gt; changeSearchOption(&quot;majors&quot;, v),
    []
  );

  return (
    &lt;Stack&gt;
      &lt;Input ... /&gt; {/* 검색어 입력 시 이 부분만 리렌더링 */}
      {/* props가 변경되지 않아 렌더링 건너뜀 */}
      &lt;MajorCheckboxGroup onChange={handleChangeMajors} ... /&gt;
    &lt;/Stack&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-2"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-2"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>컴포넌트 분리:</strong> 비대한 필터 컴포넌트를 작은 단위로 나누고 각각에 <code>React.memo</code>를 적용.</li>
<li><strong>핸들러 안정화:</strong> <code>useCallback</code>을 사용해 이벤트 핸들러의 참조값을 고정하여, 불필요한 리렌더링을 원천 차단.</li>
</ul>
<h3 id="4-개선-근거-5"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-5"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>참조 동일성:</strong> React의 최적화는 값의 참조 동일성에 의존하므로, 핸들러를 안정화해야 <code>React.memo</code>가 효과를 발휘함.</li>
<li><strong>렌더링 범위 최소화:</strong> 검색어 입력과 관련 없는 대규모 체크박스 UI를 렌더링 경로에서 분리하여 메인 스레드 부하를 줄임.</li>
</ul>
<h3 id="5-예상-효과-5"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-5"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>검색어 입력 시 CPU 사용량 최소화 및 렌더링 범위 국소화.</li>
<li>사용자가 체감하던 입력 지연 현상 완전 제거.</li>
</ul>
<hr/>
<h2 id="성능-개선-데이터-전처리를-통한-필터링-연산-최적화"><a aria-hidden="true" tabindex="-1" href="#성능-개선-데이터-전처리를-통한-필터링-연산-최적화"><span class="icon icon-link"></span></a>성능 개선: 데이터 전처리를 통한 필터링 연산 최적화</h2>
<h3 id="1-문제-분석-6"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-6"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>반복적인 고비용 연산:</strong> 필터링이 수행될 때마다 수천 개의 강의 객체에 대해 문자열 파싱 로직이 반복 실행됨.</li>
<li><strong>반응성 저하:</strong> 문자열 파싱은 비용이 큰 연산으로, 필터링 시마다 메인 스레드를 장시간 점유하여 심각한 입력 지연을 유발함.</li>
</ul>
<h3 id="2-코드-변경-사항-6"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-6"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 필터링 시마다 파싱 수행 (비용: N × 파싱비용)</p>
<p><strong>변경 후</strong></p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 1. 데이터 로드 시 단 1회만 파싱 (전처리)</span>
</span><span class="code-line"><span class="token function">setLectures</span><span class="token punctuation">(</span>
</span><span class="code-line">  data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token operator">...</span>l<span class="token punctuation">,</span>
</span><span class="code-line">    schedules<span class="token operator">:</span> l<span class="token punctuation">.</span>schedule <span class="token operator">?</span> <span class="token function">parseSchedule</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>schedule<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 필터링 시에는 이미 계산된 값만 참조 (비용: N)</span>
</span><span class="code-line"><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lecture<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> lecture<span class="token punctuation">.</span>schedules<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. 데이터 로드 시 단 1회만 파싱 (전처리)
setLectures(
  data.map((l) =&gt; ({
    ...l,
    schedules: l.schedule ? parseSchedule(l.schedule) : [],
  }))
);

// 2. 필터링 시에는 이미 계산된 값만 참조 (비용: N)
.filter((lecture) =&gt; lecture.schedules.some(...));
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-3"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-3"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>데이터 변환:</strong> API 응답을 수신하는 즉시 문자열을 파싱하여 객체에 미리 저장.</li>
<li><strong>전처리 전략:</strong> 계산 비용이 큰 파싱 로직을 빈번한 필터링 단계가 아닌 데이터 로딩 단계로 이동.</li>
<li><strong>로직 단순화:</strong> 필터 로직에서 파싱 함수를 제거하고, 미리 계산된 속성만 참조하도록 변경.</li>
</ul>
<h3 id="4-개선-근거-6"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-6"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>시간 복잡도 최적화:</strong> 사용자 입력 시 수행되는 연산 비용을 구조적으로 축소.</li>
<li><strong>렌더링 경로 경량화:</strong> 필터링 로직에서 고비용 연산을 제거하여 메인 스레드 점유를 최소화.</li>
<li><strong>전처리 원칙:</strong> &quot;비싼 계산은 렌더링 경로 밖에서 한 번만 수행한다&quot;는 원칙 적용.</li>
</ul>
<h3 id="5-예상-효과-6"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-6"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>필터링 연산 비용 감소로 검색 및 필터 반응 속도 비약적 향상.</li>
<li>데이터 규모가 증가하더라도 성능 저하 없이 확장 가능한 구조 확보.</li>
</ul>
<hr/>
<h2 id="성능-개선-문자열-검색-전처리"><a aria-hidden="true" tabindex="-1" href="#성능-개선-문자열-검색-전처리"><span class="icon icon-link"></span></a>성능 개선: 문자열 검색 전처리</h2>
<h3 id="1-문제-분석-7"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-7"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>메모리 낭비:</strong> 필터링 로직 내부에서 소문자 변환 함수를 직접 호출함에 따라, 검색어 입력 시마다 수천 개의 임시 문자열 객체가 반복적으로 생성되고 파괴됨.</li>
<li><strong>가비지 컬렉션 부하:</strong> 빈번한 메모리 할당과 해제는 브라우저의 가비지 컬렉터를 자극하여 메인 스레드를 일시적으로 멈추게 함.</li>
<li><strong>입력 지연:</strong> 가비지 컬렉션 개입 시점이 사용자 입력과 겹치면서 입력 반응성이 저하됨.</li>
</ul>
<h3 id="2-코드-변경-사항-7"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-7"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 매 필터링 루프마다 문자열 변환 및 메모리 할당 발생.</p>
<p><strong>변경 후</strong></p>
<pre class="language-ts"><code class="language-ts code-highlight"><span class="code-line"><span class="token comment">// 1. 데이터 로드 시 단 1회만 문자열 전처리</span>
</span><span class="code-line"><span class="token keyword">const</span> titleLower <span class="token operator">=</span> lecture<span class="token punctuation">.</span>title<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 필터링 시에는 변환 없이 비교만 수행 (객체 생성 없음)</span>
</span><span class="code-line"><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>lecture<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> lecture<span class="token punctuation">.</span>titleLower<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>queryLower<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. 데이터 로드 시 단 1회만 문자열 전처리
const titleLower = lecture.title.toLowerCase();

// 2. 필터링 시에는 변환 없이 비교만 수행 (객체 생성 없음)
.filter((lecture) =&gt; lecture.titleLower.includes(queryLower));
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-4"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-4"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>데이터 구조 확장:</strong> 강의 객체에 검색 전용 필드를 추가.</li>
<li><strong>사전 계산:</strong> 데이터 로딩 시점에 문자열 변환을 1회만 수행.</li>
<li><strong>객체 생성 방지:</strong> 필터링 시점에서는 변환 함수 호출을 제거하고, 이미 처리된 문자열 간 비교만 수행.</li>
</ul>
<h3 id="4-개선-근거-7"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-7"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>객체 생성 최소화 전략:</strong> 성능에 민감한 루프 내부에서 객체 생성을 제거하여 메모리 압력을 감소.</li>
<li><strong>관심사의 분리:</strong> 데이터 가공은 로딩 시점에, 비교는 인터랙션 시점에 수행하여 사용자 입력 경로에는 저비용 연산만 남김.</li>
</ul>
<h3 id="5-예상-효과-7"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-7"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>검색 시 메모리 사용량 그래프의 급격한 변동 제거 및 안정화.</li>
<li>빠른 연속 타이핑 상황에서도 끊김 없는 부드러운 입력 반응성 확보.</li>
</ul>
<hr/>
<h2 id="성능개선-필터링-로직의-가독성-및-연산-효율-개선"><a aria-hidden="true" tabindex="-1" href="#성능개선-필터링-로직의-가독성-및-연산-효율-개선"><span class="icon icon-link"></span></a>성능개선: 필터링 로직의 가독성 및 연산 효율 개선</h2>
<h3 id="1-문제-분석-8"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-8"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>높은 복잡도:</strong> 여러 조건이 하나의 긴 표현식으로 결합되어 있어 로직 파악이 어려움.</li>
<li><strong>디버깅 어려움:</strong> 필터 결과가 예상과 다를 경우, 어떤 조건에서 문제가 발생했는지 추적하기 어려움.</li>
<li><strong>실행 효율 한계:</strong> 모든 조건이 하나로 묶여 있어 실행 순서 제어 및 비용 기반 최적화가 어려움.</li>
</ul>
<h3 id="2-코드-변경-사항-8"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-8"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 모든 조건이 하나의 <code>return</code> 문에 결합된 구조.</p>
<p><strong>변경 후:</strong> 조건을 개별적으로 검사하고, 불만족 시 즉시 종료하는 구조.</p>
<pre class="language-js"><code class="language-js code-highlight"><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>queryLower <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>lecture<span class="token punctuation">.</span><span class="token property-access">titleLower</span><span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>queryLower<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword control-flow">if</span> <span class="token punctuation">(</span>grades<span class="token punctuation">.</span><span class="token property-access">length</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>grades<span class="token punctuation">.</span><span class="token method function property-access">includes</span><span class="token punctuation">(</span>lecture<span class="token punctuation">.</span><span class="token property-access">grade</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword control-flow">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token comment">// ...</span>
</span><span class="code-line"><span class="token keyword control-flow">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="if (queryLower &amp;&amp; !lecture.titleLower.includes(queryLower)) return false;
if (grades.length &gt; 0 &amp;&amp; !grades.includes(lecture.grade)) return false;
// ...
return true;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-5"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-5"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>보호 구문 패턴 도입:</strong> 조건을 만족하지 않는 경우를 <code>if</code> 문으로 즉시 반환하여 불필요한 연산을 조기에 차단.</li>
<li><strong>순차적 검증:</strong> 필터 조건을 논리적 단위로 분리하고, 위에서 아래로 흐르는 선형적인 구조로 변경.</li>
</ul>
<h3 id="4-개선-근거-8"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-8"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>단축 평가 최적화:</strong> 앞선 조건에서 탈락하면 뒤쪽의 비용이 큰 연산은 실행하지 않음으로써 CPU 자원을 절약.</li>
<li><strong>유지보수성:</strong> 새로운 필터 조건 추가 시 기존 로직을 수정할 필요 없이 구문 하나를 추가하는 방식으로 확장 가능.</li>
</ul>
<h3 id="5-예상-효과-8"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-8"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li><strong>디버깅 속도:</strong> 특정 조건에 로그를 심거나 디버거를 연결하여 즉시 원인 파악 가능.</li>
<li><strong>성능:</strong> 필터 조건이 늘어날수록 불필요한 고비용 연산을 조기에 차단하여 성능 방어.</li>
<li><strong>코드 품질:</strong> 가독성이 좋아져 팀원 누구나 로직을 빠르게 이해 가능.</li>
</ul>
<hr/>
</details>
<details>
<summary><h2 id="2일차--시간표scheduletable-및-래퍼scheduletables-최적화"><a aria-hidden="true" tabindex="-1" href="#2일차--시간표scheduletable-및-래퍼scheduletables-최적화"><span class="icon icon-link"></span></a>2일차 : 시간표(ScheduleTable) 및 래퍼(ScheduleTables) 최적화</h2></summary>
<h2 id="성능-개선-컴포넌트-리렌더링-방어-및-메모이제이션"><a aria-hidden="true" tabindex="-1" href="#성능-개선-컴포넌트-리렌더링-방어-및-메모이제이션"><span class="icon icon-link"></span></a>성능 개선: 컴포넌트 리렌더링 방어 및 메모이제이션</h2>
<h3 id="1-문제-분석-9"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-9"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>연쇄적인 렌더링:</strong> 최상위 컴포넌트의 상태가 변경되어 모달이 열릴 때, 데이터 변경과 무관한 하위의 모든 시간표 컴포넌트와 강의 블록이 강제로 다시 그려짐.</li>
<li><strong>참조 불안정성:</strong> 이벤트 핸들러 함수가 렌더링마다 새로 생성되어 자식 컴포넌트는 속성이 변경된 것으로 인식함.</li>
<li><strong>영향:</strong> 단순한 모달 오픈 동작에도 수십 개의 컴포넌트가 다시 그려지며 UI 반응 속도 저하를 유발함.</li>
</ul>
<h3 id="2-코드-변경-사항-9"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-9"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 핸들러가 매번 새로 생성되고, 자식 컴포넌트에 방어막이 없음.</p>
<p><strong>변경 후</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// 1. 핸들러 참조 고정</span>
</span><span class="code-line"><span class="token keyword">const</span> handleScheduleTimeClick <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 렌더링 방어막 구축 (값이 같으면 렌더링 건너뜀)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">DraggableSchedule</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token spread operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
</span><span class="code-line">  <span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> prev<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">===</span> next<span class="token punctuation">.</span><span class="token property-access">data</span> <span class="token operator">&amp;&amp;</span> prev<span class="token punctuation">.</span><span class="token property-access">bg</span> <span class="token operator">===</span> next<span class="token punctuation">.</span><span class="token property-access">bg</span>
</span><span class="code-line"><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 1. 핸들러 참조 고정
const handleScheduleTimeClick = useCallback((...) =&gt; { ... }, []);

// 2. 렌더링 방어막 구축 (값이 같으면 렌더링 건너뜀)
const DraggableSchedule = memo(({ ... }) =&gt; { ... },
  (prev, next) =&gt; prev.data === next.data &amp;&amp; prev.bg === next.bg
);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-개선-방안-3"><a aria-hidden="true" tabindex="-1" href="#3-개선-방안-3"><span class="icon icon-link"></span></a>3. 개선 방안</h3>
<ul>
<li><strong>핸들러 메모이제이션:</strong> <code>useCallback</code>을 사용하여 함수의 참조를 고정, 불필요한 변경 감지를 차단.</li>
<li><strong>컴포넌트 메모이제이션:</strong> <code>React.memo</code>를 사용하여 부모의 렌더링이 자식에게 전파되는 것을 차단.</li>
<li><strong>커스텀 비교 함수:</strong> 데이터와 스타일 등 핵심 속성만 비교하는 로직을 적용하여 불필요한 렌더링을 더욱 정밀하게 방지.</li>
</ul>
<h3 id="4-개선-근거-9"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-9"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>비교 연산 최적화:</strong> 리액트에서 속성 비교 비용이 컴포넌트 실행 비용보다 훨씬 저렴하다는 점을 활용.</li>
<li><strong>참조 무결성:</strong> 객체와 함수의 얕은 비교 메커니즘을 이용하여 렌더링 트리의 불필요한 부분을 제거.</li>
<li><strong>선택적 렌더링:</strong> 실제로 변경된 데이터만 렌더링하여 불필요한 연산을 원천 차단.</li>
</ul>
<h3 id="5-예상-효과-9"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-9"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li>모달 오픈 시 시간표 컴포넌트들의 불필요한 리렌더링 횟수 0회로 감소.</li>
<li>렌더링 차단 해소로 모달 애니메이션 및 반응성 즉각 개선.</li>
</ul>
<hr/>
<h2 id="성능-개선-드래그-앤-드롭-렌더링-격리-및-배경-최적화"><a aria-hidden="true" tabindex="-1" href="#성능-개선-드래그-앤-드롭-렌더링-격리-및-배경-최적화"><span class="icon icon-link"></span></a>성능 개선: 드래그 앤 드롭 렌더링 격리 및 배경 최적화</h2>
<h3 id="1-문제-분석-10"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-10"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>전역 상태로 인한 과도한 리렌더링:</strong> 드래그 상태 관리자가 최상위에 위치하여, 특정 테이블에서 드래그가 시작되면 모든 테이블이 불필요하게 다시 그려짐.</li>
<li><strong>정적 요소의 반복 연산:</strong> 드래그 중이거나 데이터가 변경될 때, 변하지 않는 배경 그리드(요일/시간 칸) 수백 개가 매번 다시 그려짐.</li>
<li><strong>성능 저하:</strong> 드래그 시 화면 끊김 현상이 발생하고 반응성이 떨어짐.</li>
</ul>
<h3 id="2-코드-변경-사항-10"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-10"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 전역 상태 관리 및 통합된 그리드 구조.
<img width="750" height="900" alt="image" src="https://github.com/user-attachments/assets/e357db7d-12ed-4bf8-b02c-5c36d59a8d30"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// App.tsx</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ScheduleDndProvider</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> </span><span class="token punctuation">{</span><span class="token comment">/* 전역에서 관리 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">ScheduleTables</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">ScheduleDndProvider</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// ScheduleTable.tsx</span>
</span><span class="code-line"><span class="token comment">// 배경과 컨텐츠가 결합되어 있어 함께 리렌더링됨</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">ScheduleTable</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> schedules <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> dndContext <span class="token operator">=</span> <span class="token function">useDndContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 전역 컨텍스트 구독</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Grid</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token punctuation">{</span><span class="token comment">/* 배경 그리기 (매번 실행) */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token punctuation">{</span><span class="token constant">DAY_LABELS</span><span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text"> 
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token punctuation">{</span><span class="token comment">/* 강의 그리기 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">      </span><span class="token punctuation">{</span>schedules<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Grid</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// App.tsx
&lt;ScheduleDndProvider&gt; {/* 전역에서 관리 */}
  &lt;ScheduleTables /&gt;
&lt;/ScheduleDndProvider&gt;

// ScheduleTable.tsx
// 배경과 컨텐츠가 결합되어 있어 함께 리렌더링됨
const ScheduleTable = memo(({ schedules }) =&gt; {
  const dndContext = useDndContext(); // 전역 컨텍스트 구독
  return (
    &lt;Grid&gt;
      {/* 배경 그리기 (매번 실행) */}
      {DAY_LABELS.map(...)} 
      {/* 강의 그리기 */}
      {schedules.map(...)}
    &lt;/Grid&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후:</strong> 개별 상태 관리 및 컴포넌트 분리.
<img width="750" height="900" alt="image" src="https://github.com/user-attachments/assets/112484bc-10c8-4f77-bdfd-4af9096bbb9a"/></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// App.tsx</span>
</span><span class="code-line"><span class="token comment">// &lt;ScheduleDndProvider&gt; 제거 (각 테이블이 독립적으로 관리)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// ScheduleTable.tsx</span>
</span><span class="code-line"><span class="token comment">// 1. 정적 배경 분리 (메모이제이션)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token maybe-class-name">GridBackground</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token comment">/* 배경 렌더링 */</span><span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 2. 개별 상태 관리 적용</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token maybe-class-name">ScheduleTable</span> <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>
</span><span class="code-line">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">DndContext</span></span> <span class="token attr-name">...</span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> </span><span class="token punctuation">{</span><span class="token comment">/* 이 테이블만의 독립된 드래그 컨텍스트 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">       </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">GridBackground</span></span> <span class="token punctuation">/&gt;</span></span><span class="token plain-text"> </span><span class="token punctuation">{</span><span class="token comment">/* 배경은 렌더링 생략 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">       </span><span class="token punctuation">{</span>lectures<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token spread operator">...</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token plain-text"> </span><span class="token punctuation">{</span><span class="token comment">/* 강의만 렌더링 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">DndContext</span></span><span class="token punctuation">&gt;</span></span>
</span><span class="code-line">  <span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// App.tsx
// &lt;ScheduleDndProvider&gt; 제거 (각 테이블이 독립적으로 관리)

// ScheduleTable.tsx
// 1. 정적 배경 분리 (메모이제이션)
const GridBackground = memo(() =&gt; &lt;&gt;{/* 배경 렌더링 */}&lt;/&gt;);

// 2. 개별 상태 관리 적용
export const ScheduleTable = memo(() =&gt; {
  return (
    &lt;DndContext ...&gt; {/* 이 테이블만의 독립된 드래그 컨텍스트 */}
       &lt;GridBackground /&gt; {/* 배경은 렌더링 생략 */}
       {lectures.map(...)} {/* 강의만 렌더링 */}
    &lt;/DndContext&gt;
  );
});
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-개선-방안-4"><a aria-hidden="true" tabindex="-1" href="#3-개선-방안-4"><span class="icon icon-link"></span></a>3. 개선 방안</h3>
<ul>
<li><strong>렌더링 격리:</strong> 드래그 상태 관리자를 각 테이블 내부로 이동시켜, 이벤트가 다른 테이블로 전파되지 않도록 구조 변경.</li>
<li><strong>관심사의 분리:</strong> 변하지 않는 배경과 변하는 강의 데이터를 분리하여 관리.</li>
<li><strong>엄격한 타입 정의:</strong> 이벤트 핸들러에 정확한 타입을 명시하여 안정성 확보.</li>
</ul>
<h3 id="4-개선-근거-10"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-10"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>상태 배치 원칙:</strong> 테이블 간 이동이 없는 로직 상, 상태를 전역에 둘 이유가 없음. 데이터를 사용하는 곳에 상태를 위치시켜 렌더링 범위를 최소화.</li>
<li><strong>렌더링 최적화:</strong> 요소가 많은 배경 그리드는 그리기 비용이 높으므로, <code>React.memo</code>를 통해 재사용되도록 강제함.</li>
</ul>
<h3 id="5-예상-효과-10"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-10"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li><strong>테이블 간 불필요한 렌더링 제거:</strong> 하나의 테이블을 조작할 때 다른 테이블은 영향을 받지 않음.</li>
<li><strong>배경 렌더링 제거:</strong> 데이터가 변경되어도 배경 그리드는 다시 그려지지 않음.</li>
<li><strong>프레임 향상:</strong> 드래그 시 메인 스레드 부하가 감소하여 부드러운 움직임 제공.</li>
</ul>
<hr/>
</details>
<details>
<summary><h2 id="3일차--접근성-최적화"><a aria-hidden="true" tabindex="-1" href="#3일차--접근성-최적화"><span class="icon icon-link"></span></a>3일차 : 접근성 최적화</h2></summary>
<h2 id="접근성-개선-메인-랜드마크-설정-적용"><a aria-hidden="true" tabindex="-1" href="#접근성-개선-메인-랜드마크-설정-적용"><span class="icon icon-link"></span></a>접근성 개선: 메인 랜드마크 설정 적용</h2>
<h3 id="1-문제-분석-11"><a aria-hidden="true" tabindex="-1" href="#1-문제-분석-11"><span class="icon icon-link"></span></a>1. 문제 분석</h3>
<ul>
<li><strong>접근성 경고 발생:</strong> 진단 도구에서 문서에 주요 랜드마크가 없다는 경고가 지속적으로 발생.</li>
<li><strong>탐색성 저하:</strong> 페이지의 핵심 콘텐츠 영역이 모두 의미 없는 태그로 구성되어 있어, 스크린 리더 사용자가 본문 영역을 식별하거나 바로 이동하기 어려움.</li>
<li><strong>구조적 의미 부재:</strong> 문서 구조상 주요 콘텐츠 영역이 명확히 정의되지 않음.</li>
</ul>
<h3 id="2-코드-변경-사항-11"><a aria-hidden="true" tabindex="-1" href="#2-코드-변경-사항-11"><span class="icon icon-link"></span></a>2. 코드 변경 사항</h3>
<p><strong>변경 전:</strong> 기본 태그인 <code>div</code>로 렌더링됨.</p>
<p><strong>변경 후</strong></p>
<pre class="language-tsx"><code class="language-tsx code-highlight"><span class="code-line"><span class="token comment">// as props를 활용하여 실제 태그를 main으로 변경</span>
</span><span class="code-line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Flex</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>main<span class="token punctuation">&quot;</span></span> <span class="token attr-name">...</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text">  </span><span class="token punctuation">{</span><span class="token comment">/* 시간표 목록 */</span><span class="token punctuation">}</span><span class="token plain-text">
</span></span><span class="code-line"><span class="token plain-text"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token class-name">Flex</span></span><span class="token punctuation">&gt;</span></span>
</span></code><div class="copied" data-code="// as props를 활용하여 실제 태그를 main으로 변경
&lt;Flex as=&quot;main&quot; ...&gt;
  {/* 시간표 목록 */}
&lt;/Flex&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="3-해결-방안-6"><a aria-hidden="true" tabindex="-1" href="#3-해결-방안-6"><span class="icon icon-link"></span></a>3. 해결 방안</h3>
<ul>
<li><strong>시맨틱 마크업 적용:</strong> 스타일 컴포넌트의 속성을 활용하여 실제 문서 구조를 의미론적으로 개선.</li>
<li><strong>메인 랜드마크 명시:</strong> 시간표 목록 영역을 페이지의 주요 콘텐츠로 정의하고 <code>main</code> 태그를 적용.</li>
<li><strong>버튼 명도대비 고대비로 변경:</strong> 기존의 green 컬러의 경우 kwcag 기준에서는 최소 권장사항에 부합하지만, wcag기준으로는 미흡하여 3.5:1 -&gt; 10.5:1 고대비 색상으로 변경</li>
</ul>
<h3 id="4-개선-근거-11"><a aria-hidden="true" tabindex="-1" href="#4-개선-근거-11"><span class="icon icon-link"></span></a>4. 개선 근거</h3>
<ul>
<li><strong>웹 표준 준수:</strong> 웹 접근성 지침에 따라 페이지의 핵심 콘텐츠는 <code>main</code> 랜드마크 내에 포함되어야 함.</li>
<li><strong>보조 기술 지원:</strong> 스크린 리더 사용자가 랜드마크 이동 기능을 통해 본문으로 빠르게 접근할 수 있도록 지원.</li>
<li><strong>의미 기반 구조:</strong> 단순한 스타일 컨테이너가 아닌, 역할이 명확한 태그 사용으로 문서의 의미 전달력 강화.</li>
</ul>
<h3 id="5-예상-효과-11"><a aria-hidden="true" tabindex="-1" href="#5-예상-효과-11"><span class="icon icon-link"></span></a>5. 예상 효과</h3>
<ul>
<li><strong>접근성 점수 개선:</strong> 주요 랜드마크 부재 경고 제거.</li>
<li><strong>사용자 경험 향상:</strong> 스크린 리더 사용자의 본문 탐색 시간 단축 및 이해도 향상.</li>
<li><strong>접근성 기준 충족:</strong> 모든 사용자에게 동등한 콘텐츠 탐색 경험 제공.</li>
</ul>
<hr/>
</details>
<h3 id="성능-지표-비교-테이블"><a class="anchor" aria-hidden="true" tabindex="-1" href="#성능-지표-비교-테이블"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>성능 지표 비교 테이블</h3>



































<table><thead><tr><th>구분</th><th>최적화 전</th><th>최적화 후</th></tr></thead><tbody><tr><td>측정 시점</td><td>최적화 적용 이전</td><td>최적화 적용 이후</td></tr><tr><td>측정 도구</td><td>Lighthouse</td><td>Lighthouse</td></tr><tr><td>측정 대상</td><td>검색 / 필터링 포함 페이지</td><td>검색 / 필터링 포함 페이지</td></tr><tr><td>특징</td><td>초기 렌더링 및 인터랙션 지연 발생</td><td>렌더링 및 입력 반응성 개선</td></tr><tr><td>정량 지표</td><td>아래 측정 스크린샷 참조</td><td>아래 측정 스크린샷 참조</td></tr></tbody></table>
<blockquote>
<p>모든 성능 평가는  Dev tools Lighthouse 측정 결과를 근거로 함</p>
</blockquote>
<hr/>
<h3 id="lighthouse-측정-결과-before--after"><a class="anchor" aria-hidden="true" tabindex="-1" href="#lighthouse-측정-결과-before--after"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lighthouse 측정 결과 (Before / After)</h3>













<table><thead><tr><th>최적화 전</th><th>최적화 후</th></tr></thead><tbody><tr><td><img src="https://github.com/user-attachments/assets/cbf711b0-204e-4de7-bd75-d1fb114e5606" alt="최적화 전 Lighthouse 결과"/></td><td><img src="https://github.com/user-attachments/assets/d6908b52-b295-4744-922e-77394234a723" alt="최적화 후 Lighthouse 결과"/></td></tr></tbody></table>
<details>
<summary><h2 id="트레이드-오프"><a aria-hidden="true" tabindex="-1" href="#트레이드-오프"><span class="icon icon-link"></span></a>트레이드 오프</h2></summary>
<p>이번 과제를 진행하며 필수적인 성능 개선은 마쳤지만, <strong>&quot;데이터가 지금보다 100배 더 많아진다면 어떻게 될까?&quot;</strong> 라는 궁금증이 생겼습니다. 그래서 더 깊은 최적화 방법들을 찾아보았고, 비록 지금 당장 적용하지는 않았지만 앞으로 꼭 도전해보고 싶은 기술들을 정리했습니다.</p>
<h3 id="1-웹-워커-web-worker-연산을-다른-곳에서-처리하기"><a aria-hidden="true" tabindex="-1" href="#1-웹-워커-web-worker-연산을-다른-곳에서-처리하기"><span class="icon icon-link"></span></a>1. 웹 워커 (Web Worker): 연산을 다른 곳에서 처리하기</h3>
<ul>
<li>
<p><strong>고민의 시작:</strong> &quot;필터링해야 할 강의가 수십만 개라면, 아무리 계산을 효율적으로 해도 화면이 잠깐 멈추지 않을까?&quot;라는 걱정이 들었습니다. 메인 화면이 멈추지 않도록 계산 작업만 따로 수행하는 <strong>웹 워커</strong> 기술을 검토했습니다.</p>
</li>
<li>
<p><strong>비유 및 트레이드오프:</strong></p>
</li>
<li>
<p>이는 마치 혼자서 요리(화면 렌더링)와 서빙을 다 하던 셰프가, 산더미처럼 쌓인 양파 까기(데이터 계산)를 해야 하는 상황과 같습니다. 셰프가 직접 양파를 까면 손님 응대를 멈춰야 합니다.</p>
</li>
<li>
<p>그래서 <strong>&#x27;주방 보조(웹 워커)&#x27;</strong> 를 고용하면 셰프는 요리에만 집중할 수 있습니다. 하지만 보조에게 업무를 지시하고 재료를 건네주는 소통 비용이 발생합니다. 현재는 까야 할 양파(데이터)가 많지 않아서, 셰프가 직접 후딱 처리하는 것이 보조를 부르는 것보다 더 효율적이라 판단했습니다.</p>
</li>
<li>
<p><strong>앞으로의 계획:</strong> 나중에 다뤄야 할 데이터가 엄청나게 많아지거나 계산이 매우 복잡해지면, 웹 워커를 도입하여 사용자가 절대 끊김을 느끼지 못하는 환경을 만들어보고 싶습니다.</p>
</li>
</ul>
<h3 id="2-목록-가상화-virtualization-보이는-것만-그리기"><a aria-hidden="true" tabindex="-1" href="#2-목록-가상화-virtualization-보이는-것만-그리기"><span class="icon icon-link"></span></a>2. 목록 가상화 (Virtualization): 보이는 것만 그리기</h3>
<ul>
<li>
<p><strong>고민의 시작:</strong> 무한 스크롤로 데이터를 계속 불러오면, 화면에 보이지 않는 요소들까지 계속 쌓여서 메모리를 많이 차지하는 문제가 보였습니다. 이를 해결하기 위해 <strong>화면에 보이는 10~20개만 실제로 그려주는 기술</strong> 을 찾아보았습니다.</p>
</li>
<li>
<p><strong>비유 및 트레이드오프:</strong></p>
</li>
<li>
<p>마트에 있는 상품 1만 개를 전부 진열대에 꺼내놓는 대신, <strong>&#x27;손님이 지금 보고 있는 칸에만 물건을 채워 넣는 방식&#x27;</strong> 입니다.</p>
</li>
<li>
<p>이렇게 하면 진열대(메모리)는 가볍고 쾌적해지지만, 안내원(스크린 리더)이나 물건 찾기(Ctrl+F) 기능이 전체 물건을 훑어볼 수 없다는 치명적인 단점이 생깁니다. 진열대에 꺼내져 있지 않은 물건은 &quot;없다&quot;고 인식하기 때문입니다. 이번 프로젝트에서는 속도보다 <strong>&#x27;누구나 물건을 찾을 수 있는 접근성&#x27;</strong> 이 더 중요하다고 판단하여 적용을 보류했습니다.</p>
</li>
<li>
<p><strong>앞으로의 계획:</strong> 접근성을 해치지 않으면서도 화면 요소를 효율적으로 관리할 수 있는 방법을 더 깊이 연구해서, 성능과 접근성 두 마리 토끼를 모두 잡는 목록을 구현해보고 싶습니다.</p>
</li>
</ul>
<hr/>
</details>
<details>
<summary><h2 id="크리스마스--오버엔지니어링"><a aria-hidden="true" tabindex="-1" href="#크리스마스--오버엔지니어링"><span class="icon icon-link"></span></a>크리스마스 : 오버엔지니어링</h2></summary>
<h2 id="코드-가독성-개선-호이스팅을-활용한-구조-변경"><a aria-hidden="true" tabindex="-1" href="#코드-가독성-개선-호이스팅을-활용한-구조-변경"><span class="icon icon-link"></span></a>코드 가독성 개선: 호이스팅을 활용한 구조 변경</h2>
<h3 id="개요"><a aria-hidden="true" tabindex="-1" href="#개요"><span class="icon icon-link"></span></a>개요</h3>
<p>핵심 목표는 <strong>중요한 로직을 파일의 최상단에 배치하는 것</strong> 입니다.</p>
<p>기존 코드에서는 헬퍼 함수들이 메인 로직보다 위에 작성되어 있어, 코드를 읽을 때 세부 구현 사항부터 마주해야 하는 흐름이었습니다. 자바스크립트의 <strong>호이스팅</strong> 특성을 활용하여 메인 비즈니스 로직을 최상단으로 올리고, 세부 구현 함수들은 하단으로 배치하여 가독성을 높였습니다.</p>
<h3 id="변경-이유"><a aria-hidden="true" tabindex="-1" href="#변경-이유"><span class="icon icon-link"></span></a>변경 이유</h3>
<p><strong>1. 위에서 아래로 읽히는 자연스러운 흐름</strong>
신문 기사를 읽을 때 헤드라인과 핵심 내용을 먼저 보고 세부 사항을 나중에 읽는 것처럼, 코드도 핵심 로직이 먼저 보여야 합니다.</p>
<ul>
<li><strong>기존:</strong> <code>fill2</code>, <code>parseHnM</code> 등 보조 함수가 먼저 등장하여 메인 로직인 <code>parseSchedule</code>을 찾기 위해 스크롤을 내려야 했습니다.</li>
<li><strong>변경 후:</strong> <code>parseSchedule</code> 함수가 가장 먼저 등장하여 코드의 목적을 바로 파악할 수 있습니다.</li>
</ul>
<p><strong>2. 헬퍼 함수의 위치 재조정</strong>
<code>getTimeRange</code>나 정규식 생성 같은 기능은 메인 로직을 돕는 보조 역할을 합니다. 이러한 세부 구현 내용을 하단으로 이동시켜, 코드를 읽는 사람이 흐름을 방해받지 않도록 개선했습니다.</p>
<h3 id="핵심-개념-호이스팅"><a aria-hidden="true" tabindex="-1" href="#핵심-개념-호이스팅"><span class="icon icon-link"></span></a>핵심 개념: 호이스팅</h3>
<p>이러한 구조 변경을 가능하게 한 것은 자바스크립트의 <strong>호이스팅</strong> 기능입니다.</p>
<p>호이스팅이란 자바스크립트 엔진이 코드를 실행하기 전, 변수와 함수의 선언을 메모리에 미리 등록하는 과정을 말합니다. 특히 <code>function</code> 키워드로 선언된 함수는 선언문 자체가 온전하게 끌어올려지므로, <strong>함수가 정의된 위치보다 위에서 호출하는 것이 가능합니다.</strong></p>
<h3 id="변경된-패턴"><a aria-hidden="true" tabindex="-1" href="#변경된-패턴"><span class="icon icon-link"></span></a>변경된 패턴</h3>
<p><strong>1. 화살표 함수에서 함수 선언문으로 변경</strong>
<code>const</code>로 선언된 화살표 함수는 선언 라인에 도달하기 전에는 사용할 수 없습니다. 이를 <code>function</code> 선언문으로 변경하여, 파일 내 어느 위치에서든 자유롭게 호출할 수 있도록 했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 기존: const는 호이스팅 되지만 초기화 전에는 사용 불가 (일시적 사각지대)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">fill2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 변경: function은 선언과 동시에 사용 가능</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">fill2</span><span class="token punctuation">(</span>n<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// 기존: const는 호이스팅 되지만 초기화 전에는 사용 불가 (일시적 사각지대)
const fill2 = (n: number) =&gt; { ... }

// 변경: function은 선언과 동시에 사용 가능
export function fill2(n: number) { ... }

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>2. 정규식 변수의 함수화</strong>
정규식 변수(<code>const reg = ...</code>) 또한 호이스팅의 제약을 받으므로 아래로 내릴 수 없었습니다. 이를 <strong>정규식을 반환하는 함수</strong>로 감싸서 호이스팅이 가능하도록 처리했습니다. 덕분에 지엽적인 정규식 패턴도 메인 로직의 시야에서 분리할 수 있었습니다.</p>
<h3 id="코드-비교"><a aria-hidden="true" tabindex="-1" href="#코드-비교"><span class="icon icon-link"></span></a>코드 비교</h3>
<p><strong>변경 전</strong>
세부 함수들이 먼저 나와서 메인 로직을 한눈에 파악하기 어렵습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">getTimeRange</span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span> <span class="token comment">// 세부 구현</span>
</span><span class="code-line"><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"><span class="token anchor function">^</span><span class="token char-set class-name">.</span><span class="token char-set class-name">.</span><span class="token char-set class-name">.</span></span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token comment">// 세부 변수</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">parseSchedule</span> <span class="token operator">=</span> <span class="token punctuation">(</span>schedule<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 메인 로직</span>
</span><span class="code-line">   <span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="const getTimeRange = (value) =&gt; { ... } // 세부 구현
const reg = /^.../; // 세부 변수

export const parseSchedule = (schedule) =&gt; { // 메인 로직
   // ...
}

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong>
메인 로직이 바로 보이며, 문맥 흐름이 자연스럽습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 메인 로직이 가장 먼저 등장</span>
</span><span class="code-line"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">parseSchedule</span><span class="token punctuation">(</span>schedule<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token function">getScheduleRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 아래에 있는 함수를 위에서 호출 (호이스팅)</span>
</span><span class="code-line">  <span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">getTimeRange</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// ...</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 세부 구현 내용은 아래로 이동</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">getScheduleRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex"><span class="token anchor function">^</span><span class="token char-set class-name">.</span><span class="token char-set class-name">.</span><span class="token char-set class-name">.</span></span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">getTimeRange</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// 메인 로직이 가장 먼저 등장
export function parseSchedule(schedule: string) {
  const reg = getScheduleRegex(); // 아래에 있는 함수를 위에서 호출 (호이스팅)
  const range = getTimeRange(...);
  // ...
}

// 세부 구현 내용은 아래로 이동
function getScheduleRegex() { return /^.../; }
function getTimeRange(value) { ... }

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="오버엔지니어링-후기"><a aria-hidden="true" tabindex="-1" href="#오버엔지니어링-후기"><span class="icon icon-link"></span></a>오버엔지니어링 후기</h3>
<p>이 코드는 자바스크립트 엔진이 코드를 해석하고 메모리에 올리는 동작 원리를 활용한 패턴입니다.
함수가 정의되기 전에 호출되는 것처럼 보여 낯설 수 있지만, 이 패턴을 통해 <strong>중요한 것을 먼저 보여주는 방식</strong> 지양해야 할 호스팅을 활용하여 엔진 실행 흐름 + 개발자 인지 흐름을 일치시킬 수 있게 됐습니다.</p>
<hr/>
<h2 id="2-성능-최적화-context-직렬화-연산-개선"><a aria-hidden="true" tabindex="-1" href="#2-성능-최적화-context-직렬화-연산-개선"><span class="icon icon-link"></span></a>2. 성능 최적화: Context 직렬화 연산 개선</h2>
<h3 id="개요-1"><a aria-hidden="true" tabindex="-1" href="#개요-1"><span class="icon icon-link"></span></a>개요</h3>
<p>핵심 목표는 <strong>렌더링 경로에서 불필요한 직렬화 연산을 제거하는 것</strong> 입니다.</p>
<p><code>ScheduleContext</code>에서 키 배열의 변경을 감지하기 위해 사용하던 <code>JSON.stringify</code>는 매 렌더링마다 O(N)의 비용을 발생시킵니다. 이를 <code>useRef</code>와 얕은 비교 기법으로 대체하여 성능을 최적화했습니다.</p>
<h3 id="변경-이유-1"><a aria-hidden="true" tabindex="-1" href="#변경-이유-1"><span class="icon icon-link"></span></a>변경 이유</h3>
<p><strong>1. 렌더링 비용 절감</strong>
<code>JSON.stringify</code>는 객체를 문자열로 변환하기 위해 전체를 순회해야 하는 무거운 작업입니다. 단순한 ID 목록 비교를 위해 매번 이 비용을 지불하는 것은 비효율적입니다.</p>
<ul>
<li><strong>기존:</strong> 렌더링마다 수백, 수천 개의 키를 가진 객체를 문자열로 변환.</li>
<li><strong>변경 후:</strong> 문자열 변환 없이 배열의 길이와 요소만 빠르게 비교.</li>
</ul>
<p><strong>2. 안정적인 참조 유지</strong>
불필요한 연산을 제거함과 동시에, 값이 실제로 변경되지 않았을 때는 이전 참조(Reference)를 그대로 유지하여 하위 컴포넌트의 리렌더링을 방지합니다.</p>
<h3 id="핵심-개념-참조-동등성-reference-equality"><a aria-hidden="true" tabindex="-1" href="#핵심-개념-참조-동등성-reference-equality"><span class="icon icon-link"></span></a>핵심 개념: 참조 동등성 (Reference Equality)</h3>
<p>리액트의 리렌더링을 결정하는 핵심은 <strong>&quot;참조가 바뀌었는가?&quot;</strong> 입니다.
우리는 <code>useRef</code>를 사용하여 이전 상태를 메모리에 보존하고, 새로운 데이터와 <strong>직접 비교</strong> 를 수행합니다. 이를 통해 리액트의 의존성 배열 검사가 문자열이 아닌, 우리가 제어한 참조 값을 바라보게 만듭니다.</p>
<h3 id="변경된-패턴-1"><a aria-hidden="true" tabindex="-1" href="#변경된-패턴-1"><span class="icon icon-link"></span></a>변경된 패턴</h3>
<p><strong>usePreservedTableIds 커스텀 훅 도입</strong>
매번 새로운 문자열을 생성하는 대신, 변화가 있을 때만 <code>ref.current</code>를 업데이트하는 훅을 구현했습니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 기존: 매번 O(N) 문자열 생성 비용 발생</span>
</span><span class="code-line"><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> keys<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 변경: O(1) 길이 체크 + O(N) 단순 순회 (문자열 변환보다 훨씬 빠름)</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">usePreservedTableIds</span> <span class="token operator">=</span> <span class="token punctuation">(</span>map<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> idsRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token comment">// ... 길이 및 요소 비교 로직 ...</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>changed<span class="token punctuation">)</span> idsRef<span class="token punctuation">.</span>current <span class="token operator">=</span> newIds<span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">return</span> idsRef<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// 기존: 매번 O(N) 문자열 생성 비용 발생
useMemo(() =&gt; keys, [JSON.stringify(keys)])

// 변경: O(1) 길이 체크 + O(N) 단순 순회 (문자열 변환보다 훨씬 빠름)
const usePreservedTableIds = (map) =&gt; {
  const idsRef = useRef([]);
  // ... 길이 및 요소 비교 로직 ...
  if (changed) idsRef.current = newIds;
  return idsRef.current;
}

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="코드-비교-1"><a aria-hidden="true" tabindex="-1" href="#코드-비교-1"><span class="icon icon-link"></span></a>코드 비교</h3>
<p><strong>변경 전</strong>
편리하지만 비용이 바싼 패턴입니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> tableIds <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>schedulesMap<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
</span><span class="code-line">  <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>schedulesMap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 렌더링마다 O(N) 발생</span>
</span><span class="code-line"><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="const tableIds = useMemo(() =&gt; Object.keys(schedulesMap), [
  JSON.stringify(Object.keys(schedulesMap)) // 렌더링마다 O(N) 발생
]);

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong>
메모리를 직접 제어하여 성능을 극대화한 패턴입니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 내부에서 useRef로 참조를 관리하여 불필요한 연산 차단</span>
</span><span class="code-line"><span class="token keyword">const</span> tableIds <span class="token operator">=</span> <span class="token function">usePreservedTableIds</span><span class="token punctuation">(</span>schedulesMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 의존성 배열에는 참조값만 전달</span>
</span><span class="code-line"><span class="token keyword">const</span> idsValue <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> tableIds <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>tableIds<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// 내부에서 useRef로 참조를 관리하여 불필요한 연산 차단
const tableIds = usePreservedTableIds(schedulesMap);

// 의존성 배열에는 참조값만 전달
const idsValue = useMemo(() =&gt; ({ tableIds }), [tableIds]);

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="오버엔지니어링-후기-1"><a aria-hidden="true" tabindex="-1" href="#오버엔지니어링-후기-1"><span class="icon icon-link"></span></a>오버엔지니어링 후기</h3>
<p>리액트가 제공하는 <code>deps</code> 배열에만 의존하지 않고, 직접 변경 감지 로직을 구현했습니다.</p>
<p>이는 &quot;편리함(JSON.stringify)&quot; 뒤에 숨은 성능 비용을 찾아내고, <strong>자료구조적 접근</strong>으로 해결한 최적화를 시도해봤습니다. 데이터가 늘어날수록 이 최적화의 효과를 많이 볼 수 있을거라고 생각합니다.</p>
<hr/>
<h2 id="3-알고리즘-최적화-비트마스크-연산"><a aria-hidden="true" tabindex="-1" href="#3-알고리즘-최적화-비트마스크-연산"><span class="icon icon-link"></span></a>3. 알고리즘 최적화: 비트마스크 연산</h2>
<h3 id="개요-2"><a aria-hidden="true" tabindex="-1" href="#개요-2"><span class="icon icon-link"></span></a>개요</h3>
<p>핵심 목표는 <strong>검색 필터링 속도를 획기적으로 단축시키는 것</strong> 입니다.</p>
<p>기존에는 배열 메서드(<code>includes</code>, <code>some</code>)를 사용하여 O(N * M)의 비용이 들었으나, 이를 <strong>비트마스크(Bitmask)</strong> 알고리즘으로 대체하여 O(1)의 비트 연산으로 최적화했습니다.</p>
<h3 id="변경-이유-2"><a aria-hidden="true" tabindex="-1" href="#변경-이유-2"><span class="icon icon-link"></span></a>변경 이유</h3>
<p><strong>1. 대량 데이터 처리 속도 향상</strong>
수천 개의 강의 데이터와 복잡한 요일/시간 조건을 비교할 때, 반복문 기반의 탐색은 CPU 사이클을 많이 소모합니다.</p>
<ul>
<li><strong>기존:</strong> 루프를 돌며 배열 안에 값이 있는지 하나하나 확인.</li>
<li><strong>변경 후:</strong> 단 한 번의 비트 연산(<code>&amp;</code>)으로 겹침 여부 즉시 판단.</li>
</ul>
<p><strong>2. 공간과 시간의 트레이드오프</strong>
<code>scheduleMask</code>라는 추가적인 메모리 공간(BigInt)을 사용하여, 실행 시간(Time Complexity)을 극한으로 줄이는 전략을 취했습니다.</p>
<h3 id="핵심-개념-비트마스크-bitmask"><a aria-hidden="true" tabindex="-1" href="#핵심-개념-비트마스크-bitmask"><span class="icon icon-link"></span></a>핵심 개념: 비트마스크 (Bitmask)</h3>
<p>시간표의 요일과 교시를 <strong>이진수 비트</strong> 로 1:1 매핑하는 기법입니다.
예를 들어 <code>월요일 1교시</code>를 <code>0번째 비트</code>, <code>화요일 1교시</code>를 <code>16번째 비트</code>로 설정합니다. 이렇게 하면 복잡한 시간표가 하나의 거대한 정수(<code>BigInt</code>)로 표현됩니다.</p>
<h3 id="변경된-패턴-2"><a aria-hidden="true" tabindex="-1" href="#변경된-패턴-2"><span class="icon icon-link"></span></a>변경된 패턴</h3>
<p><strong>배열 순회 → 비트 연산자 변경</strong></p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 기존: 배열 순회 (느림)</span>
</span><span class="code-line"><span class="token keyword">if</span> <span class="token punctuation">(</span>lectures<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>l <span class="token operator">=&gt;</span> days<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">...</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 변경: 비트 AND 연산 (매우 빠름)</span>
</span><span class="code-line"><span class="token comment">// 두 비트마스크를 AND(&amp;) 연산했을 때 0이 아니면 겹치는 시간이 존재함</span>
</span><span class="code-line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lecture<span class="token punctuation">.</span>scheduleMask <span class="token operator">&amp;</span> searchMask<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0n</span><span class="token punctuation">)</span> <span class="token operator">...</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// 기존: 배열 순회 (느림)
if (lectures.some(l =&gt; days.includes(l.day))) ...

// 변경: 비트 AND 연산 (매우 빠름)
// 두 비트마스크를 AND(&amp;) 연산했을 때 0이 아니면 겹치는 시간이 존재함
if ((lecture.scheduleMask &amp; searchMask) !== 0n) ...

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="코드-비교-2"><a aria-hidden="true" tabindex="-1" href="#코드-비교-2"><span class="icon icon-link"></span></a>코드 비교</h3>
<p><strong>변경 전</strong>
가독성은 좋지만 데이터가 많아지면 느려지는 로직입니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// SearchDialog.tsx</span>
</span><span class="code-line">lectures<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>lecture <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// 중첩 루프 발생</span>
</span><span class="code-line">  <span class="token keyword">return</span> lecture<span class="token punctuation">.</span>schedules<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>s <span class="token operator">=&gt;</span> days<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>day<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// SearchDialog.tsx
lectures.filter(lecture =&gt; {
  // 중첩 루프 발생
  return lecture.schedules.some(s =&gt; days.includes(s.day));
})

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>변경 후</strong>
CPU가 가장 좋아하는 방식의 연산입니다.</p>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// utils.ts (미리 계산)</span>
</span><span class="code-line">lecture<span class="token punctuation">.</span>scheduleMask <span class="token operator">=</span> <span class="token function">getScheduleMask</span><span class="token punctuation">(</span>lecture<span class="token punctuation">.</span>schedule<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// SearchDialog.tsx</span>
</span><span class="code-line">lectures<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>lecture <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// O(1) 비트 연산</span>
</span><span class="code-line">  <span class="token keyword">return</span> <span class="token punctuation">(</span>lecture<span class="token punctuation">.</span>scheduleMask <span class="token operator">&amp;</span> dayMask<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token number">0n</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span><span class="token punctuation">)</span>
</span><span class="code-line">
</span></code><div class="copied" data-code="// utils.ts (미리 계산)
lecture.scheduleMask = getScheduleMask(lecture.schedule);

// SearchDialog.tsx
lectures.filter(lecture =&gt; {
  // O(1) 비트 연산
  return (lecture.scheduleMask &amp; dayMask) !== 0n;
})

"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="오버엔지니어링-후기-2"><a aria-hidden="true" tabindex="-1" href="#오버엔지니어링-후기-2"><span class="icon icon-link"></span></a>오버엔지니어링 후기</h3>
<p>프론트엔드에서 잘 도입하지 않는 <strong>비트마스크</strong> 를 찾아보고 도입했습니다.
<code>BigInt</code>를 활용해 32비트의 한계를 넘어선 비트 공간을 확보하고, 이를 통해 수천 번의 배열 순회를 단 몇 번의 CPU 사이클로 압축했습니다.
비트연산을 통해 더 빠른 계산이 가능하게 됐습니다.</p>
<hr/>
</details>
<details>
<summary><h2 id="-시간없어서-넘어간-거슬리는-이슈"><a aria-hidden="true" tabindex="-1" href="#-시간없어서-넘어간-거슬리는-이슈"><span class="icon icon-link"></span></a>🚧 시간없어서 넘어간 거슬리는 이슈</h2></summary>
<h3 id="1-웹-접근성a11y-경고-form-id-중복-및-라벨-미매칭"><a aria-hidden="true" tabindex="-1" href="#1-웹-접근성a11y-경고-form-id-중복-및-라벨-미매칭"><span class="icon icon-link"></span></a>1. 웹 접근성(A11y) 경고: Form ID 중복 및 라벨 미매칭</h3>
<p>현재 브라우저 콘솔에 다음과 같은 경고가 출력되는 것을 인지하고 있습니다.</p>
<blockquote>
<ol>
<li><code>The label&#x27;s for attribute doesn&#x27;t match any element id</code></li>
<li><code>Multiple form field elements in the same form have the same id attribute value</code></li>
</ol>
</blockquote>
<p><strong>원인</strong></p>
<ul>
<li>반복 렌더링되는 컴포넌트 내부의 <code>input</code> 요소들에 고정된 <code>id</code>가 부여되어 발생한 문제입니다.</li>
<li>이로 인해 스크린 리더 인식 불가 및 자동완성 기능에 제약이 생길 수 있습니다.</li>
</ul>
<p><strong>해결 계획 (To-Do)</strong></p>
<ul>
<li>여행 일정으로 인해 부득이하게 이번 PR에는 수정 사항을 반영하지 못했습니다.</li>
<li><strong>여행 복귀 후</strong>, 리액트의 <strong><code>useId</code> 훅</strong>을 도입하거나 유니크 ID 생성 로직을 적용하여 접근성 문제를 최우선으로 리팩토링 해보려고 합니다.</li>
</ul>
<hr/>
</details>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<h4 id="memo는-만능이-아니다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#memo는-만능이-아니다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>memo는 만능이 아니다</h4>
<ul>
<li>
<p><strong>“memo를 쓴다고 무조건 빨라지는 건 아니구나”</strong>
처음에는 <code>React.memo</code>만 감싸면 렌더링이 최적화될 줄 알았습니다.
하지만 프로파일러로 확인해 보니 여전히 리렌더링이 발생하고 있었고,
그 원인이 <strong>참조값(Reference)이 매번 바뀌기 때문</strong>이라는 사실을 알게 되었습니다.</p>
<p>이 과정을 통해 <code>useCallback</code>과 <code>useMemo</code>는 단순한 문법이 아니라,
불필요한 리렌더링을 막기 위한 <strong>렌더링 방어막</strong>이라는 점을 깊이 이해하게 되었습니다.</p>
</li>
</ul>
<hr/>
<h4 id="메인-스레드를-쉬게-해주기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#메인-스레드를-쉬게-해주기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>메인 스레드를 쉬게 해주기</h4>
<ul>
<li>
<p><strong>“메인 스레드를 블로킹하지 않아야 사용자는 렉을 느끼지 않는다”</strong>
이전에는 코드가 순서대로 실행되는 것만을 고려했지만,
이번 작업을 통해 메인 스레드 점유 여부가 체감 성능에 직접적인 영향을 준다는 사실을 배웠습니다.</p>
<p>API를 병렬(<code>Promise.all</code>)로 호출하고,
무거운 데이터 가공을 렌더링 중이 아닌 <strong>데이터 로딩 시점</strong> 에 미리 처리하는
전처리(Pre-calculation) 방식으로 변경하자 체감 속도가 확연히 개선되는 경험을 했습니다.</p>
</li>
</ul>
<hr/>
<h4 id="리액트와-dom의-타이밍-맞추기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리액트와-dom의-타이밍-맞추기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리액트와 DOM의 타이밍 맞추기</h4>
<ul>
<li>
<p><strong>“리액트 상태와 실제 DOM 생성 시점은 다를 수 있다”</strong>
무한 스크롤 구현 과정에서 <code>useRef</code>에 값이 할당되어도 리렌더링이 발생하지 않아
<code>IntersectionObserver</code>가 연결되지 않는 버그를 경험했습니다.</p>
<p>이를 통해 DOM이 실제로 마운트되는 타이밍과
리액트의 상태 업데이트 타이밍이 다를 수 있다는 점을 이해하게 되었고,
<strong>Callback Ref 패턴</strong>을 사용해 해당 문제를 안정적으로 해결할 수 있었습니다.</p>
</li>
</ul>
<hr/>
<h3 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h3>
<h4 id="코드가-읽기-좋아야-성능도-잡힌다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드가-읽기-좋아야-성능도-잡힌다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드가 읽기 좋아야 성능도 잡힌다</h4>
<ul>
<li>
<p><strong>“구조가 곧 성능이다”</strong>
<code>ScheduleTable</code> 컴포넌트가 지나치게 비대해져 수정이 어려운 상태였습니다.
이를 <strong>변하지 않는 배경(GridBackground)</strong> 과
<strong>자주 변하는 강의(Schedule)</strong> 컴포넌트로 분리하면서
코드 가독성과 렌더링 성능이 동시에 개선되는 경험을 했습니다.</p>
<p>이 과정을 통해 <strong>관심사 분리와 구조 설계가 곧 성능 최적화로 이어진다</strong> 는 점을 체감했습니다.</p>
</li>
</ul>
<hr/>
<h4 id="상태는-필요한-곳에만-두기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#상태는-필요한-곳에만-두기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>상태는 필요한 곳에만 두기</h4>
<ul>
<li>
<p><strong>“전역 상태는 편하지만, 공짜는 아니다”</strong>
처음에는 <code>DndContext</code>를 최상위에 두었지만,
드래그 이벤트 발생 시 모든 테이블이 리렌더링되는 문제가 있었습니다.</p>
<p>이를 각 테이블 내부로 이동해 상태를 <strong>격리</strong> 하자
불필요한 렌더링이 제거되었고 체감 성능도 즉시 개선되었습니다.</p>
<p>이를 통해 <strong>상태는 사용하는 가장 가까운 위치에 둬야 한다</strong> 는 원칙을 명확히 이해하게 되었습니다.</p>
</li>
</ul>
<hr/>
<h4 id="복잡한-조건문-정리하기"><a class="anchor" aria-hidden="true" tabindex="-1" href="#복잡한-조건문-정리하기"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>복잡한 조건문 정리하기</h4>
<ul>
<li>
<p><strong>“읽기 쉬운 코드가 결국 빠르다”</strong>
검색 필터링 로직이 여러 <code>&amp;&amp;</code> 조건으로 길게 연결되어 있어
가독성과 디버깅이 모두 어려운 상태였습니다.</p>
<p>이를 <code>if (!조건) return false</code> 형태의
<strong>Guard Clause 패턴</strong>으로 변경하니
코드 흐름이 명확해지고, 조건 불일치 시 조기 종료되어
연산 비용까지 자연스럽게 줄일 수 있었습니다.</p>
</li>
</ul>
<hr/>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<h4 id="기술-선택에는-항상-트레이드오프가-따른다"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술-선택에는-항상-트레이드오프가-따른다"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술 선택에는 항상 트레이드오프가 따른다</h4>
<ul>
<li>
<p><strong>“좋은 기술도 상황에 맞지 않으면 독이 된다”</strong>
가상화는 성능 면에서는 강력하지만,
스크린 리더가 콘텐츠를 읽지 못해 <strong>접근성을 해친다</strong>는 문제를 직접 확인했습니다.</p>
<p>이를 통해 무조건 최신 기술을 도입하는 것이 정답이 아니라,
<strong>서비스의 핵심 가치와 사용자 경험을 먼저 고려해야 한다</strong>는 점을 배웠습니다.</p>
</li>
</ul>
<hr/>
<h4 id="실무-적용에-대한-자신감"><a class="anchor" aria-hidden="true" tabindex="-1" href="#실무-적용에-대한-자신감"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>실무 적용에 대한 자신감</h4>
<ul>
<li><strong>“지금 당장 실무에 써먹을 수 있는 최적화들”</strong>
API 병렬 호출, 렌더링 경계 분리, 메모이제이션 전략 등은
실제 프로젝트에서도 즉각적인 성능 개선 효과를 낼 수 있는 방법이라는 확신이 들었습니다.</li>
</ul>
<hr/>
<h4 id="더-공부해보고-싶은-것들"><a class="anchor" aria-hidden="true" tabindex="-1" href="#더-공부해보고-싶은-것들"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>더 공부해보고 싶은 것들</h4>
<ul>
<li><strong>“다음 단계의 성능 최적화”</strong>
이번에는 트레이드오프 문제로 도입하지 못했지만,
<strong>Web Worker</strong> 패턴은
대규모 데이터 처리 환경에서 꼭 다시 도전해보고 싶은 주제입니다.</li>
</ul>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<!-- -->
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<h4 id="1-react-19react-compiler와-수동-최적화의-미래"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-react-19react-compiler와-수동-최적화의-미래"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. React 19(React Compiler)와 수동 최적화의 미래</h4>
<blockquote>
<p><strong>배경:</strong> 이번 과제에서 <code>useMemo</code>, <code>useCallback</code>을 사용하여 리렌더링을 막는 데 많은 시간을 쏟았습니다.</p>
</blockquote>
<ul>
<li><strong>질문:</strong>
최근 React 19와 <strong>React Compiler(구 React Forget)</strong> 소식을 접했습니다. 컴파일러가 도입되면 자동으로 메모이제이션이 처리되어 개발자가 수동으로 <code>useMemo</code>나 <code>memo</code>를 쓸 일이 없어진다고 하던데요.
<strong>그렇다면 지금 제가 연습한 수동 최적화 기술들은 앞으로 레거시가 되는 걸까요?</strong> 아니면 컴파일러 시대에도 여전히 개발자가 렌더링 파이프라인을 이해하고 수동으로 제어해야 할 영역이 남을까요? 주니어로서 어떤 스탠스를 취해야 할지 궁금합니다.</li>
</ul>
<h4 id="2-실무에서의-최적화와-개발공수의-우선순위"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-실무에서의-최적화와-개발공수의-우선순위"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 실무에서의 &#x27;최적화와 개발공수의 우선순위</h4>
<blockquote>
<p><strong>배경:</strong> 최적화를 하다 보니 욕심이 생겨서 끝도 없이 파고들게 되었습니다.</p>
</blockquote>
<ul>
<li><strong>질문:</strong>
이번에 최적화를 진행하다 보니 1ms라도 더 줄이고 싶어서 밤을 새우게 되더라고요. 하지만 회사에서는 리소스가 한정되어 있으니 마냥 최적화만 할 순 없을 것 같습니다.
코치님께서는 실무에서 성능 개선 작업을 하실 때 <strong>&#x27;이 정도면 충분하다&#x27;라고 판단하고 다음 기능 개발로 넘어가는 정량적/정성적 기준</strong>이 있으신가요? (예: Lighthouse 점수 90점, 혹은 하위 10% 기기에서의 프레임 방어 등)</li>
</ul>
<h4 id="3-현업-경험-부재와-심화-과제-경험의-이력서-활용-전략"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-현업-경험-부재와-심화-과제-경험의-이력서-활용-전략"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. 현업 경험 부재와 심화 과제 경험의 이력서 활용 전략</h4>
<blockquote>
<p><strong>배경:</strong> 현재 개발 직무를 떠나 있어 실무에서의 대규모 트래픽 처리나 운영 배포 경험이 부족한 상태입니다. 다시 개발자로 돌아가고 싶은 열망이 크지만, 이력서에 적을 &#x27;실무 트러블슈팅&#x27; 경험이 없어 위축되곤 합니다.</p>
</blockquote>
<ul>
<li><strong>질문:</strong>
이번 항해 과제를 수행하면서 일반적인 최적화(메모이제이션 등) <strong>비트마스크 알고리즘 도입, 렌더링 참조 최적화, 호이스팅 구조 개선</strong> 등 기술적으로 깊이 파고드는 경험을 했습니다.
현업 프로젝트가 아닌 <strong>개인/부트캠프 과제에서 수행한 이러한 기술적 시도와 PR 내용</strong>을 이력서에 메인으로 녹여내도 신입/주니어 지원 시 충분히 경쟁력이 있을까요?
실무 경험이 없는 상태에서 이러한 경험을 어떤 관점으로 어필해야 면접관에게 긍정적인 평가를 받을 수 있을지 조언 부탁드립니다.</li>
</ul>
<hr/>
<p>10주간에 항해의 마지막 과제라고 하니까 크리스마스임에도 과제에 미련이남네요...
양질의 과제와 멘토링을 통해 10주전의 저보다 조금은 나아졌음을  느끼고 코치님들에게 감사합마음이 듭니다.
내년에는 같은 프론트엔드 개발씬에서 개발자로 커리어를 다시 시작할 수 있는 한해면 좋겠네요.</p>
<p>항해 끝!</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>Q. React 19(React Compiler)와 수동 최적화의 미래</p>
<p>A. 리액트가 컴파일러를 통해 최적화 하는것은 예측가능한 범위내의 습관적인 최적화를 반복적으로 하는 것의 피로도를 줄여주는 역할이라고 생각합니다.
물론 여러최적화를 추가로 하고 있을 것이고 앞으로 발전 가능성은 얼마든지 충분히 있어요.
다만 성능 최적화라는 것이 단순하게 어떤 영역에서만 발생하는 것도 아니고 UI는 복잡하기 때문에 성능에 영향을 주는 코드가 리액트가 자동으로 파악하기 힘든 부분도 분명있습니다.
렌더링 파이프라인에 대해서 신경안쓰고 만들 수 있도록 발전은 하겠지만(덜신경쓰게만들수록 좋은 프레임웍이니까요)
성능에 대한 고민은 다양한 부분에서 필요하다고 생각합니다.
렌더링 파이프라인을 알고 리액트를 사용하는 사람과 그렇지 않은 사람은 분명 코드래밸에서 차이가 날 수밖에 없으니까요.
이것은 어떻게보면 AI시대의 우리의 고민과 닿는 부분이 있는 것 같아요.
다만 이렇게 생각해보면 어떨까요?
깊은 이해가 있는 개발자와 없는 개발자.
어떤 개발자가 더 나은 개발자 일까요?
그리고 어차피 아직은 면접볼때 이런 이해에 대한 질문을 많이 하기때문에 아직은 필요합니다. :)</p>
<p>Q. 실무에서의 &#x27;최적화와 개발공수의 우선순위</p>
<p>A. 애초에 고려해야 할 성능은 당연히 고려해야하고,
성능에 민감할 수 있는 코드는 조금 더 성능을 고려해서 개발을 해요.
그렇게하고 배포 이후 성능 이슈가 발견되면 성능 개선 업무로 별도로 진행을 합니다 :)
어느 수준까지라고 한다면, 일단 할 수 있는 것까진 하고
실제 테스트시 성능에 문제가 없고 더이상 할 것도 안보이면 멈추는 것이죠
다만 테스트시 성능에 문제가 아직도 있다면 해결할때까지 파야죵..
문제가 없다고 판단하는 기준은 유저가 사용했을때 문제가 없는지 쾌적한지가 기준인 것 같아요.
만약 그기준을 룰로 만들고 싶다면,
룰로 정해도 좋을 것 같습니다.
실제로 예를들어 LCP는 어느정도까지 나와야한다 이런 기준이 있는 회사들이 많습니다.
저희 회사도 기준은 있지만 점수보다는 LCP는 몇 ms이하 이런 기준입니다.</p>
<p>Q. 현업 경험 부재와 심화 과제 경험의 이력서 활용 전략</p>
<p>A. 제일 좋은것은 실무의 녹여내서 그것을 이력서에 작성하는 것입니다.
이게 가장 효과적이고요 그외에는 어떻게보면 부족한 성과일수밖에 없을 것 같아요.</p>
<p>깊은 기술적인 이해로 사이드프로젝트를 진행하거나 블로그를 작성할 수 있을 것 같습니다.
물론 둘다하면 더 좋을 것 같아요 :)
경쟁력은 실무에 녹인 것 보단 떨어질 수 있지만 없는 것 보단 나을 수 밖에 없을 것 같아요.
어떤 강력한 한방 보다는 나는 이런 개발자라는 태도의 개념으로 풀어가는게 좋을 것 같습니다.</p>
<p>크리스마스까지 과제하시느라 정말 고생많으셨어요 ㅜㅜ
그동안 배우신 것을 토대로 더나은 커리어 더나은 성과를 만들 수 있길 바라겠습니다.</p>
<p>화이팅!!!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 - 박수범 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 박수범, [5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 - 박수범 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 - 박수범 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 박수범님이 제출한 [5팀 박수범] Chapter 4-2. 코드 관점의 성능 최적화 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-RTTRX4Ru.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
