<link rel="preload" as="image" href="https://github.com/user-attachments/assets/5a374a5f-b1c9-4131-9d97-b620382adbce"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/314efe44-1d11-4f72-ba3b-79bdaa837b1c"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/0f157750-d668-44f3-864e-4bcea45b90a8"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/ea8a951d-21a2-4385-a9dd-ee3db5fd4ea8"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/4e76b081-fd14-48ec-aa31-78a52cd9e008"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/7fe3495f-ca62-481a-b369-d61bc8e797ec"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/daac272e-d54b-4b78-8ac0-a08da0bc51f8"/><link rel="preload" as="image" href="https://github.com/user-attachments/assets/d2fa34fc-bdec-4a55-8b8e-0a017f719c85"/><div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@rlacodud/" data-discover="true">rlacodud<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter3-2/pull/3" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->rlacodud</span><span>2025.11.29</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h2>
<p><a href="https://rlacodud.github.io/front_7th_chapter3-2/index.basic">basic 배포 경로</a>
<a href="https://rlacodud.github.io/front_7th_chapter3-2/index.advanced">advanced 배포 경로</a></p>
<h2 id="과제의-핵심취지"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제의-핵심취지"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제의 핵심취지</h2>
<ul>
<li>React의 hook 이해하기</li>
<li>함수형 프로그래밍에 대한 이해</li>
<li>액션과 순수함수의 분리</li>
</ul>
<h2 id="과제에서-꼭-알아가길-바라는-점"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제에서-꼭-알아가길-바라는-점"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제에서 꼭 알아가길 바라는 점</h2>
<ul>
<li>엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup</li>
<li>엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()</li>
<li>엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등</li>
<li>엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart) vs capaitalize(str)</li>
</ul>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<ul class="contains-task-list">
<li>
<p>Component에서 비즈니스 로직을 분리하기</p>
</li>
<li>
<p>비즈니스 로직에서 특정 엔티티만 다루는 계산을 분리하기</p>
</li>
<li>
<p>뷰데이터와 엔티티데이터의 분리에 대한 이해</p>
</li>
<li>
<p>entities -&gt; features -&gt; UI 계층에 대한 이해</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Component에서 사용되는 Data가 아닌 로직들은 hook으로 옮겨졌나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 주어진 hook의 책임에 맞도록 코드가 분리가 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 계산함수는 순수함수로 작성이 되었나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 함수는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 특정 Entitiy만 다루는 Component와 UI를 다루는 Component는 분리되어 있나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 데이터 흐름에 맞는 계층구조를 이루고 의존성이 맞게 작성이 되었나요?</p>
</li>
</ul>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<ul class="contains-task-list">
<li>
<p>이번 심화과제는 Context나 Jotai를 사용해서 Props drilling을 없애는 것입니다.</p>
</li>
<li>
<p>어떤 props는 남겨야 하는지, 어떤 props는 제거해야 하는지에 대한 기준을 세워보세요.</p>
</li>
<li>
<p>Context나 Jotai를 사용하여 상태를 관리하는 방법을 익히고, 이를 통해 컴포넌트 간의 데이터 전달을 효율적으로 처리할 수 있습니다.</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> Context나 Jotai를 사용해서 전역상태관리를 구축했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전역상태관리를 통해 domain custom hook을 적절하게 리팩토링 했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 도메인 컴포넌트에 도메인 props는 남기고 props drilling을 유발하는 불필요한 props는 잘 제거했나요?</p>
</li>
<li class="task-list-item">
<p><input type="checkbox" disabled="" checked=""/> 전체적으로 분리와 재조립이 더 수월해진 결합도가 낮아진 코드가 되었나요?</p>
</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<!-- -->
<h3 id="과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제를-하면서-내가-알게된-점-좋았던-점은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제를 하면서 내가 알게된 점, 좋았던 점은 무엇인가요?</h3>
<h4 id="1-함수형-프로그래밍functional-programming"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-함수형-프로그래밍functional-programming"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. 함수형 프로그래밍(Functional Programming)</h4>
<p>함수형 프로그래밍은 사실상 프로그래밍 철학에 가까운 개념으로, 한 문장으로 말하자면 아래와 같습니다.</p>
<blockquote>
<p>데이터는 변하지 않으며, 프로그램은 순수 함수들의 조합으로 구성된다.</p>
</blockquote>
<p><strong>(1) 데이터는 변하지 않는다(Immutability)</strong>
객체나 배열의 값을 직접 바꾸는 대신, 기존 데이터를 기반으로 새로운 데이터를 만들어내야 합니다.
그렇게 강조해대는 <strong>불변성</strong>의 개념인데 결국 상태가 언제 바뀌었는지 명확해야 <strong>렌더링 퇴적화</strong>나 <strong>변경 추적</strong>이 가능하기 때문에 강조하는 것입니다.</p>
<p><strong>🧐 왜 그래야 할까요?</strong></p>
<ul>
<li>값이 중간에 바뀌지 않으니 예측 가능성이 높아지고</li>
<li>디버깅이 쉬워지고</li>
<li>동시성 문제(멀티 스레드, 비동기)에서 충돌이 줄어들고</li>
<li>상태를 되돌리거나 시간 여행 디버깅(Time-travel debugging)이 가능해지기 때문입니다.</li>
</ul>
<p><strong>(2) 순수 함수로 구성한다(Pure Function)</strong>
순수 함수가 무엇일까요? 아래만 기억합시다!</p>
<ul>
<li>같은 입력 → 항상 같은 출력</li>
<li>함수 외부 상태를 변경하지 않음</li>
</ul>
<pre class="language-javascript"><code class="language-javascript code-highlight"><span class="code-line"><span class="token keyword">function</span> <span class="token function">pureAdd</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>         <span class="token comment">// 같은 입력 → 같은 결과</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">impureAdd</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token console class-name">console</span><span class="token punctuation">.</span><span class="token method function property-access">log</span><span class="token punctuation">(</span><span class="token string">&quot;실행됨&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 외부 상태 사용 (콘솔)</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="function pureAdd(a, b) {
  return a + b;         // 같은 입력 → 같은 결과
}

function impureAdd(a, b) {
  console.log(&quot;실행됨&quot;); // 외부 상태 사용 (콘솔)
  return a + b;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>근데 저런 util 함수 단계정도면 충족하기 쉽지만 데이터를 다루는 등의 복잡한 로직에서는 그게 어떻게 가능할까요?</p>
<p>FP에서 말하고자 하는 바는 <strong>모든 걸 순수함수로 만들라는 것이 아닙니다.</strong>
<strong>순수함수를 최대화</strong>하고 <strong>부수효과는 의도된 위치에 모아두어</strong> 변경 및 관리가 용이하도록 하면 됩니다.</p>
<p><strong>(3) 함수는 조합 가능한 작은 블록이다(Composition)</strong>
함수형 프로그래밍에서는 큰 문제를 해결하기 위해 함수를 계속 합성(조합)해 나가는 방식을 선호합니다.</p>
<pre class="language-javascript"><code class="language-javascript code-highlight"><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">double</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token arrow operator">=&gt;</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">inc</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token arrow operator">=&gt;</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">const</span> <span class="token function-variable function">process</span> <span class="token operator">=</span> <span class="token parameter">x</span> <span class="token arrow operator">=&gt;</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token function">inc</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token function">process</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span>
</span></code><div class="copied" data-code="const double = x =&gt; x * 2;
const inc = x =&gt; x + 1;

const process = x =&gt; double(inc(x));

process(3); // 8
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이걸 FP에서는 <strong>함수 합성</strong>이라고 하며, 레고 블럭 쌓듯이 작은 단위로 쪼개서 조합하는 걸 의미합니다.</p>
<p>이름에서부터 명령형 프로그래밍은 이렇게 해! 하고 <strong>어떻게(how) 할지</strong>를 설명한다면,
함수형 프로그래밍은 함수가 인자를 받고 결과를 돌려주듯이 어떤 결과를 주기 위해 <strong>무엇(what)을 할지</strong>를 설명합니다.</p>
<pre class="language-javascript"><code class="language-javascript code-highlight"><span class="code-line"><span class="token comment">// 명령형: 어떻게 반복할지 알려줌</span>
</span><span class="code-line"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword control-flow">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> n <span class="token keyword">of</span> numbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  result<span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 선언형: 무엇을 할지 말함</span>
</span><span class="code-line">numbers<span class="token punctuation">.</span><span class="token method function property-access">map</span><span class="token punctuation">(</span><span class="token parameter">n</span> <span class="token arrow operator">=&gt;</span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></code><div class="copied" data-code="// 명령형: 어떻게 반복할지 알려줌
let result = [];
for (let n of numbers) {
  result.push(n * 2);
}

// 선언형: 무엇을 할지 말함
numbers.map(n =&gt; n * 2);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h4 id="2-엔티티entity란"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-엔티티entity란"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. 엔티티(Entity)란?</h4>
<p>폴더 구조나 파일명에서 자주 사용되는 엔티티(Entity)라는 용어가 있는데 정확히 무슨 뜻일까요?</p>
<p>**엔티티(Entity)**는 도메인(비즈니스 로직)의 핵심이 되는 <strong>실제 데이터 객체</strong>를 의미하며,
쉽게 말해 앱이 다루는 “진짜 대상”을 말합니다.</p>
<p>이 엔티티를 기준으로 Component, hook, function을 나눌 수 있습니다.</p>
<ul>
<li>엔티티를 다루는 상태와 그렇지 않은 상태 - cart, isCartFull vs isShowPopup</li>
<li>엔티티를 다루는 컴포넌트와 훅 - CartItemView, useCart(), useProduct()</li>
<li>엔티티를 다루지 않는 컴포넌트와 훅 - Button, useRoute, useEvent 등</li>
<li>엔티티를 다루는 함수와 그렇지 않은 함수 - calculateCartTotal(cart) vs capaitalize(str)</li>
</ul>
<p>왜 Entity를 기준으로 분리를 해야 하는걸까요?
지금 과제를 기준으로 생각해봅시다.</p>
<p>과제는 쇼핑몰 프로젝트이고 해당 프로젝트에서 다뤄지는 개체(data)에는 크게 상품, 쿠폰, 장바구니가 있습니다.
여기서 생각할 수 있는 구조로는 상품 카드, 쿠폰 카드, 장바구니 아이템 카드가 대표적으로 있겠죠.</p>
<p>만약 극단적으로 이 아이템 카드를 하나의 컴포넌트로 렌더하게끔 한다면
한 컴포넌트 내에서 분기를 추가하면서 렌더하게끔 할 것입니다.</p>
<p>그럼 문제 없는 거 아닌가요?🤔
몇개월 뒤 아이템 카드에 새로운 개체인 게시글이 추가되어야 한다고 할 때 컴포넌트 내에 분기를 추가해야 하고
이는 곧 다른 분기에도 영향을 줄 수 있는 <strong>잠재적 위험</strong>이 됩니다.</p>
<p>이를 방지하기 위해서도 우리는 각 개체별로 <strong>다른 관심사를 격리</strong>시키고 <strong>독립적으로 확장</strong>해나갈 수 있도록 보장해줘야 합니다.</p>
<h4 id="3-jotai"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-jotai"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Jotai</h4>
<p>상태 관리 라이브러리로는 Zustand를 사용해봤는데 Jotai는 처음 접해봤습니다. (Jotai 조타..)
Jotai는 React와 유사한 문법 체계를 가지고있어 React에 특화된 상태 관리 라이브러리입니다.</p>
<p>얼마나 비슷하길래..?하고 보면 진짜 거의 그대로 사용하는 급이네요</p>
<pre class="language-javascript"><code class="language-javascript code-highlight"><span class="code-line"><span class="token comment">// 1. React의 useState를 사용한 경우</span>
</span><span class="code-line"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> useState <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">&#x27;react&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line"><span class="token comment">// 2. Jotai의 useAtom을 사용한 경우</span>
</span><span class="code-line"><span class="token keyword module">import</span> <span class="token imports"><span class="token punctuation">{</span> atom<span class="token punctuation">,</span> useAtom <span class="token punctuation">}</span></span> <span class="token keyword module">from</span> <span class="token string">&#x27;jotai&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 컴포넌트 밖에 atom(상태의 단위)을 정의합니다</span>
</span><span class="code-line"><span class="token keyword">const</span> countAtom <span class="token operator">=</span> <span class="token function">atom</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function"><span class="token maybe-class-name">Counter</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token comment">// useState와 사용법이 완전히 동일합니다!</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useAtom</span><span class="token punctuation">(</span>countAtom<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword control-flow">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">c</span> <span class="token arrow operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// 1. React의 useState를 사용한 경우
import { useState } from &#x27;react&#x27;;

function Counter() {
  const [count, setCount] = useState(0);
  return &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;{count}&lt;/button&gt;;
}
// 2. Jotai의 useAtom을 사용한 경우
import { atom, useAtom } from &#x27;jotai&#x27;;

// 컴포넌트 밖에 atom(상태의 단위)을 정의합니다
const countAtom = atom(0);

function Counter() {
  // useState와 사용법이 완전히 동일합니다!
  const [count, setCount] = useAtom(countAtom);
  return &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;{count}&lt;/button&gt;;
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이만큼 유사한 문법 체계를 가지고 있기 때문에 기존 React 프로젝트에서 전역 상태관리를 도입해야 한다면,
러닝커브도 적고 전환 시간을 최소화할 수 있을 것 같습니다.</p>
<hr/>
<h3 id="이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제에서-내가-제일-신경-쓴-부분은-무엇인가요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제에서 내가 제일 신경 쓴 부분은 무엇인가요?</h3>
<h4 id="-과제-진행-과정"><a class="anchor" aria-hidden="true" tabindex="-1" href="#-과제-진행-과정"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>✅ 과제 진행 과정</h4>
<p><strong>(1) 개념 정립</strong>
해당 챕터에서 다루는 디자인 패턴과 함수형 프로그래밍에 대해 이해하고 정리하는 시간을 가졌습니다.</p>
<p><strong>(2) 구조의 시각화</strong>
그리고 프로젝트 구조를 시각화하기로 결심했습니다.</p>
<p>멘토링에서 구조를 시각화하는 연습을 해보라고 하셨던 조언과 더불어 이번 과제의 핵심은 <strong>원래 구조의 문제점을 파악</strong>하고 이를 개선하기 위해 <strong>어떤 패턴</strong>을 적용할지, <strong>어떻게 리팩토링할지를 사고</strong>하는 것이라고 생각했기 때문입니다.</p>
<p><strong>(2-1) 텍스트로 기능 정리</strong>
처음부터 코드를 보면서 모든 기능을 정리하려 하면 복잡할 것 같아서 빌드한 페이지에 직접 액션을 해보며 기능설계서를 역으로 작성했고
혹시 누락하거나 잘못 작성한 부분이 있을까봐 AI에게 검증을 맡겼습니다.</p>
<pre><code class="code-highlight"><span class="code-line"># 쇼핑몰
</span><span class="code-line">- 쇼핑몰에 존재하는 상품 목록이 노출된다.
</span><span class="code-line">    - 재고가 5개 이하면 품절 임박 텍스트가 노출된다.
</span><span class="code-line">    - 할인이 있을 경우 해당 할인 정보를 노출한다.
</span><span class="code-line">    - 재고 소진 시 품절 버튼으로 변경 &amp; 가격 영역이 SOLD OUT으로 변경된다.
</span><span class="code-line">- 검색 input 입력 → 해당 input값을 포함하는 상품들을 반환한다.
</span><span class="code-line">    - 검색어 입력 후 500ms 지연 후 검색이 실행된다. (debounce)
</span><span class="code-line">    - 상품명과 상품 설명 모두에서 검색한다.
</span><span class="code-line">    - 포함하는 상품이 없으면 empty UI를 반환한다.
</span><span class="code-line">    - 빈 값이면 전체 상품 리스트를 반환한다.
</span><span class="code-line">- 장바구니 담기 버튼 클릭 → 장바구니에 해당 상품이 담긴다.
</span><span class="code-line">    - 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">    - 우측에 해당 상품이 적용된다.
</span><span class="code-line">    - 헤더의 장바구니 아이콘 옆에 총 아이템 개수가 배지로 표시된다.
</span><span class="code-line">- 수량 input 클릭 → 장바구니에 담을 상품 수가 1씩 증감한다.
</span><span class="code-line">    - 지정 개수 이상이면 지정한 할인율이 적용된다.
</span><span class="code-line">    - 장바구니에 10개 이상인 상품이 있으면 추가 5% 할인이 적용된다. (최대 50%까지)
</span><span class="code-line">    - 재고 이상으로 증가할 경우, 수량 에러 토스트 팝업이 뜬다.
</span><span class="code-line">    - 1에서 0으로 감소할 경우, 장바구니에 해당 상품이 제거된다.
</span><span class="code-line">    - 재고 소진 시 품절 버튼으로 변경 &amp; 가격 영역이 SOLD OUT으로 변경된다.
</span><span class="code-line">    - 각 장바구니 아이템에 적용된 할인율이 &quot;-X%&quot; 형태로 표시된다.
</span><span class="code-line">- 쿠폰 select 클릭 → 선택한 값으로 쿠폰 할인이 적용된다.
</span><span class="code-line">    - 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">    - 적용 불가한 쿠폰일 경우, 에러 토스트 팝업이 뜬다. (percentage 쿠폰은 10,000원 이상 구매 시 사용 가능)
</span><span class="code-line">- 결제 버튼 클릭 → 결제 성공 토스트 팝업이 뜬다.
</span><span class="code-line">    - 장바구니에 해당 상품이 제거된다.
</span><span class="code-line">    - 선택된 쿠폰이 해제된다.
</span><span class="code-line">- 장바구니 X 버튼 클릭 → 장바구니에 해당 상품이 제거된다.
</span><span class="code-line">- 관리자 페이지로 버튼 클릭 → 관리자 페이지로 이동한다.
</span><span class="code-line">- 데이터 저장/복원
</span><span class="code-line">    - 상품, 쿠폰, 장바구니 데이터가 localStorage에 자동으로 저장된다.
</span><span class="code-line">    - 페이지 새로고침 시 저장된 데이터가 자동으로 복원된다.
</span><span class="code-line">
</span><span class="code-line"># 관리자
</span><span class="code-line">- 새 상품 추가 버튼 클릭 → 새 상품 추가 form이 노출된다.
</span><span class="code-line">    - 상품명을 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">    - 가격을 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
</span><span class="code-line">    - 재고를 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
</span><span class="code-line">    - 취소 버튼 클릭 → 새 상품 추가 form이 미노출된다.
</span><span class="code-line">    - 할인 추가 버튼 클릭 → 할인 추가 form이 노출된다. (기본: 10개 | 10%)
</span><span class="code-line">        - 할인 추가 버튼 클릭 → 할인 추가 form이 추가된다.
</span><span class="code-line">        - 할인 수량 input은 type=&quot;number&quot;이며 min=&quot;1&quot; 속성이 있어 0 이하 입력 시 브라우저 기본 validation이 작동한다.
</span><span class="code-line">        - 할인율 input은 type=&quot;number&quot;이며 max=&quot;100&quot; 속성이 있어 100 이상 입력 시 브라우저 기본 validation이 작동한다.
</span><span class="code-line">        - 각 할인 항목의 X 버튼 클릭 → 해당 할인 항목이 삭제된다.
</span><span class="code-line">    - 필수값(상품명, 가격, 재고)을 입력하고 추가 버튼 클릭 → 상품 목록에 추가된다.
</span><span class="code-line">        - 새 상품 추가 form이 미노출된다.
</span><span class="code-line">        - 상품 추가 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">- 삭제 버튼 클릭 → 해당 상품이 삭제된다.
</span><span class="code-line">    - 삭제 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">- 수정 버튼 클릭 → 상품 수정 form이 노출된다.
</span><span class="code-line">    - 수정 버튼 클릭 → 수정 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">    - 상품명을 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">    - 가격을 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
</span><span class="code-line">    - 재고를 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
</span><span class="code-line">    - 취소 버튼 클릭 → 상품 수정 form이 미노출된다.
</span><span class="code-line">    - 할인 추가 버튼 클릭 → 할인 추가 form이 노출된다. (기본: 10개 | 10%)
</span><span class="code-line">        - 할인 추가 버튼 클릭 → 할인 추가 form이 추가된다.
</span><span class="code-line">        - 할인 수량 input은 type=&quot;number&quot;이며 min=&quot;1&quot; 속성이 있어 0 이하 입력 시 브라우저 기본 validation이 작동한다.
</span><span class="code-line">        - 할인율 input은 type=&quot;number&quot;이며 max=&quot;100&quot; 속성이 있어 100 이상 입력 시 브라우저 기본 validation이 작동한다.
</span><span class="code-line">        - 각 할인 항목의 X 버튼 클릭 → 해당 할인 항목이 삭제된다.
</span><span class="code-line">    - 필수값(상품명, 가격, 재고)을 입력하고 수정 버튼 클릭 → 상품이 수정된다.
</span><span class="code-line">        - 상품 수정 form이 미노출된다.
</span><span class="code-line">        - 상품 수정 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">- 쿠폰 관리 탭 클릭 → 쿠폰 관리 콘텐츠가 노출된다.
</span><span class="code-line">    - 삭제 버튼 클릭 → 해당 쿠폰이 삭제된다.
</span><span class="code-line">        - 삭제 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">        - 삭제한 쿠폰이 현재 선택된 쿠폰이면 자동으로 해제된다.
</span><span class="code-line">    - 새 쿠폰 추가 버튼 클릭 → 새 쿠폰 생성 form이 노출된다.
</span><span class="code-line">        - 취소 버튼 클릭 → 새 쿠폰 생성 form이 미노출된다.
</span><span class="code-line">        - 쿠폰명을 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 쿠폰코드를 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">            - 쿠폰 코드 입력 시 자동으로 대문자로 변환된다.
</span><span class="code-line">        - 할인금액을 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
</span><span class="code-line">        - 할인 타입 select 클릭 → 선택한 값으로 쿠폰 할인 타입이 변경된다.
</span><span class="code-line">        - 이미 존재하는 쿠폰 코드를 입력하고 쿠폰 생성 버튼 클릭 → 에러 토스트 팝업이 뜬다.
</span><span class="code-line">        - 필수값(쿠폰명, 쿠폰 코드, 할인 금액)을 입력하고 쿠폰 생성 버튼 클릭 → 쿠폰 목록에 추가된다.
</span><span class="code-line">            - 새 쿠폰 생성 form이 미노출된다.
</span><span class="code-line">            - 쿠폰 추가 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
</span><span class="code-line">- 쇼핑몰로 돌아가기 버튼 클릭 → 쇼핑몰 페이지로 돌아간다.
</span><span class="code-line">- 데이터 저장/복원
</span><span class="code-line">    - 상품, 쿠폰 데이터가 localStorage에 자동으로 저장된다.
</span><span class="code-line">    - 페이지 새로고침 시 저장된 데이터가 자동으로 복원된다.
</span></code><div class="copied" data-code="# 쇼핑몰
- 쇼핑몰에 존재하는 상품 목록이 노출된다.
    - 재고가 5개 이하면 품절 임박 텍스트가 노출된다.
    - 할인이 있을 경우 해당 할인 정보를 노출한다.
    - 재고 소진 시 품절 버튼으로 변경 &amp; 가격 영역이 SOLD OUT으로 변경된다.
- 검색 input 입력 → 해당 input값을 포함하는 상품들을 반환한다.
    - 검색어 입력 후 500ms 지연 후 검색이 실행된다. (debounce)
    - 상품명과 상품 설명 모두에서 검색한다.
    - 포함하는 상품이 없으면 empty UI를 반환한다.
    - 빈 값이면 전체 상품 리스트를 반환한다.
- 장바구니 담기 버튼 클릭 → 장바구니에 해당 상품이 담긴다.
    - 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
    - 우측에 해당 상품이 적용된다.
    - 헤더의 장바구니 아이콘 옆에 총 아이템 개수가 배지로 표시된다.
- 수량 input 클릭 → 장바구니에 담을 상품 수가 1씩 증감한다.
    - 지정 개수 이상이면 지정한 할인율이 적용된다.
    - 장바구니에 10개 이상인 상품이 있으면 추가 5% 할인이 적용된다. (최대 50%까지)
    - 재고 이상으로 증가할 경우, 수량 에러 토스트 팝업이 뜬다.
    - 1에서 0으로 감소할 경우, 장바구니에 해당 상품이 제거된다.
    - 재고 소진 시 품절 버튼으로 변경 &amp; 가격 영역이 SOLD OUT으로 변경된다.
    - 각 장바구니 아이템에 적용된 할인율이 &quot;-X%&quot; 형태로 표시된다.
- 쿠폰 select 클릭 → 선택한 값으로 쿠폰 할인이 적용된다.
    - 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
    - 적용 불가한 쿠폰일 경우, 에러 토스트 팝업이 뜬다. (percentage 쿠폰은 10,000원 이상 구매 시 사용 가능)
- 결제 버튼 클릭 → 결제 성공 토스트 팝업이 뜬다.
    - 장바구니에 해당 상품이 제거된다.
    - 선택된 쿠폰이 해제된다.
- 장바구니 X 버튼 클릭 → 장바구니에 해당 상품이 제거된다.
- 관리자 페이지로 버튼 클릭 → 관리자 페이지로 이동한다.
- 데이터 저장/복원
    - 상품, 쿠폰, 장바구니 데이터가 localStorage에 자동으로 저장된다.
    - 페이지 새로고침 시 저장된 데이터가 자동으로 복원된다.

# 관리자
- 새 상품 추가 버튼 클릭 → 새 상품 추가 form이 노출된다.
    - 상품명을 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
    - 가격을 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
    - 재고를 입력하지 않고 추가 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
    - 취소 버튼 클릭 → 새 상품 추가 form이 미노출된다.
    - 할인 추가 버튼 클릭 → 할인 추가 form이 노출된다. (기본: 10개 | 10%)
        - 할인 추가 버튼 클릭 → 할인 추가 form이 추가된다.
        - 할인 수량 input은 type=&quot;number&quot;이며 min=&quot;1&quot; 속성이 있어 0 이하 입력 시 브라우저 기본 validation이 작동한다.
        - 할인율 input은 type=&quot;number&quot;이며 max=&quot;100&quot; 속성이 있어 100 이상 입력 시 브라우저 기본 validation이 작동한다.
        - 각 할인 항목의 X 버튼 클릭 → 해당 할인 항목이 삭제된다.
    - 필수값(상품명, 가격, 재고)을 입력하고 추가 버튼 클릭 → 상품 목록에 추가된다.
        - 새 상품 추가 form이 미노출된다.
        - 상품 추가 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
- 삭제 버튼 클릭 → 해당 상품이 삭제된다.
    - 삭제 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
- 수정 버튼 클릭 → 상품 수정 form이 노출된다.
    - 수정 버튼 클릭 → 수정 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
    - 상품명을 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
    - 가격을 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
    - 재고를 입력하지 않고 수정 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 문자열 입력 → 아무일도 일어나지 않는다. (숫자만 입력 가능)
    - 취소 버튼 클릭 → 상품 수정 form이 미노출된다.
    - 할인 추가 버튼 클릭 → 할인 추가 form이 노출된다. (기본: 10개 | 10%)
        - 할인 추가 버튼 클릭 → 할인 추가 form이 추가된다.
        - 할인 수량 input은 type=&quot;number&quot;이며 min=&quot;1&quot; 속성이 있어 0 이하 입력 시 브라우저 기본 validation이 작동한다.
        - 할인율 input은 type=&quot;number&quot;이며 max=&quot;100&quot; 속성이 있어 100 이상 입력 시 브라우저 기본 validation이 작동한다.
        - 각 할인 항목의 X 버튼 클릭 → 해당 할인 항목이 삭제된다.
    - 필수값(상품명, 가격, 재고)을 입력하고 수정 버튼 클릭 → 상품이 수정된다.
        - 상품 수정 form이 미노출된다.
        - 상품 수정 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
- 쿠폰 관리 탭 클릭 → 쿠폰 관리 콘텐츠가 노출된다.
    - 삭제 버튼 클릭 → 해당 쿠폰이 삭제된다.
        - 삭제 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
        - 삭제한 쿠폰이 현재 선택된 쿠폰이면 자동으로 해제된다.
    - 새 쿠폰 추가 버튼 클릭 → 새 쿠폰 생성 form이 노출된다.
        - 취소 버튼 클릭 → 새 쿠폰 생성 form이 미노출된다.
        - 쿠폰명을 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 쿠폰코드를 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
            - 쿠폰 코드 입력 시 자동으로 대문자로 변환된다.
        - 할인금액을 입력하지 않고 쿠폰 생성 버튼 클릭 → 브라우저 기본 validation 에러가 노출된다.
        - 할인 타입 select 클릭 → 선택한 값으로 쿠폰 할인 타입이 변경된다.
        - 이미 존재하는 쿠폰 코드를 입력하고 쿠폰 생성 버튼 클릭 → 에러 토스트 팝업이 뜬다.
        - 필수값(쿠폰명, 쿠폰 코드, 할인 금액)을 입력하고 쿠폰 생성 버튼 클릭 → 쿠폰 목록에 추가된다.
            - 새 쿠폰 생성 form이 미노출된다.
            - 쿠폰 추가 성공 토스트 팝업이 뜬다. (3초 후 자동으로 사라진다)
- 쇼핑몰로 돌아가기 버튼 클릭 → 쇼핑몰 페이지로 돌아간다.
- 데이터 저장/복원
    - 상품, 쿠폰 데이터가 localStorage에 자동으로 저장된다.
    - 페이지 새로고침 시 저장된 데이터가 자동으로 복원된다.
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>(2-2) Action / Calculation / Data로 재분류</strong>
위에서 텍스트로 정리한 내용을 FP 관점에서 Action / Calculation / Data로 재분류했습니다.</p>
<p><strong>1️⃣ Action (부수효과)</strong></p>
<p><strong>[쇼핑몰]</strong></p>
<ul>
<li>검색 input 입력</li>
<li>장바구니 담기 버튼 클릭</li>
<li>수량 input 클릭</li>
<li>쿠폰 select 클릭</li>
<li>결제 버튼 클릭</li>
<li>장바구니 X 버튼 클릭</li>
<li>관리자 페이지로 버튼 클릭</li>
<li>토스트 알림 표시/제거</li>
<li>localStorage 자동 저장</li>
<li>검색 debounce 처리</li>
</ul>
<p><strong>[관리자]</strong></p>
<ul>
<li>새 상품 추가 버튼 클릭</li>
<li>취소 버튼 클릭</li>
<li>상품명 입력</li>
<li>가격 입력</li>
<li>재고 입력</li>
<li>할인 추가 버튼 클릭</li>
<li>할인 항목 X 버튼 클릭</li>
<li>추가 버튼 클릭</li>
<li>삭제 버튼 클릭</li>
<li>수정 버튼 클릭</li>
<li>쿠폰 관리 탭 클릭</li>
<li>삭제 버튼 클릭</li>
<li>새 쿠폰 추가 버튼 클릭</li>
<li>취소 버튼 클릭</li>
<li>쿠폰명 입력</li>
<li>쿠폰코드 입력</li>
<li>할인금액 입력</li>
<li>할인 타입 select 클릭</li>
<li>쿠폰 생성 버튼 클릭</li>
<li>쇼핑몰로 돌아가기 버튼 클릭</li>
</ul>
<p><strong>2️⃣ Calculation (순수 로직)</strong></p>
<ul>
<li>필터링</li>
<li>할인 계산</li>
<li>수량 계산</li>
<li>validation 판단</li>
<li>쿠폰 코드 대문자 변환</li>
<li>재고 계산</li>
<li>가격 포맷팅</li>
<li>장바구니 총 개수 계산</li>
<li>쿠폰 적용 가능 여부 판단</li>
<li>중복 쿠폰 코드 검증</li>
<li>주문번호 생성</li>
</ul>
<p><strong>3️⃣ Data (정적/상태 데이터)</strong></p>
<ul>
<li>상품 리스트</li>
<li>장바구니 리스트</li>
<li>쿠폰 리스트</li>
<li>신규 쿠폰 form 데이터</li>
<li>할인 정책</li>
<li>신규 상품 form 데이터</li>
<li>상품 수정 form 데이터</li>
<li>검색어 (searchTerm, debouncedSearchTerm)</li>
<li>선택된 쿠폰 (selectedCoupon)</li>
<li>관리자 모드 상태 (isAdmin)</li>
<li>알림 리스트 (notifications)</li>
<li>활성 탭 (activeTab)</li>
<li>폼 표시 상태 (showProductForm, showCouponForm)</li>
<li>수정 중인 상품 ID (editingProduct)</li>
<li>장바구니 총 개수 (totalItemCount)</li>
</ul>
<p><strong>(2-3) 피그잼으로 시각화하기</strong>
이런 걸 처음 해보다보니 초반에는 가이드를 잡고 어떤 걸 어디로 분류하고 화살표는 어디까지 연결해야 할지에 대한 기준이 잡히지 않아 시간이 오래 걸렸습니다.</p>
<p>그러나 Q&amp;A 때 테오가 화살표로 연결하는 건 함수를 호출하는 것을 의미하며, 이는 곧 a=&gt;b라고 할 때 <strong>a는 b를 알고 있지만 b는 a를 모른다</strong>는 단방향 흐름을 의미한다고 하여 이해가 갔습니다.</p>
<p>그 이후로 개별 플로우는 시각화를 완성할 수 있었습니다.
<a href="https://www.figma.com/board/DA6BbRA4PJ5ReQ1OI9Sk4D/7%EC%A3%BC%EC%B0%A8_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8_%EB%8F%84%EC%8B%9D%ED%99%94?node-id=0-1&amp;p=f&amp;t=fMsjW2CT3zXIqSVI-0">진행한 피그잼 링크</a>
<img width="614" height="853" alt="image" src="https://github.com/user-attachments/assets/5a374a5f-b1c9-4131-9d97-b620382adbce"/></p>
<p><strong>(3) 본격적인 구조 개선</strong>
<strong>(3-1) 고민</strong>
<strong>1️⃣ 아이콘 정의</strong>
<strong>❗ 둘 다 삭제하는 아이콘인데, 역할을 어떻게 구분지어야 할까?</strong>
<img width="708" height="192" alt="image" src="https://github.com/user-attachments/assets/314efe44-1d11-4f72-ba3b-79bdaa837b1c"/>
<img width="762" height="296" alt="image" src="https://github.com/user-attachments/assets/0f157750-d668-44f3-864e-4bcea45b90a8"/></p>
<p>X 아이콘과 쓰레기통 모양 둘 다 무언가를 삭제할 때 사용하는 아이콘입니다.</p>
<p>네이밍을 할 때 시각적인 걸 기준으로 IconX, IconTrash라는 등의 이름으로 하게 되면 추후에 만약 아이콘이 변경되었을 때 이름 수정이나 아이콘 추가 작업이 필요하게 되고 이는 곧 불필요한 추가 작업을 초래하게 됩니다.</p>
<p>그래서 두개의 <strong>역할을 명확하게</strong> 정해두기로 했습니다.</p>
<ul>
<li>X 아이콘: 일반적으로 폼이나 모달 형태에서 닫기/지우기(on/off 가능)의 역할을 하는 아이콘 =&gt; IconClose</li>
<li>쓰레기통 아이콘:  영구적으로 데이터를 삭제하는 역할을 하는 아이콘 =&gt; IconDelete
그렇게 하니 네이밍을 쉽게 진행할 수 있었습니다!</li>
</ul>
<p><strong>❗ 둘 다 장바구니 모양인데, 역할을 어떻게 구분지어야 할까?</strong>
<img width="378" height="108" alt="image" src="https://github.com/user-attachments/assets/ea8a951d-21a2-4385-a9dd-ee3db5fd4ea8"/>
<img width="220" height="90" alt="image" src="https://github.com/user-attachments/assets/4e76b081-fd14-48ec-aa31-78a52cd9e008"/></p>
<p>첫번째와 유사한 고민으로, 둘 다 장바구니 모양인데 어떻게 네이밍할지 고민됐습니다.
그래도 앞선 경험을 겪고나니 이번에도 역할 기반으로 구분해봤습니다.</p>
<ul>
<li>카트 아이콘: 장바구니 개수를 보여주거나 클릭 시 액션이 존재할만한 영역(현재는 해당 기능까지는 미개발 상태) =&gt; IconCartButton</li>
<li>쇼핑백 아이콘: 단순한 장식 요소 =&gt; IconCartSymbol</li>
</ul>
<p><strong>2️⃣ 동일한 내용의 토스트 팝업인데 중복 노출을 허용해도 되는가?</strong>
<img width="558" height="1094" alt="image" src="https://github.com/user-attachments/assets/7fe3495f-ca62-481a-b369-d61bc8e797ec"/>
동일한 내용의 토스트 팝업이 아직 화면에서 사라지지 않았는데 호출하는만큼 노출되는 게 에러처럼 보인다고 생각했습니다.
그래서 동일한 내용이라면 해당 토스트 팝업이 <strong>사라지기 전까지는 중복 호출을 막는</strong> 것으로 개선했습니다.</p>
<p><strong>3️⃣ 상품목록이 비어있으면 table 부분부터 안 나와야 하는 게 아닌가?</strong>
<img width="1280" height="271" alt="image" src="https://github.com/user-attachments/assets/daac272e-d54b-4b78-8ac0-a08da0bc51f8"/>
기존에는 상품 목록이 비어있어도 table header 부분까지는 노출되고 body 부분만 미노출되도록 작업되어있었지만,
개인적으로 이건 <strong>적합하지 않은 UI</strong>라고 판단되어 table 자체가 미노출되도록 수정했습니다.</p>
<p><strong>4️⃣ isRecommended는 어떻게 확인하나?</strong>
<img width="1280" height="372" alt="image" src="https://github.com/user-attachments/assets/d2fa34fc-bdec-4a55-8b8e-0a017f719c85"/>
상품 구조에서는 isRecommended를 기준으로 BEST 뱃지 노출 처리를 하고 있었는데
form에서는 도저히 isRecommended를 제어하는 영역을 찾을 수 없었고 이상한 부분이라고 생각했습니다.</p>
<p>일반적으로 BEST 뱃지는 <strong>관리자 재량</strong>으로 노출시키기 때문에 <strong>form에서 isRecommended를 적용</strong>할 수 있도록 개선했습니다.</p>
<p><strong>5️⃣ 의미없는 분기</strong>
불필요한 분기는 삭제했습니다!</p>
<pre><code class="code-highlight"><span class="code-line">{(activeTab === &quot;products&quot; ? products : products).map((product) =&gt;
</span></code><div class="copied" data-code="{(activeTab === &quot;products&quot; ? products : products).map((product) =&gt;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>(3-2) 디자인 패턴 적용</strong>
<strong>1️⃣ 생성 패턴(Creational Patterns)</strong>
<strong>❗Factory Method(팩토리 메서드 패턴)</strong>
쿠폰 생성 시 복잡한 검증 로직을 캡슐화하여 일관성을 보장합니다.</p>
<pre><code class="code-highlight"><span class="code-line">// models/coupon.ts
</span><span class="code-line">export interface AddCouponResult {
</span><span class="code-line">  coupons: Coupon[];
</span><span class="code-line">  success: boolean;
</span><span class="code-line">  errorMessage?: string;
</span><span class="code-line">}
</span><span class="code-line">export const addCoupon = (
</span><span class="code-line">  coupons: Coupon[],
</span><span class="code-line">  newCoupon: Coupon
</span><span class="code-line">): AddCouponResult =&gt; {
</span><span class="code-line">  // 1. 검증
</span><span class="code-line">  const validation = validateCouponForm(newCoupon);
</span><span class="code-line">  if (!validation.isValid) {
</span><span class="code-line">    return {
</span><span class="code-line">      coupons,
</span><span class="code-line">      success: false,
</span><span class="code-line">      errorMessage: validation.errorMessage,
</span><span class="code-line">    };
</span><span class="code-line">  }
</span><span class="code-line">  // 2. 중복 체크
</span><span class="code-line">  if (isCouponCodeDuplicate(coupons, newCoupon.code)) {
</span><span class="code-line">    return {
</span><span class="code-line">      coupons,
</span><span class="code-line">      success: false,
</span><span class="code-line">      errorMessage: &quot;이미 존재하는 쿠폰 코드입니다.&quot;,
</span><span class="code-line">    };
</span><span class="code-line">  }
</span><span class="code-line">  // 3. 쿠폰 생성 및 반환
</span><span class="code-line">  return {
</span><span class="code-line">    coupons: [...coupons, newCoupon],
</span><span class="code-line">    success: true,
</span><span class="code-line">  };
</span><span class="code-line">};
</span><span class="code-line">// AdminCouponForm.tsx
</span><span class="code-line">const result = addCoupon(coupons, couponForm);
</span><span class="code-line">if (!result.success) {
</span><span class="code-line">  handleNotificationAdd(result.errorMessage || &quot;&quot;, &quot;error&quot;);
</span><span class="code-line">  return;
</span><span class="code-line">}
</span><span class="code-line">setCoupons(result.coupons);
</span></code><div class="copied" data-code="// models/coupon.ts
export interface AddCouponResult {
  coupons: Coupon[];
  success: boolean;
  errorMessage?: string;
}
export const addCoupon = (
  coupons: Coupon[],
  newCoupon: Coupon
): AddCouponResult =&gt; {
  // 1. 검증
  const validation = validateCouponForm(newCoupon);
  if (!validation.isValid) {
    return {
      coupons,
      success: false,
      errorMessage: validation.errorMessage,
    };
  }
  // 2. 중복 체크
  if (isCouponCodeDuplicate(coupons, newCoupon.code)) {
    return {
      coupons,
      success: false,
      errorMessage: &quot;이미 존재하는 쿠폰 코드입니다.&quot;,
    };
  }
  // 3. 쿠폰 생성 및 반환
  return {
    coupons: [...coupons, newCoupon],
    success: true,
  };
};
// AdminCouponForm.tsx
const result = addCoupon(coupons, couponForm);
if (!result.success) {
  handleNotificationAdd(result.errorMessage || &quot;&quot;, &quot;error&quot;);
  return;
}
setCoupons(result.coupons);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>2️⃣ 구조 패턴(Structural Patterns)</strong>
<strong>❗Facade(파사드 패턴)</strong></p>
<pre><code class="code-highlight"><span class="code-line">// models/cart.ts
</span><span class="code-line">export const calculateCartTotal = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  selectedCoupon: Coupon | null
</span><span class="code-line">): {
</span><span class="code-line">  totalBeforeDiscount: number;
</span><span class="code-line">  totalAfterDiscount: number;
</span><span class="code-line">} =&gt; {
</span><span class="code-line">  // 내부적으로 여러 복잡한 계산을 수행
</span><span class="code-line">  const totalBeforeDiscount = calculateCartOriginalTotal(cart);
</span><span class="code-line">  const totalAfterItemDiscount = calculateTotalBeforeCoupon(cart);
</span><span class="code-line">  const totalAfterDiscount = applyCouponDiscount(
</span><span class="code-line">    totalAfterItemDiscount,
</span><span class="code-line">    selectedCoupon
</span><span class="code-line">  );
</span><span class="code-line">  return {
</span><span class="code-line">    totalBeforeDiscount,
</span><span class="code-line">    totalAfterDiscount,
</span><span class="code-line">  };
</span><span class="code-line">};
</span></code><div class="copied" data-code="// models/cart.ts
export const calculateCartTotal = (
  cart: CartItem[],
  selectedCoupon: Coupon | null
): {
  totalBeforeDiscount: number;
  totalAfterDiscount: number;
} =&gt; {
  // 내부적으로 여러 복잡한 계산을 수행
  const totalBeforeDiscount = calculateCartOriginalTotal(cart);
  const totalAfterItemDiscount = calculateTotalBeforeCoupon(cart);
  const totalAfterDiscount = applyCouponDiscount(
    totalAfterItemDiscount,
    selectedCoupon
  );
  return {
    totalBeforeDiscount,
    totalAfterDiscount,
  };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>복잡한 할인 계산 로직을 분리함으로써 컴포넌트에서는 calculateCartTotal(cart, coupon)만 호출하면 됩니다.</p>
<pre><code class="code-highlight"><span class="code-line">// ShoppingCouponPayment.tsx
</span><span class="code-line">const totals = calculateCartTotal(cart, selectedCoupon);
</span></code><div class="copied" data-code="// ShoppingCouponPayment.tsx
const totals = calculateCartTotal(cart, selectedCoupon);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗Composite (컴포지트 패턴)</strong>
작은 순수 함수들을 조합하여 복잡한 로직을 구현함으로써
각 함수의 독립적인 테스트가 가능하고 함수 재사용성이 향상됩니다.</p>
<pre><code class="code-highlight"><span class="code-line">// calculateItemTotal은 여러 함수를 조합
</span><span class="code-line">export const calculateItemTotal = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  item: CartItem
</span><span class="code-line">): number =&gt; {
</span><span class="code-line">  // 할인율 계산
</span><span class="code-line">  const discountRate = getMaxApplicableDiscount(cart, item);  
</span><span class="code-line">  // 할인 가격 계산
</span><span class="code-line">  return calculateDiscountedPrice(                            
</span><span class="code-line">    item.product.price,
</span><span class="code-line">    item.quantity,
</span><span class="code-line">    discountRate
</span><span class="code-line">  );
</span><span class="code-line">};
</span><span class="code-line">// getMaxApplicableDiscount도 여러 함수 조합
</span><span class="code-line">export const getMaxApplicableDiscount = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  item: CartItem
</span><span class="code-line">): number =&gt; {
</span><span class="code-line">// 기본 할인
</span><span class="code-line">  const baseDiscount = getMaxDiscountRate(                    
</span><span class="code-line">    item.product.discounts,
</span><span class="code-line">    item.quantity
</span><span class="code-line">  );
</span><span class="code-line">  // 대량 구매 할인
</span><span class="code-line">  if (hasBulkPurchase(cart)) {                                
</span><span class="code-line">    return Math.min(baseDiscount + 0.05, 0.5);
</span><span class="code-line">  }
</span><span class="code-line">  return baseDiscount;
</span><span class="code-line">};
</span></code><div class="copied" data-code="// calculateItemTotal은 여러 함수를 조합
export const calculateItemTotal = (
  cart: CartItem[],
  item: CartItem
): number =&gt; {
  // 할인율 계산
  const discountRate = getMaxApplicableDiscount(cart, item);  
  // 할인 가격 계산
  return calculateDiscountedPrice(                            
    item.product.price,
    item.quantity,
    discountRate
  );
};
// getMaxApplicableDiscount도 여러 함수 조합
export const getMaxApplicableDiscount = (
  cart: CartItem[],
  item: CartItem
): number =&gt; {
// 기본 할인
  const baseDiscount = getMaxDiscountRate(                    
    item.product.discounts,
    item.quantity
  );
  // 대량 구매 할인
  if (hasBulkPurchase(cart)) {                                
    return Math.min(baseDiscount + 0.05, 0.5);
  }
  return baseDiscount;
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3️⃣ 행동 패턴(Behavioral Patterns)</strong>
<strong>❗Strategy(전략 패턴)</strong>
할인 타입(amount/percentage)에 따라 다른 계산 방식을 적용함으로써 새로운 할인 타입 추가 시 확장이 용이합니다.</p>
<pre><code class="code-highlight"><span class="code-line">// models/coupon.ts
</span><span class="code-line">export const applyCouponDiscount = (
</span><span class="code-line">  totalBeforeCoupon: number,
</span><span class="code-line">  coupon: Coupon | null
</span><span class="code-line">): number =&gt; {
</span><span class="code-line">  if (!coupon) {
</span><span class="code-line">    return totalBeforeCoupon;
</span><span class="code-line">  }
</span><span class="code-line">  // Strategy: 할인 타입에 따라 다른 알고리즘 적용
</span><span class="code-line">  if (coupon.discountType === &quot;amount&quot;) {
</span><span class="code-line">    // 정액 할인 전략
</span><span class="code-line">    return Math.max(0, totalBeforeCoupon - coupon.discountValue);
</span><span class="code-line">  } else {
</span><span class="code-line">    // 정률 할인 전략
</span><span class="code-line">    return Math.round(
</span><span class="code-line">      totalBeforeCoupon * (1 - coupon.discountValue / 100)
</span><span class="code-line">    );
</span><span class="code-line">  }
</span><span class="code-line">};
</span></code><div class="copied" data-code="// models/coupon.ts
export const applyCouponDiscount = (
  totalBeforeCoupon: number,
  coupon: Coupon | null
): number =&gt; {
  if (!coupon) {
    return totalBeforeCoupon;
  }
  // Strategy: 할인 타입에 따라 다른 알고리즘 적용
  if (coupon.discountType === &quot;amount&quot;) {
    // 정액 할인 전략
    return Math.max(0, totalBeforeCoupon - coupon.discountValue);
  } else {
    // 정률 할인 전략
    return Math.round(
      totalBeforeCoupon * (1 - coupon.discountValue / 100)
    );
  }
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗Template Method(템플릿 메서드 패턴) - 부분적 적용</strong>
각 단계를 명확히 분리함으로써 검증 → 체크 → 생성의 순서가 항상 유지되도록 합니다.</p>
<pre><code class="code-highlight"><span class="code-line">// coupon.ts
</span><span class="code-line">export const addCoupon = (
</span><span class="code-line">  coupons: Coupon[],
</span><span class="code-line">  newCoupon: Coupon
</span><span class="code-line">): AddCouponResult =&gt; {
</span><span class="code-line">  // 템플릿: 1. 검증 → 2. 중복 체크 → 3. 생성
</span><span class="code-line">  const validation = validateCouponForm(newCoupon);  // 1단계
</span><span class="code-line">  if (!validation.isValid) {
</span><span class="code-line">    return { coupons, success: false, errorMessage: validation.errorMessage };
</span><span class="code-line">  }
</span><span class="code-line">  if (isCouponCodeDuplicate(coupons, newCoupon.code)) {  // 2단계
</span><span class="code-line">    return { coupons, success: false, errorMessage: &quot;이미 존재하는 쿠폰 코드입니다.&quot; };
</span><span class="code-line">  }
</span><span class="code-line">  return { coupons: [...coupons, newCoupon], success: true };  // 3단계
</span><span class="code-line">};
</span></code><div class="copied" data-code="// coupon.ts
export const addCoupon = (
  coupons: Coupon[],
  newCoupon: Coupon
): AddCouponResult =&gt; {
  // 템플릿: 1. 검증 → 2. 중복 체크 → 3. 생성
  const validation = validateCouponForm(newCoupon);  // 1단계
  if (!validation.isValid) {
    return { coupons, success: false, errorMessage: validation.errorMessage };
  }
  if (isCouponCodeDuplicate(coupons, newCoupon.code)) {  // 2단계
    return { coupons, success: false, errorMessage: &quot;이미 존재하는 쿠폰 코드입니다.&quot; };
  }
  return { coupons: [...coupons, newCoupon], success: true };  // 3단계
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>4️⃣ 추가 설계 원칙 및 패턴</strong>
GoF 패턴 외에도 적용된 중요한 설계 원칙들을 적용했습니다.</p>
<p><strong>❗ Pure Function Pattern(순수 함수 패턴)</strong>
동일한 입력에 대해 항상 동일한 출력을 보장하고 디버깅이 용이하다.</p>
<pre><code class="code-highlight"><span class="code-line">// discount.ts
</span><span class="code-line">export const getMaxDiscountRate = (
</span><span class="code-line">  discounts: Discount[],
</span><span class="code-line">  quantity: number
</span><span class="code-line">): number =&gt; {
</span><span class="code-line">  return discounts.reduce((maxDiscount, discount) =&gt; {
</span><span class="code-line">    return quantity &gt;= discount.quantity &amp;&amp; discount.rate &gt; maxDiscount
</span><span class="code-line">      ? discount.rate
</span><span class="code-line">      : maxDiscount;
</span><span class="code-line">  }, 0);
</span><span class="code-line">};
</span></code><div class="copied" data-code="// discount.ts
export const getMaxDiscountRate = (
  discounts: Discount[],
  quantity: number
): number =&gt; {
  return discounts.reduce((maxDiscount, discount) =&gt; {
    return quantity &gt;= discount.quantity &amp;&amp; discount.rate &gt; maxDiscount
      ? discount.rate
      : maxDiscount;
  }, 0);
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗ Result Pattern(결과 패턴)</strong>
예외 대신 Result 타입을 반환하여 에러를 명시적으로 처리함으로써 타입 안전성이 향상되고 에러 처리를 강제할 수 있습니다.</p>
<pre><code class="code-highlight"><span class="code-line">// cart.ts
</span><span class="code-line">export type AddToCartError = &quot;OUT_OF_STOCK&quot; | &quot;EXCEEDS_STOCK&quot; | null;
</span><span class="code-line">export interface AddToCartResult {
</span><span class="code-line">  cart: CartItem[];
</span><span class="code-line">  error: AddToCartError;
</span><span class="code-line">}
</span><span class="code-line">export const addProductToCart = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  product: ProductWithUI
</span><span class="code-line">): AddToCartResult =&gt; {
</span><span class="code-line">  const remainingStock = getRemainingStock(product, cart);
</span><span class="code-line">  if (remainingStock &lt;= 0) {
</span><span class="code-line">    return { cart, error: &quot;OUT_OF_STOCK&quot; };
</span><span class="code-line">  }
</span><span class="code-line">  // ...
</span><span class="code-line">  return { cart: nextCart, error: null };
</span><span class="code-line">};
</span></code><div class="copied" data-code="// cart.ts
export type AddToCartError = &quot;OUT_OF_STOCK&quot; | &quot;EXCEEDS_STOCK&quot; | null;
export interface AddToCartResult {
  cart: CartItem[];
  error: AddToCartError;
}
export const addProductToCart = (
  cart: CartItem[],
  product: ProductWithUI
): AddToCartResult =&gt; {
  const remainingStock = getRemainingStock(product, cart);
  if (remainingStock &lt;= 0) {
    return { cart, error: &quot;OUT_OF_STOCK&quot; };
  }
  // ...
  return { cart: nextCart, error: null };
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗ Immutability Pattern (불변성 패턴)</strong>
기존 데이터를 변경하지 않고 새로운 데이터를 생성함으로써 React의 불변성 요구사항을 충족합니다.</p>
<pre><code class="code-highlight"><span class="code-line">// cart.ts
</span><span class="code-line">export const removeProductFromCart = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  productId: string
</span><span class="code-line">): CartItem[] =&gt; {
</span><span class="code-line">  return cart.filter((item) =&gt; item.product.id !== productId); // 새 배열 반환
</span><span class="code-line">};
</span><span class="code-line">export const updateCartItemQuantity = (
</span><span class="code-line">  cart: CartItem[],
</span><span class="code-line">  productId: string,
</span><span class="code-line">  newQuantity: number
</span><span class="code-line">): CartItem[] =&gt; {
</span><span class="code-line">  return cart.map((item) =&gt;
</span><span class="code-line">    item.product.id === productId
</span><span class="code-line">      ? { ...item, quantity: newQuantity }  // 새 객체 생성
</span><span class="code-line">      : item
</span><span class="code-line">  );
</span><span class="code-line">};
</span></code><div class="copied" data-code="// cart.ts
export const removeProductFromCart = (
  cart: CartItem[],
  productId: string
): CartItem[] =&gt; {
  return cart.filter((item) =&gt; item.product.id !== productId); // 새 배열 반환
};
export const updateCartItemQuantity = (
  cart: CartItem[],
  productId: string,
  newQuantity: number
): CartItem[] =&gt; {
  return cart.map((item) =&gt;
    item.product.id === productId
      ? { ...item, quantity: newQuantity }  // 새 객체 생성
      : item
  );
};
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗Single Responsibility Principle(단일 책임 원칙)</strong>
엔티티별 모듈을 분리함으로써 모듈 간 결합도는 감소시키고 변경 영향 범위를 최소화합니다.</p>
<pre><code class="code-highlight"><span class="code-line">models/
</span><span class="code-line">  ├── cart.ts      → 장바구니 관련 로직만
</span><span class="code-line">  ├── coupon.ts    → 쿠폰 관련 로직만
</span><span class="code-line">  ├── discount.ts  → 할인 관련 로직만
</span><span class="code-line">  └── product.ts   → 상품 관련 로직만
</span></code><div class="copied" data-code="models/
  ├── cart.ts      → 장바구니 관련 로직만
  ├── coupon.ts    → 쿠폰 관련 로직만
  ├── discount.ts  → 할인 관련 로직만
  └── product.ts   → 상품 관련 로직만
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>❗ Separation of Concerns (관심사의 분리)</strong>
컴포넌트와 비즈니스 로직을 분리함으로써 재사용성을 향상시키고 유지보수가 용이하도록 합니다.</p>
<pre><code class="code-highlight"><span class="code-line">Before (컴포넌트에 비즈니스 로직 포함)
</span><span class="code-line">// ShoppingCartItem.tsx (이전)
</span><span class="code-line">const calculateItemTotal = (item: CartItem): number =&gt; {
</span><span class="code-line">  const { price } = item.product;
</span><span class="code-line">  const { quantity } = item;
</span><span class="code-line">  const discount = getMaxApplicableDiscount(item, cart);
</span><span class="code-line">  return Math.round(price * quantity * (1 - discount));
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">After (비즈니스 로직을 모델로 분리)
</span><span class="code-line">// models/cart.ts
</span><span class="code-line">export const calculateItemTotal = (cart, item) =&gt; { /* ... */ };
</span><span class="code-line">// ShoppingCartItem.tsx
</span><span class="code-line">const itemTotal = calculateItemTotal(cart, item);
</span></code><div class="copied" data-code="Before (컴포넌트에 비즈니스 로직 포함)
// ShoppingCartItem.tsx (이전)
const calculateItemTotal = (item: CartItem): number =&gt; {
  const { price } = item.product;
  const { quantity } = item;
  const discount = getMaxApplicableDiscount(item, cart);
  return Math.round(price * quantity * (1 - discount));
};

After (비즈니스 로직을 모델로 분리)
// models/cart.ts
export const calculateItemTotal = (cart, item) =&gt; { /* ... */ };
// ShoppingCartItem.tsx
const itemTotal = calculateItemTotal(cart, item);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>(4) Jotai 적용</strong>
구조 개선을 진행하며 props drilling이 거듭될 때마다 컴포넌트 분리를 덜 해야 하나 싶어지기까지 했습니다.</p>
<pre><code class="code-highlight"><span class="code-line">src/basic/
</span><span class="code-line">├── App.tsx (L0) ⚠️ Props 생성
</span><span class="code-line">│   ├── cart: CartItem[]
</span><span class="code-line">│   ├── products: ProductWithUI[]
</span><span class="code-line">│   ├── setCart: Dispatch&lt;...&gt;
</span><span class="code-line">│   └── addNotification: (message, type) =&gt; void
</span><span class="code-line">│
</span><span class="code-line">└── pages/
</span><span class="code-line">    └── PageShopping.tsx (L1) ⚠️ Props 전달만 (사용 안 함)
</span><span class="code-line">        ├── cart: CartItem[] ⬇️
</span><span class="code-line">        ├── products: ProductWithUI[] ⬇️
</span><span class="code-line">        ├── setCart: Dispatch&lt;...&gt; ⬇️
</span><span class="code-line">        └── handleNotificationAdd: (message, type) =&gt; void ⬇️
</span><span class="code-line">        │
</span><span class="code-line">        └── shopping/
</span><span class="code-line">            └── ShoppingList.tsx (L2) ⚠️ Props 전달만 (사용 안 함)
</span><span class="code-line">                ├── cart: CartItem[] ⬇️
</span><span class="code-line">                ├── products: ProductWithUI[] ⬇️
</span><span class="code-line">                ├── setCart: Dispatch&lt;...&gt; ⬇️
</span><span class="code-line">                └── handleNotificationAdd: (message, type) =&gt; void ⬇️
</span><span class="code-line">                │
</span><span class="code-line">                └── product/
</span><span class="code-line">                    └── ShoppingProductItem.tsx (L3) ⚠️ Props 전달만 (사용 안 함)
</span><span class="code-line">                        ├── cart: CartItem[] ⬇️
</span><span class="code-line">                        ├── products: ProductWithUI[] ⬇️
</span><span class="code-line">                        ├── setCart: Dispatch&lt;...&gt; ⬇️
</span><span class="code-line">                        └── handleNotificationAdd: (message, type) =&gt; void ⬇️
</span><span class="code-line">                        │
</span><span class="code-line">                        └── components/entity/product/
</span><span class="code-line">                            └── ProductItem.tsx (L4) ✅ 최종 사용처
</span><span class="code-line">                                ├── cart: CartItem[] ✅ 실제 사용
</span><span class="code-line">                                ├── products: ProductWithUI[] ✅ 실제 사용
</span><span class="code-line">                                ├── setCart: Dispatch&lt;...&gt; ✅ 실제 사용
</span><span class="code-line">                                └── handleNotificationAdd: (message, type) =&gt; void ✅ 실제 사용
</span></code><div class="copied" data-code="src/basic/
├── App.tsx (L0) ⚠️ Props 생성
│   ├── cart: CartItem[]
│   ├── products: ProductWithUI[]
│   ├── setCart: Dispatch&lt;...&gt;
│   └── addNotification: (message, type) =&gt; void
│
└── pages/
    └── PageShopping.tsx (L1) ⚠️ Props 전달만 (사용 안 함)
        ├── cart: CartItem[] ⬇️
        ├── products: ProductWithUI[] ⬇️
        ├── setCart: Dispatch&lt;...&gt; ⬇️
        └── handleNotificationAdd: (message, type) =&gt; void ⬇️
        │
        └── shopping/
            └── ShoppingList.tsx (L2) ⚠️ Props 전달만 (사용 안 함)
                ├── cart: CartItem[] ⬇️
                ├── products: ProductWithUI[] ⬇️
                ├── setCart: Dispatch&lt;...&gt; ⬇️
                └── handleNotificationAdd: (message, type) =&gt; void ⬇️
                │
                └── product/
                    └── ShoppingProductItem.tsx (L3) ⚠️ Props 전달만 (사용 안 함)
                        ├── cart: CartItem[] ⬇️
                        ├── products: ProductWithUI[] ⬇️
                        ├── setCart: Dispatch&lt;...&gt; ⬇️
                        └── handleNotificationAdd: (message, type) =&gt; void ⬇️
                        │
                        └── components/entity/product/
                            └── ProductItem.tsx (L4) ✅ 최종 사용처
                                ├── cart: CartItem[] ✅ 실제 사용
                                ├── products: ProductWithUI[] ✅ 실제 사용
                                ├── setCart: Dispatch&lt;...&gt; ✅ 실제 사용
                                └── handleNotificationAdd: (message, type) =&gt; void ✅ 실제 사용
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>하지만 그게 과제의 목표이니 아랑곳하지 않고 props drilling을 진행했고 드디어 개선할 때입니다!!!!</p>
<p>적용하는 과정은 그리 어렵지 않았습니다.
useState로 정의했던 내용들은 다 Jotai를 활용하도록 변경하면 로컬 페이지에서는 문제없이 동작했습니다.</p>
<p><strong>(4-1) 돌아온 테스트와 로컬의 차이</strong>
그러나 테스트에서는 &quot;장바구니 담기&quot;버튼을 찾지 못해서 테스트가 12개정도 실패했습니다..(돌아온 테스트와 로컬의 차이)</p>
<pre><code class="code-highlight"><span class="code-line">fireEvent.click(screen.getAllByText(&#x27;장바구니 담기&#x27;)[0]);
</span></code><div class="copied" data-code="fireEvent.click(screen.getAllByText(&#x27;장바구니 담기&#x27;)[0]);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>스냅샷을 확인해보니 테스트의 알림이 많이 생성되어 페이지에 남아있었고 그로 인해 버튼을 찾지 못하는 것처럼 보였습니다.</p>
<p>즉, 각 테스트의 상태가 격리되어야 하는 것이고 매 테스트마다 시작 부분에 App을 렌더하고 있으므로 각 App이 독립된 상태를 가지도록 하면 되지 않을까 싶었습니다.</p>
<pre><code class="code-highlight"><span class="code-line">test(&#x27;상품을 검색하고 장바구니에 추가할 수 있다&#x27;, async () =&gt; {
</span><span class="code-line">  render(&lt;App /&gt;);
</span></code><div class="copied" data-code="test(&#x27;상품을 검색하고 장바구니에 추가할 수 있다&#x27;, async () =&gt; {
  render(&lt;App /&gt;);
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>이를 위해 Provider로 App을 감싸서 App 렌더링 시 매번 새로운 Provider가 생성되도록 했고 이를 통해 이전 테스트의 상태가 영향을 주지 않게끔 할 수 있습니다!</p>
<hr/>
<h3 id="이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><a class="anchor" aria-hidden="true" tabindex="-1" href="#이번-과제를-통해-앞으로-해보고-싶은게-있다면-알려주세요"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>이번 과제를 통해 앞으로 해보고 싶은게 있다면 알려주세요!</h3>
<p>이번 과제를 진행하면서 느낀 점은 <strong>레거시 코드를 분석하고 개선</strong>하는 작업은 차라리 명확한 기준이 있어서 접근하기 쉬웠지만,
<strong>처음부터 코드를 작성</strong>할 때 함수형 프로그래밍이나 디자인 패턴을 <strong>자연스럽게 고려하는 것은 훨씬 어렵다</strong>는 것이었습니다.</p>
<p>앞으로는 기능 구현을 바로 시작하는 대신</p>
<ul>
<li>기능 플로우를 설계하고</li>
<li>Action / Calculation / Data 를 정리하고</li>
<li>엔티티 단위로 구조를 먼저 잡은 뒤</li>
<li>그 후에 실제 코드를 작성하는 방식
으로 <strong>처음부터 구조의 흐름을 설계</strong>하는 습관을 만들고 싶습니다.</li>
</ul>
<p>이번 과제를 통해 그 중요성을 체감할 수 있었고, 다음 프로젝트나 기능 개발에 적용해보고 싶습니다!</p>
<h3 id="리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용이나-궁금한-것에-대한-질문-편하게-남겨주세요-"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용이나 궁금한 것에 대한 질문 편하게 남겨주세요 :)</h3>
<ul>
<li>처음부터 기능과 구조를 설계할 때 어떤 기준이나 접근 방식으로 시작하면 좋을까요?</li>
<li>구조 설계 단계에서 피그잼이나 노션에 어떤 내용을 정리하면 실전에서 가장 효과적인지 노하우가 있을까요?</li>
<li>패턴과 함수형 사고를 자연스럽게 적용할 수 있도록 훈련하는 방법이 궁금합니다!</li>
</ul>
<hr/>
<p>자세한 구현 과정과 회고는 아래 블로그에 정리했습니다! 😊
<a href="https://chaeng03.tistory.com/entry/%ED%95%AD%ED%95%B499-7%EC%A3%BC%EC%B0%A8%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EC%84%A4%EA%B3%84">7주차_디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</a>
<a href="https://chaeng03.tistory.com/m/entry/%ED%95%AD%ED%95%B499-WIL-7%EC%A3%BC%EC%B0%A8Chapter3-2-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EA%B3%BC-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-%EC%84%A4%EA%B3%84">WIL 7주차_Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계</a></p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>안녕하세요 채영님! 7주차 과제 잘 진행해주셨네요. 압도적인 회고에 놀랐습니다 ㅎㅎ 고생하셨습니다~!!</p>
<blockquote>
<p>처음부터 기능과 구조를 설계할 때 어떤 기준이나 접근 방식으로 시작하면 좋을까요?</p>
</blockquote>
<p>제일 중요한건 요구사항이라고 생각합니다 ㅎㅎ
요구사항은 기능 요구사항과 비기능(기술) 요구사항이 있어요.</p>
<p>기능 요구사항에 제일 잘 대응할 수 있는 설계가 있으니 이를 먼저 고려해야 한답니다.
비기능 요구사항은</p>
<ul>
<li>모노 레포 vs 모놀리식 레포</li>
<li>vue vs react</li>
<li>csr vs ssr</li>
<li>..</li>
</ul>
<p>이런 것들이죠!</p>
<p>어떤 요구사항을 어떤 방식으로 구현하는지에 따라 설계가 완전히 달라지기 때문에, 요구사항에 대한 접근이 중요해요.
정답이 딱히 없는 영역이랄까...</p>
<p>코드를 작성할 때에도 &quot;기능 요구사항이 추가/수정/삭제 된다면 어떻게 될까?&quot; 를 항상 고민해보시면 좋답니다!
내가 작성한 코드가 어떤 요구사항에 잘 대응되는지 시뮬레이션을 돌려보는거죠 ㅎㅎ</p>
<blockquote>
<p>구조 설계 단계에서 피그잼이나 노션에 어떤 내용을 정리하면 실전에서 가장 효과적인지 노하우가 있을까요?</p>
</blockquote>
<p>저는 &quot;사용자 시나리오&quot;와 &quot;엣지 케이스&quot;를 정리해보는거라고 생각해요.</p>
<ol>
<li>사용자 시나리오를 만들고</li>
<li>사용자 시나리오에 대한 use-case 를 설계하고</li>
<li>use-case 에 대응 되는 구간을 설계하고</li>
</ol>
<p>이런 과정이랄까... 이게 글로 설명하기는 어려운데 다음에 멘토링 때 기회가 되면 저희 팀에서 했던 방식을 소개해드릴게요!</p>
<blockquote>
<p>패턴과 함수형 사고를 자연스럽게 적용할 수 있도록 훈련하는 방법이 궁금합니다!</p>
</blockquote>
<p>일단 함수형으로 코드를 다 작성해보는거죠 ㅎㅎ
함수형 사고는 결국 &quot;선언형 패러다임&quot;과 연관있다고 생각해요.</p>
<p>AI를 이용해서 &quot;이걸 선언형 패러다임으로 만든다면 어떤 모습일까?&quot;를 계속 물어보는 방법도 좋답니다!</p>
<p>패턴은.. 저도 잘 모르겠어요 ㅋㅋ</p>
<p>제일 도움이 많이 되었던건 &quot;리팩토링&quot;을 반복적으로 해보는 것이라고 생각해요.
만들었던 것을 다시 수정하고 수정하고 수정하는 과정을 거치면서 훈련을 하는거죠.
다만 똑같은 방식으로 만들기보단 다양한 시도를 해보시면 좋답니다!</p>
<p>저는 극단적인 오버엔지니어링을 하면서 실력이 많이 늘었었어요. 그러면서 밸런스를 맞춰가는거죠!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 김채영 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 김채영님이 제출한 [5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 김채영, [5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 김채영 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 김채영님이 제출한 [5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 - 김채영 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 김채영님이 제출한 [5팀 김채영] Chapter3-2. 디자인 패턴과 함수형 프로그래밍 그리고 상태 관리 설계 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
