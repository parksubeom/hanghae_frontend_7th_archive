<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@taejun0/" data-discover="true">taejun0<!-- --> 님의 상세페이지</a> ＞ <!-- -->[5팀 오태준] Chapter 2-2. 나만의 React 만들기</h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/42" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[5팀 오태준] Chapter 2-2. 나만의 React 만들기</h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->taejun0</span><span>2025.11.17</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://taejun0.github.io/front_7th_chapter2-2/">https://taejun0.github.io/front_7th_chapter2-2/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="phase-1-vnode와-기초-유틸리티"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-1-vnode와-기초-유틸리티"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 1: VNode와 기초 유틸리티</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/elements.ts</code>: <code>createElement</code>, <code>normalizeNode</code>, <code>createChildPath</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/validators.ts</code>: <code>isEmptyValue</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/equals.ts</code>: <code>shallowEquals</code>, <code>deepEquals</code></li>
</ul>
<h4 id="phase-2-컨텍스트와-루트-초기화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-2-컨텍스트와-루트-초기화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 2: 컨텍스트와 루트 초기화</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/types.ts</code>: VNode/Instance/Context 타입 선언</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 루트/훅 컨텍스트와 경로 스택 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/setup.ts</code>: 컨테이너 초기화, 컨텍스트 리셋, 루트 렌더 트리거</li>
</ul>
<h4 id="phase-3-dom-인터페이스-구축"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-3-dom-인터페이스-구축"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 3: DOM 인터페이스 구축</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: 속성/스타일/이벤트 적용 규칙, DOM 노드 탐색/삽입/제거</li>
</ul>
<h4 id="phase-4-렌더-스케줄링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-4-렌더-스케줄링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 4: 렌더 스케줄링</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/enqueue.ts</code>: <code>enqueue</code>, <code>withEnqueue</code>로 마이크로태스크 큐 구성</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/render.ts</code>: <code>render</code>, <code>enqueueRender</code>로 루트 렌더 사이클 구현</li>
</ul>
<h4 id="phase-5-reconciliation"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-5-reconciliation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 5: Reconciliation</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/reconciler.ts</code>: 마운트/업데이트/언마운트, 자식 비교, key/anchor 처리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: Reconciliation에서 사용할 DOM 재배치 보조 함수 확인</li>
</ul>
<h4 id="phase-6-기본-hook-시스템"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-6-기본-hook-시스템"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 6: 기본 Hook 시스템</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/hooks.ts</code>: 훅 상태 저장, <code>useState</code>, <code>useEffect</code>, cleanup/queue 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 훅 커서 증가, 방문 경로 기록, 미사용 훅 정리</li>
</ul>
<p><strong>기본 과제 완료 기준</strong>: <code>basic.equals.test.tsx</code>, <code>basic.mini-react.test.tsx</code></p>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<h4 id="phase-7-확장-hook--hoc"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-7-확장-hook--hoc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 7: 확장 Hook &amp; HOC</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useRef.ts</code>: ref 객체 유지</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useMemo.ts</code>, <code>hooks/useCallback.ts</code>: shallow 비교 기반 메모이제이션</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useDeepMemo.ts</code>, <code>hooks/useAutoCallback.ts</code>: deep 비교/자동 콜백 헬퍼</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hocs/memo.ts</code>, <code>hocs/deepMemo.ts</code>: props 비교 기반 컴포넌트 메모이제이션</li>
</ul>
<p><strong>심화 과제 완료 기준</strong>: <code>advanced.hooks.test.tsx</code>, <code>advanced.hoc.test.tsx</code></p>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<h3 id="아하-모먼트-a-ha-moment"><a class="anchor" aria-hidden="true" tabindex="-1" href="#아하-모먼트-a-ha-moment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>아하! 모먼트 (A-ha! Moment)</h3>
<p><strong>Reconciliation의 anchor 메커니즘과 DOM 재배치 로직</strong>:
가장 어려웠던 부분은 key 기반 자식 노드 재배치였습니다. <code>[a, b, c]</code> → <code>[b, c, a]</code>로 변경할 때, <code>b</code>가 첫 번째 위치로 이동해야 하는데 계속 실패했습니다.</p>
<p>처음에는 단순히 <code>nextSibling</code>을 anchor로 사용했지만, 재배치 과정에서 DOM이 아직 이동하지 않은 상태이기 때문에 anchor 계산이 잘못되었습니다.</p>
<p>해결책은 <strong>역순으로 anchor를 계산</strong>하는 것이었습니다:</p>
<ol>
<li><code>nextChildren</code>을 역순으로 순회하면서 각 자식의 anchor를 계산</li>
<li>key가 있는 경우, 기존 위치의 DOM 노드를 먼저 찾아 anchor로 사용</li>
<li>key로 찾지 못한 경우, 재배치 후 위치의 자식 DOM을 anchor로 사용</li>
<li><code>insertBefore</code> 호출 시, <code>currentDom</code>이 이미 <code>anchor.previousSibling</code>이 아니거나, 첫 번째 위치가 아니면 무조건 이동</li>
</ol>
<p>특히 <code>b</code>가 첫 번째로 이동할 때, <code>currentDom.nextSibling === anchor</code>인 경우에도 <code>currentPrevSibling !== null</code>이면 이동해야 한다는 점을 깨달았습니다. 이는 DOM이 이미 올바른 상대 위치에 있어도, 절대 위치가 다르면 이동이 필요하기 때문입니다.</p>
<p><strong>컴포넌트 경로 변경과 상태 마이그레이션</strong>:
<code>Footer</code> 컴포넌트의 상태가 <code>Item</code> 개수 변경 시 유지되지 않는 문제가 있었습니다. 원인은 컴포넌트의 경로(<code>path</code>)가 변경되면 <code>hooks.state</code>와 <code>hooks.cursor</code>가 새 경로에 없어서 상태가 초기화되는 것이었습니다.</p>
<p>처음에는 경로 계산 로직을 수정하려고 했지만, 실제 문제는 <strong>경로 변경 시 상태를 마이그레이션하지 않는 것</strong>이었습니다.</p>
<p>해결책은 <code>updateComponent</code>에서 경로가 변경될 때:</p>
<ol>
<li><code>oldPath</code>에서 <code>hooks.state</code>, <code>hooks.cursor</code>, <code>hooks.visited</code>를 읽어옴</li>
<li><code>newPath</code>로 복사</li>
<li><code>oldPath</code>의 데이터를 삭제</li>
<li><strong>이 작업을 <code>context.hooks.cursor.set(path, 0)</code> 호출 전에 수행</strong></li>
</ol>
<p>이렇게 하면 경로가 변경되어도 컴포넌트의 상태가 유지됩니다.</p>
<p><strong>Fragment의 DOM 노드 수집과 제거</strong>:
<code>{hasChildren &amp;&amp; &lt;&gt;...&lt;/&gt;}</code>에서 <code>hasChildren</code>이 false가 되면 Fragment의 자식들이 제거되어야 하는데, 계속 남아있었습니다.</p>
<p>문제는 <code>getDomNodes</code> 함수가 <code>FRAGMENT</code>와 <code>COMPONENT</code>를 제대로 처리하지 못했던 것입니다. <code>instance.dom</code>을 직접 반환하면 Fragment는 DOM이 없어서 빈 배열이 반환되었습니다.</p>
<p>해결책은 <code>getDomNodes</code>에서:</p>
<ol>
<li><code>FRAGMENT</code>와 <code>COMPONENT</code>는 <code>instance.dom</code>이 없으므로 재귀적으로 자식들의 DOM을 수집</li>
<li><code>NodeTypes.FRAGMENT</code>와 <code>NodeTypes.COMPONENT</code>를 명시적으로 비교 (이전에는 <code>instance.kind === &#x27;FRAGMENT&#x27;</code>로 비교했는데 타입 오류 발생)</li>
<li><code>updateComponent</code>에서 <code>childNode</code>가 null이거나 빈 children일 때, <code>prevChild</code>가 Fragment면 명시적으로 <code>reconcile(parentDom, prevChild, null, path)</code> 호출</li>
</ol>
<p>이렇게 하면 Fragment의 모든 자식 DOM이 재귀적으로 제거됩니다.</p>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<p><strong>Reconciliation 알고리즘의 복잡성 이해</strong>:
이번 과제를 통해 Reconciliation이 단순히 &quot;이전과 현재를 비교&quot;하는 것이 아니라, 여러 전략을 조합해야 한다는 것을 깊이 이해했습니다:</p>
<ol>
<li><strong>Key 기반 매칭</strong>: key가 있으면 key로 먼저 매칭 (최우선)</li>
<li><strong>Path 기반 매칭</strong>: key가 없으면 같은 경로의 인스턴스 재사용</li>
<li><strong>타입 기반 매칭</strong>: 경로도 다르면 같은 타입의 인스턴스 재사용</li>
<li><strong>위치 고려</strong>: 마지막 위치의 경우, 같은 타입의 마지막 자식을 우선 선택</li>
</ol>
<p>또한 anchor를 사용한 DOM 재배치 로직에서:</p>
<ul>
<li>DOM이 아직 이동하지 않은 상태에서 anchor를 계산해야 함</li>
<li>역순 계산이 필요한 이유</li>
<li><code>insertBefore</code>의 동작 원리와 <code>previousSibling</code>의 관계</li>
</ul>
<p><strong>디버깅 전략의 중요성</strong>:
문제가 계속 해결되지 않을 때, &quot;같은 방식으로 계속 시도&quot;하는 것보다는:</p>
<ol>
<li><strong>근본적인 재작성</strong>: reconciliation 로직을 처음부터 다시 작성</li>
<li><strong>상세한 로깅</strong>: 모든 함수에 <code>console.log</code>를 추가해 실행 흐름 추적</li>
<li><strong>단계별 검증</strong>: 각 단계에서 예상값과 실제값을 비교</li>
</ol>
<p>특히 <code>console.log</code>를 전략적으로 배치해, 어떤 함수에서 문제가 발생하는지 정확히 파악한 것이 큰 도움이 되었습니다.</p>
<p><strong>상태 관리와 경로의 관계</strong>:
React의 Hook 시스템이 컴포넌트 경로에 의존한다는 것을 직접 구현하며 이해했습니다:</p>
<ul>
<li>각 컴포넌트 인스턴스는 고유한 경로를 가짐</li>
<li>경로가 변경되면 상태도 함께 마이그레이션해야 함</li>
<li><code>hooks.visited</code>를 사용해 현재 렌더링에서 방문한 컴포넌트만 추적</li>
<li><code>cleanupUnusedHooks</code>에서 방문하지 않은 컴포넌트의 상태를 정리</li>
</ul>
<h3 id="코드-품질"><a class="anchor" aria-hidden="true" tabindex="-1" href="#코드-품질"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>코드 품질</h3>
<p><strong>특히 만족스러운 구현</strong>:</p>
<ul>
<li><strong>anchor 계산 로직</strong>: 역순으로 계산하고, key 기반과 위치 기반을 조합한 로직이 정확하게 작동합니다.</li>
<li><strong>상태 마이그레이션</strong>: 경로 변경 시 상태를 자동으로 마이그레이션하는 로직이 깔끔합니다.</li>
<li><strong>getDomNodes의 재귀적 처리</strong>: Fragment와 Component의 DOM을 재귀적으로 수집하는 로직이 명확합니다.</li>
</ul>
<p><strong>리팩토링이 필요한 부분</strong>:</p>
<ul>
<li><code>reconcile</code> 함수가 1000줄이 넘어 가독성이 떨어집니다. <code>mountHost</code>, <code>updateHost</code>, <code>mountComponent</code>, <code>updateComponent</code> 등을 별도 파일로 분리하면 좋을 것 같습니다.</li>
<li><code>updateHost</code>와 <code>updateFragment</code>의 로직이 거의 동일하므로, 공통 로직을 추출해 중복을 제거할 수 있습니다.</li>
<li>디버깅용 <code>console.log</code>가 많이 남아있어 제거가 필요합니다.</li>
</ul>
<p><strong>코드 설계 관련 고민과 결정</strong>:</p>
<ul>
<li><strong>anchor 파라미터 추가</strong>: DOM 위치를 정확하게 제어하기 위해 <code>reconcile</code> 함수에 anchor 파라미터를 추가했습니다. 이는 재배치 로직을 크게 개선했지만, 함수 시그니처가 복잡해졌습니다.</li>
<li><strong>경로 기반 상태 관리</strong>: 문자열 경로(<code>&quot;0.c0.i1.c2&quot;</code>)를 사용해 계층 구조를 표현했습니다. 디버깅에 유용하지만, 경로 변경 시 마이그레이션이 필요해 복잡도가 증가했습니다.</li>
<li><strong>타입 비교 방식</strong>: <code>NodeTypes.FRAGMENT</code>와 같은 상수를 사용해 타입을 비교했습니다. 이는 타입 안정성을 높이지만, 런타임 비교가 필요합니다.</li>
</ul>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p><strong>가장 큰 배움이 있었던 부분</strong>:</p>
<ol>
<li><strong>Reconciliation의 복잡성</strong>: 단순해 보이지만 실제로는 key 매칭, path 매칭, 타입 매칭, anchor 계산 등 여러 전략을 조합해야 합니다.</li>
<li><strong>DOM 조작의 정확성</strong>: <code>insertBefore</code>와 <code>removeChild</code>를 사용할 때, 노드의 현재 위치와 부모를 정확히 확인해야 합니다.</li>
<li><strong>상태 마이그레이션의 필요성</strong>: 경로가 변경되면 상태도 함께 이동해야 한다는 점을 직접 구현하며 이해했습니다.</li>
</ol>
<p><strong>추가 학습이 필요한 영역</strong>:</p>
<ul>
<li><strong>React Fiber의 스케줄링</strong>: 현재는 마이크로태스크 큐를 사용했지만, React Fiber의 우선순위 기반 스케줄링을 학습하면 더 효율적일 것입니다.</li>
<li><strong>성능 최적화</strong>: 현재는 기본적인 최적화만 수행하므로, 메모이제이션 범위 확대, 가상화(virtualization) 등을 추가로 학습하면 좋을 것 같습니다.</li>
<li><strong>타입 시스템 개선</strong>: <code>any</code> 타입을 사용하는 부분을 더 엄격한 타입으로 개선할 수 있을 것 같습니다.</li>
</ul>
<p><strong>실무 적용 가능성</strong>:</p>
<ul>
<li>Virtual DOM과 Reconciliation 개념은 React뿐만 아니라 Vue, Svelte 등 다른 프레임워크에서도 유사하게 사용되므로, 이번 학습이 프레임워크 이해에 도움이 될 것입니다.</li>
<li>Hook 시스템의 구현 원리를 이해하면, 커스텀 훅을 더 효과적으로 작성하고, 훅의 동작을 예측할 수 있을 것입니다.</li>
<li>디버깅 전략(로깅, 단계별 검증)은 실무에서도 유용할 것입니다.</li>
</ul>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p><strong>과제에서 모호하거나 애매했던 부분</strong>:</p>
<ul>
<li><code>createChildPath</code> 함수의 <code>siblings</code> 파라미터: 실제로는 사용되지 않았는데, 시그니처에 포함되어 있어 혼란스러웠습니다.</li>
<li>Fragment의 children이 빈 배열일 때의 처리: <code>{hasChildren &amp;&amp; &lt;&gt;...&lt;/&gt;}</code>에서 <code>hasChildren</code>이 false일 때 Fragment가 null이 되어야 하는지, 빈 Fragment로 처리해야 하는지 명확하지 않았습니다. 테스트를 통해 null이 되어야 함을 확인했습니다.</li>
<li>anchor 계산의 정확한 시점: 재배치 과정에서 anchor를 언제 계산해야 하는지, DOM이 이동하기 전인지 후인지 명확하지 않았습니다.</li>
</ul>
<p><strong>과제에서 좋았던 부분</strong>:</p>
<ul>
<li>단계별 구현 가이드가 명확해서, 각 Phase를 순차적으로 진행할 수 있었습니다.</li>
<li>테스트 코드가 상세해서, 각 기능의 동작을 정확하게 검증할 수 있었습니다. 특히 실패한 테스트의 오류 메시지가 명확해서 디버깅에 도움이 되었습니다.</li>
<li>Reconciliation의 복잡한 로직을 단계적으로 구현할 수 있도록 잘 구성되어 있었습니다.</li>
</ul>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<p><strong>Reconciliation 로직의 구조 개선 방안</strong>:
현재 <code>reconcile</code> 함수가 1000줄이 넘어 가독성이 떨어집니다. <code>mountHost</code>, <code>updateHost</code>, <code>mountComponent</code>, <code>updateComponent</code> 등을 별도 파일로 분리하는 것이 좋을까요? 아니면 현재처럼 하나의 파일에 유지하는 것이 더 나을까요?</p>
<p>또한 <code>updateHost</code>와 <code>updateFragment</code>의 로직이 거의 동일한데, 공통 로직을 추출해 중복을 제거할 수 있을까요? 어떤 방식으로 리팩토링하면 좋을지 조언해주실 수 있을까요?</p>
<p><strong>컴포넌트 경로 관리 전략</strong>:
현재 컴포넌트 경로를 문자열(<code>&quot;0.c0.i1.c2&quot;</code>)로 표현하고 있는데, 경로 변경 시 상태 마이그레이션이 필요합니다. 더 효율적인 경로 관리 방식이 있을까요?</p>
<p>예를 들어:</p>
<ul>
<li>경로 객체를 사용해 타입 안정성을 높이는 방법</li>
<li>경로 변경을 자동으로 감지해 마이그레이션하는 로직을 추가하는 방법</li>
<li>경로 대신 다른 식별자(예: 고유 ID)를 사용하는 방법</li>
</ul>
<p>어떤 방식이 더 나을지 조언해주실 수 있을까요?</p>
<p><strong>anchor 계산 로직의 최적화</strong>:
현재 anchor 계산 로직이 복잡하고, 역순 순회를 사용하고 있습니다. 더 효율적이거나 명확한 방법이 있을까요?</p>
<p>특히 key 기반 재배치에서:</p>
<ul>
<li>기존 위치의 DOM을 찾는 로직</li>
<li>재배치 후 위치의 DOM을 찾는 로직</li>
<li><code>insertBefore</code> 호출 조건</li>
</ul>
<p>이 부분들을 더 간결하게 표현할 수 있는 방법이 있을까요?</p>
<p><strong>타입 안정성 개선</strong>:
현재 <code>any</code> 타입을 일부 사용하고 있는데, 더 엄격한 타입 정의로 개선할 수 있을까요?</p>
<p>특히:</p>
<ul>
<li><code>normalizeNode</code> 함수에서 <code>any</code>를 사용하는 부분</li>
<li><code>createElement</code>의 children 타입</li>
<li>VNode의 type이 <code>string | symbol | React.ComponentType</code>인데, 이를 더 구체적으로 타입화할 수 있는 방법</li>
</ul>
<p>이런 부분들을 어떻게 개선하면 좋을지 조언해주실 수 있을까요?</p>
<p><strong>디버깅 전략</strong>:
문제가 계속 해결되지 않을 때, <code>console.log</code>를 추가해 디버깅하는 방식 외에 더 효과적인 방법이 있을까요?</p>
<p>예를 들어:</p>
<ul>
<li>브레이크포인트를 사용한 디버깅</li>
<li>테스트 코드에 더 상세한 검증 로직 추가</li>
<li>시각화 도구 사용</li>
</ul>
<p>어떤 방식이 더 효율적일지 조언해주실 수 있을까요?</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>수고했어요 태준! 기본 과제랑 심화 과제 모두 잘 해냈네요. 회고가 정말 상세하네요. 잘 봤습니다! 멋지네요</p>
<p>Q) 현재 reconcile 함수가 1000줄이 넘어 가독성이 떨어집니다. mountHost, updateHost, mountComponent, updateComponent 등을 별도 파일로 분리하는 것이 좋을까요? 아니면 현재처럼 하나의 파일에 유지하는 것이 더 나을까요?
=&gt; reconcile 함수 1000줄 문제는, 분리하는 게 맞아요. mountHost, updateHost, mountComponent, updateComponent를 별도 함수로 빼면 각각의 책임이 명확해지고 테스트도 쉬워집니다. 한 파일에 둘지 여러 파일로 나눌지는 취향인데, 저는 한 파일에 여러 함수로 분리하는 걸 선호해요. 애초에 태준도 1000줄이 넘어 가독성이 떨어지고 있다고 인지했으니 분리를 하는 편이 좋겠죠? import/export 오버헤드 없이 흐름을 따라가기 쉽거든요.</p>
<p>Q) 현재 컴포넌트 경로를 문자열(&quot;0.c0.i1.c2&quot;)로 표현하고 있는데, 경로 변경 시 상태 마이그레이션이 필요합니다. 더 효율적인 경로 관리 방식이 있을까요?
=&gt; 전체적으로 어떻게 하는게 이해가 되었다면 React는 실제로 어떻게 하고 있을까? 하면 살펴보시면 좋겠습니다. 우리에겐 정답지가 있으니까요. React Fiber는 경로 문자열이 아니라 <strong>Fiber 노드 자체에 상태를 저장</strong>해요. 각 컴포넌트 인스턴스가 Fiber 노드로 표현되고, 그 노드의 memoizedState 필드에 훅 상태가 linked list로 들어있습니다. &quot;React Fiber memoizedState&quot;로 한번 찾아보면서 왜 이렇게 설계를 했을지 이해해보길 바래요.</p>
<p>Q) 현재 any 타입을 일부 사용하고 있는데, 더 엄격한 타입 정의로 개선할 수 있을까요?
=&gt; 네 있습니다. any 타입 개선은 점진적으로 하면 돼요. 급하게 다 바꾸려 하지 말고, 버그가 발생하거나 리팩토링할 때 해당 부분만 타입을 강화하는 방식이 실무적입니다.</p>
<p>Q) 문제가 계속 해결되지 않을 때, console.log를 추가해 디버깅하는 방식 외에 더 효과적인 방법이 있을까요?
=&gt; 설명해주고 싶지만 효과는 설명한다고 해서 되는 부분이 아닌 것 같아요. 작성해준 degguer나 브레이크 포인트, 시각화나 devtools 모두 각자의 이유가 있으니까요. 이건 문제마다 다른거라서 그냥 몸소 겪으면서 노하우를 찾는 수 밖에 없어요. 제가 말로 알려주는건 한계가 있고 AI에게 물어봐도 경험하지 않으면 텍스트만으로 알 수 있는 건 한계가 있으니까요. console.log 외의 방법이 있다는건 태준이 알고 있으니 다양하게 시도를 해보면서 적절한 도구의 쓰임새를 꺠쳐보길 바래요.</p>
<p>이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 태준이는 그 과정을 정말 깊이 있게 경험했네요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 된다는 걸 이번에 배웠기를 바랍니다.</p>
<p>다음 챕터는 설계입니다! 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[5팀 오태준] Chapter 2-2. 나만의 React 만들기 - 오태준 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 오태준님이 제출한 [5팀 오태준] Chapter 2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 오태준, [5팀 오태준] Chapter 2-2. 나만의 React 만들기, 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[5팀 오태준] Chapter 2-2. 나만의 React 만들기 - 오태준 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 오태준님이 제출한 [5팀 오태준] Chapter 2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[5팀 오태준] Chapter 2-2. 나만의 React 만들기 - 오태준 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 오태준님이 제출한 [5팀 오태준] Chapter 2-2. 나만의 React 만들기 과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
