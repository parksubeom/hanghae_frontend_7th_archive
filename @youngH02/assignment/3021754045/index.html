<div data-slot="sidebar-wrapper" style="--sidebar-width:16rem;--sidebar-width-icon:3rem" class="group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full"><div class="min-h-screen flex w-full"><div class="group peer text-sidebar-foreground hidden md:block" data-state="expanded" data-collapsible="" data-variant="sidebar" data-side="left" data-slot="sidebar"><div data-slot="sidebar-gap" class="relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear group-data-[collapsible=offcanvas]:w-0 group-data-[side=right]:rotate-180 group-data-[collapsible=icon]:w-(--sidebar-width-icon)"></div><div data-slot="sidebar-container" class="fixed inset-y-0 z-10 hidden h-svh transition-[left,right,width] duration-200 ease-linear md:flex left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)] group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l w-64"><div data-sidebar="sidebar" data-slot="sidebar-inner" class="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"><div data-slot="sidebar-content" data-sidebar="content" class="flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden bg-card border-r border-border"><a class="p-4" href="/front_7th/" data-discover="true"><div class="flex items-center space-x-2 mb-6"><div class="w-8 h-8 bg-gradient-primary rounded-lg flex items-center justify-center"><span class="text-white font-bold text-sm">7기</span></div><h4 class="text-lg font-bold text-primary">항해플러스 프론트엔드</h4></div></a><div data-slot="sidebar-group" data-sidebar="group" class="relative flex w-full min-w-0 flex-col p-2"><div data-slot="sidebar-group-label" data-sidebar="group-label" class="ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0 text-muted-foreground px-4">학습 관리</div><div data-slot="sidebar-group-content" data-sidebar="group-content" class="w-full text-sm"><ul data-slot="sidebar-menu" data-sidebar="menu" class="flex w-full min-w-0 flex-col gap-1 px-2"><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-users h-5 w-5" aria-hidden="true"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path><path d="M16 3.128a4 4 0 0 1 0 7.744"></path><path d="M22 21v-2a4 4 0 0 0-3-3.87"></path><circle cx="9" cy="7" r="4"></circle></svg><span class="ml-3">수강생 목록</span></a></li><li data-slot="sidebar-menu-item" data-sidebar="menu-item" class="group/menu-item relative"><a data-slot="sidebar-menu-button" data-sidebar="menu-button" data-size="default" data-active="false" class="peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left outline-hidden ring-sidebar-ring transition-[width,height,padding] focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&amp;&gt;span:last-child]:truncate [&amp;&gt;svg]:size-4 [&amp;&gt;svg]:shrink-0 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground text-sm h-12 text-foreground hover:bg-secondary hover:text-secondary-foreground rounded-lg transition-all duration-300" href="/front_7th/assignments/" data-discover="true"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-book-open h-5 w-5" aria-hidden="true"><path d="M12 7v14"></path><path d="M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"></path></svg><span class="ml-3">과제 목록</span></a></li></ul></div></div></div></div></div></div><div class="flex-1 min-w-0"><header class="h-12 flex items-center border-b border-border bg-card px-4"><button data-slot="sidebar-trigger" class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50 size-7 mr-4 text-white" data-sidebar="trigger"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-panel-left" aria-hidden="true"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 3v18"></path></svg><span class="sr-only">Toggle Sidebar</span></button><h4 class="text-lg font-semibold "><a href="/front_7th/@youngH02/" data-discover="true">youngH02<!-- --> 님의 상세페이지</a> ＞ <!-- -->[4팀 박지영] Chapter2-2. 나만의 React 만들기 </h4></header><main class="p-6"><div><div class="card-wrap"><div data-slot="card" class="card text-card-foreground flex flex-col gap-6 shadow-sm mb-6 p-6 border border-gray-700 bg-gray-800 rounded-lg"><a href="https://github.com/hanghae-plus/front_7th_chapter2-2/pull/50" target="_blank"><div class="flex items-start gap-4"><div class="flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" height="32" aria-hidden="true" viewBox="0 0 24 24" width="32" fill="white" class="w-8 h-8"><path d="M12 1C5.923 1 1 5.923 1 12c0 4.867 3.149 8.979 7.521 10.436.55.096.756-.233.756-.522 0-.262-.013-1.128-.013-2.049-2.764.509-3.479-.674-3.699-1.292-.124-.317-.66-1.293-1.127-1.554-.385-.207-.936-.715-.014-.729.866-.014 1.485.797 1.691 1.128.99 1.663 2.571 1.196 3.204.907.096-.715.385-1.196.701-1.471-2.448-.275-5.005-1.224-5.005-5.432 0-1.196.426-2.186 1.128-2.956-.111-.275-.496-1.402.11-2.915 0 0 .921-.288 3.024 1.128a10.193 10.193 0 0 1 2.75-.371c.936 0 1.871.123 2.75.371 2.104-1.43 3.025-1.128 3.025-1.128.605 1.513.221 2.64.111 2.915.701.77 1.127 1.747 1.127 2.956 0 4.222-2.571 5.157-5.019 5.432.399.344.743 1.004.743 2.035 0 1.471-.014 2.654-.014 3.025 0 .289.206.632.756.522C19.851 20.979 23 16.854 23 12c0-6.077-4.922-11-11-11Z"></path></svg></div><div class="flex-1 min-w-0"><div class="flex items-center gap-2 mb-2"><h3 class="text-lg font-semibold text-white truncate">[4팀 박지영] Chapter2-2. 나만의 React 만들기 </h3></div><div class="flex items-center gap-4 text-xs text-gray-500"><span>by <!-- -->youngH02</span><span>2025.11.18</span></div></div></div></a></div></div><div class="overflow-auto"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-체크포인트"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-체크포인트"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 체크포인트</h2>
<h3 id="배포-링크"><a class="anchor" aria-hidden="true" tabindex="-1" href="#배포-링크"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>배포 링크</h3>
<p><a href="https://youngh02.github.io/front_7th_chapter2-2/">https://youngh02.github.io/front_7th_chapter2-2/</a></p>
<h3 id="기본과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기본과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기본과제</h3>
<h4 id="phase-1-vnode와-기초-유틸리티"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-1-vnode와-기초-유틸리티"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 1: VNode와 기초 유틸리티</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/elements.ts</code>: <code>createElement</code>, <code>normalizeNode</code>, <code>createChildPath</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/validators.ts</code>: <code>isEmptyValue</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/equals.ts</code>: <code>shallowEquals</code>, <code>deepEquals</code></li>
</ul>
<h4 id="phase-2-컨텍스트와-루트-초기화"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-2-컨텍스트와-루트-초기화"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 2: 컨텍스트와 루트 초기화</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/types.ts</code>: VNode/Instance/Context 타입 선언</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 루트/훅 컨텍스트와 경로 스택 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/setup.ts</code>: 컨테이너 초기화, 컨텍스트 리셋, 루트 렌더 트리거</li>
</ul>
<h4 id="phase-3-dom-인터페이스-구축"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-3-dom-인터페이스-구축"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 3: DOM 인터페이스 구축</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: 속성/스타일/이벤트 적용 규칙, DOM 노드 탐색/삽입/제거</li>
</ul>
<h4 id="phase-4-렌더-스케줄링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-4-렌더-스케줄링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 4: 렌더 스케줄링</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>utils/enqueue.ts</code>: <code>enqueue</code>, <code>withEnqueue</code>로 마이크로태스크 큐 구성</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/render.ts</code>: <code>render</code>, <code>enqueueRender</code>로 루트 렌더 사이클 구현</li>
</ul>
<h4 id="phase-5-reconciliation"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-5-reconciliation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 5: Reconciliation</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/reconciler.ts</code>: 마운트/업데이트/언마운트, 자식 비교, key/anchor 처리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/dom.ts</code>: Reconciliation에서 사용할 DOM 재배치 보조 함수 확인</li>
</ul>
<h4 id="phase-6-기본-hook-시스템"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-6-기본-hook-시스템"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 6: 기본 Hook 시스템</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/hooks.ts</code>: 훅 상태 저장, <code>useState</code>, <code>useEffect</code>, cleanup/queue 관리</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>core/context.ts</code>: 훅 커서 증가, 방문 경로 기록, 미사용 훅 정리</li>
</ul>
<p><strong>기본 과제 완료 기준</strong>: <code>basic.equals.test.tsx</code>, <code>basic.mini-react.test.tsx</code> 전부 통과</p>
<h3 id="심화과제"><a class="anchor" aria-hidden="true" tabindex="-1" href="#심화과제"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>심화과제</h3>
<h4 id="phase-7-확장-hook--hoc"><a class="anchor" aria-hidden="true" tabindex="-1" href="#phase-7-확장-hook--hoc"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Phase 7: 확장 Hook &amp; HOC</h4>
<ul class="contains-task-list">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useRef.ts</code>: ref 객체 유지</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useMemo.ts</code>, <code>hooks/useCallback.ts</code>: shallow 비교 기반 메모이제이션</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hooks/useDeepMemo.ts</code>, <code>hooks/useAutoCallback.ts</code>: deep 비교/자동 콜백 헬퍼</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""/> <code>hocs/memo.ts</code>, <code>hocs/deepMemo.ts</code>: props 비교 기반 컴포넌트 메모이제이션</li>
</ul>
<h2 id="과제-셀프회고"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-셀프회고"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 셀프회고</h2>
<p>과제 시작 시 막막함을 느껴 easy 난이도의 Virtual DOM 구현부터 시작했는데, 이 접근이 전체 구조를 이해하는 데 도움이 되었습니다. 처음 시작이 되니 그래도..방향을 잡기 수월했습니다. 초반 Phase들(VNode, Context, DOM 조작)은 어느 정도 이해하며 구현할 수 있었지만, Hooks 부분으로 갈수록 커서 기반 상태 관리와 클로저 활용이 복잡하게 느껴졌습니다. 특히 hooks들의 실행 타이밍과 의존성 배열 비교 로직은 여전히 어려워 추가로 살펴볼 예정입니다. 그래도 React의 내부 동작 원리를 직접 구현하며 아주 조금 React를 알게된 것 같습니다...</p>
<h3 id="아하-모먼트-a-ha-moment"><a class="anchor" aria-hidden="true" tabindex="-1" href="#아하-모먼트-a-ha-moment"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>아하! 모먼트 (A-ha! Moment)</h3>
<p><strong>1. React가 불변성을 강조하는 이유</strong></p>
<ul>
<li><strong>shallowEquals</strong>: 1단계 속성의 참조만 비교 (빠름)</li>
<li><strong>deepEquals</strong>: 모든 깊이 재귀적으로 비교 (느림)</li>
<li><strong>불변성을 지키면</strong>: 상태 변경 시 새 객체 생성 → 참조가 바뀜 → shallow 비교로 변경 감지 가능</li>
<li><strong>불변성을 안 지키면</strong>: 기존 객체 수정 → 참조가 같음 → shallow 비교로 변경 감지 불가 → deep 비교 필요 (느림)</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 불변성 지킴 </span>
</span><span class="code-line"><span class="token keyword">const</span> oldState <span class="token operator">=</span> <span class="token punctuation">{</span> user<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;React&quot;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token keyword">const</span> newState <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>oldState<span class="token punctuation">,</span> user<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span>oldState<span class="token punctuation">.</span>user<span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">11</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">shallowEquals</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false (user 참조가 바뀜 → 변경 감지!)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 불변성 안 지킴 ❌</span>
</span><span class="code-line"><span class="token keyword">const</span> oldState2 <span class="token operator">=</span> <span class="token punctuation">{</span> user<span class="token operator">:</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;React&quot;</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line">oldState2<span class="token punctuation">.</span>user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment">// 기존 객체 수정</span>
</span><span class="code-line"><span class="token function">shallowEquals</span><span class="token punctuation">(</span>oldState2<span class="token punctuation">,</span> oldState2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true (참조 같음 → 변경 감지 불가!)</span>
</span></code><div class="copied" data-code="// 불변성 지킴 
const oldState = { user: { name: &quot;React&quot;, age: 10 } };
const newState = { ...oldState, user: { ...oldState.user, age: 11 } };
shallowEquals(oldState, newState); // false (user 참조가 바뀜 → 변경 감지!)

// 불변성 안 지킴 ❌
const oldState2 = { user: { name: &quot;React&quot;, age: 10 } };
oldState2.user.age = 11; // 기존 객체 수정
shallowEquals(oldState2, oldState2); // true (참조 같음 → 변경 감지 불가!)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>2. Hook은 호출 순서로 관리된다</strong></p>
<p>Hook은 변수명이 아니라 <strong>배열 인덱스</strong>로 상태를 식별합니다. 따라서:</p>
<ul>
<li>조건부 호출 시 인덱스가 꼬여서 잘못된 상태 반환</li>
<li><strong>클로저</strong>로 setState가 생성 시점의 인덱스를 기억</li>
<li>&quot;Hook은 최상위에서만 호출&quot; 규칙의 근본적 이유를 이해함</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 잘못된 사용: 조건부 Hook 호출</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 인덱스 0</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 인덱스 1 (조건부!)</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 인덱스 1 또는 2?</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 첫 렌더링 (count = 0)</span>
</span><span class="code-line"><span class="token comment">// useState(0) → 인덱스 0에 저장</span>
</span><span class="code-line"><span class="token comment">// if 문 스킵</span>
</span><span class="code-line"><span class="token comment">// useState(20) → 인덱스 1에 저장</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 두 번째 렌더링 (count = 1)</span>
</span><span class="code-line"><span class="token comment">// useState(0) → 인덱스 0 읽음 ✅</span>
</span><span class="code-line"><span class="token comment">// useState(&quot;&quot;) → 인덱스 1 읽음 ❌ (20이 나옴!)</span>
</span><span class="code-line"><span class="token comment">// useState(20) → 인덱스 2 읽음 ❌ (undefined!)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 올바른 사용: 항상 같은 순서로 호출</span>
</span><span class="code-line"><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">  
</span><span class="code-line">  <span class="token comment">// 조건부로 사용하되, 호출 순서는 유지</span>
</span><span class="code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line">    <span class="token comment">// name 사용</span>
</span><span class="code-line">  <span class="token punctuation">}</span>
</span><span class="code-line"><span class="token punctuation">}</span>
</span></code><div class="copied" data-code="// 잘못된 사용: 조건부 Hook 호출
function Counter() {
  const [count, setCount] = useState(0); // 인덱스 0
  
  if (count &gt; 0) {
    const [name, setName] = useState(&quot;&quot;); // 인덱스 1 (조건부!)
  }
  
  const [age, setAge] = useState(20); // 인덱스 1 또는 2?
}

// 첫 렌더링 (count = 0)
// useState(0) → 인덱스 0에 저장
// if 문 스킵
// useState(20) → 인덱스 1에 저장

// 두 번째 렌더링 (count = 1)
// useState(0) → 인덱스 0 읽음 ✅
// useState(&quot;&quot;) → 인덱스 1 읽음 ❌ (20이 나옴!)
// useState(20) → 인덱스 2 읽음 ❌ (undefined!)

// 올바른 사용: 항상 같은 순서로 호출
function Counter() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState(&quot;&quot;);
  const [age, setAge] = useState(20);
  
  // 조건부로 사용하되, 호출 순서는 유지
  if (count &gt; 0) {
    // name 사용
  }
}
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>3. Attribute vs Property의 차이</strong></p>
<ul>
<li><strong>Attribute</strong>: HTML 문서에 쓰인 초기값 (<code>setAttribute</code>)</li>
<li><strong>Property</strong>: JavaScript 객체의 현재 값 (<code>dom.value = ...</code>)</li>
<li><code>value</code>, <code>checked</code> 등은 <strong>property로 설정해야 실제 값이 변경됨</strong></li>
<li>이를 놓쳐서 URL 복원 시 input에 값이 안 나타나는 문제가 있었고, property로 수정하여 해결</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 잘못된 방법: setAttribute 사용</span>
</span><span class="code-line"><span class="token keyword">const</span> input <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#x27;input&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">input<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">&#x27;value&#x27;</span><span class="token punctuation">,</span> <span class="token string">&#x27;젤리&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>input<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;&quot; (빈 문자열! 실제 값은 안 바뀜)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 올바른 방법: property 직접 설정</span>
</span><span class="code-line"><span class="token keyword">const</span> input2 <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#x27;input&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">input2<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&#x27;젤리&#x27;</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>input2<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;젤리&quot; (실제 값 변경됨!)</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token operator">&lt;</span>input value<span class="token operator">=</span><span class="token punctuation">{</span>searchQuery<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">// value는 property로 처리해야 함</span>
</span></code><div class="copied" data-code="// 잘못된 방법: setAttribute 사용
const input = document.createElement(&#x27;input&#x27;);
input.setAttribute(&#x27;value&#x27;, &#x27;젤리&#x27;);
console.log(input.value); // &quot;&quot; (빈 문자열! 실제 값은 안 바뀜)

// 올바른 방법: property 직접 설정
const input2 = document.createElement(&#x27;input&#x27;);
input2.value = &#x27;젤리&#x27;;
console.log(input2.value); // &quot;젤리&quot; (실제 값 변경됨!)

&lt;input value={searchQuery} /&gt; // value는 property로 처리해야 함
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p><strong>4. queueMicrotask로 렌더링 배치 처리</strong></p>
<ul>
<li>동기 코드 실행 → Microtask (렌더링) → Macrotask 순서</li>
<li>여러 setState 호출을 한 번의 렌더링으로 배치 처리</li>
<li>React의 Automatic Batching 동작 원리를 이해함</li>
</ul>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token comment">// 여러 setState 호출</span>
</span><span class="code-line"><span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;React&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line"><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// queueMicrotask로 배치 처리</span>
</span><span class="code-line"><span class="token comment">// → 동기 코드 모두 실행 완료 후</span>
</span><span class="code-line"><span class="token comment">// → 한 번의 렌더링으로 모든 상태 업데이트 반영</span>
</span><span class="code-line">
</span><span class="code-line"><span class="token comment">// 실행 순서:</span>
</span><span class="code-line"><span class="token comment">// 1. setState 호출들 (동기)</span>
</span><span class="code-line"><span class="token comment">// 2. 렌더링 (microtask) ← 한 번만 실행!</span>
</span><span class="code-line"><span class="token comment">// 3. setTimeout 등 (macrotask)</span>
</span></code><div class="copied" data-code="// 여러 setState 호출
setCount(1);
setName(&quot;React&quot;);
setAge(10);

// queueMicrotask로 배치 처리
// → 동기 코드 모두 실행 완료 후
// → 한 번의 렌더링으로 모든 상태 업데이트 반영

// 실행 순서:
// 1. setState 호출들 (동기)
// 2. 렌더링 (microtask) ← 한 번만 실행!
// 3. setTimeout 등 (macrotask)
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<h3 id="기술적-성장"><a class="anchor" aria-hidden="true" tabindex="-1" href="#기술적-성장"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>기술적 성장</h3>
<p><strong>핵심 개념 학습</strong></p>
<ol>
<li><strong>Reconciliation</strong>: 타입 비교 → DOM 재사용 여부 결정 → 속성만 업데이트 → DOM 조작 최소화</li>
<li><strong>커서 기반 Hook 관리</strong>: <code>Map&lt;컴포넌트경로, Hook배열&gt;</code>로 각 컴포넌트의 상태를 독립적으로 관리</li>
<li><strong>클로저 활용</strong>: setState가 생성 시점의 인덱스를 기억하여 나중에 호출해도 정확한 상태 업데이트</li>
<li><strong>Property vs Attribute</strong>: input의 <code>value</code>는 property로 설정해야 실제 값 변경</li>
</ol>
<p><strong>만족스러운 구현</strong></p>
<ol>
<li><strong>context.ts getter 패턴</strong>: 스택이 비어있을 때 명확한 에러 제공 (&quot;훅은 컴포넌트 내부에서만 호출&quot;)</li>
<li><strong>withEnqueue 클로저</strong>: <code>scheduled</code> 플래그를 클로저로 캡슐화하여 배치 렌더링 구현</li>
<li><strong>커서와 상태 분리</strong>: cursor(순서 추적)와 state(값 저장)를 분리하여 매 렌더링마다 cursor만 초기화</li>
</ol>
<h3 id="학습-효과-분석"><a class="anchor" aria-hidden="true" tabindex="-1" href="#학습-효과-분석"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>학습 효과 분석</h3>
<p><strong>React Rules의 근본적 이유를 이해함</strong></p>






























<table><thead><tr><th>규칙</th><th>이전</th><th>이후 (구현 후)</th></tr></thead><tbody><tr><td>Hook 최상위 호출</td><td>ESLint가 시키니까</td><td>커서 기반이라 순서 바뀌면 상태 꼬임</td></tr><tr><td>key 사용</td><td>경고 안 뜨게</td><td>경로 생성 시 리스트 재정렬에도 상태 유지</td></tr><tr><td>의존성 배열 정확히</td><td>습관적으로</td><td>shallowEquals 비교라 누락 시 effect 미실행</td></tr><tr><td>불변성 유지</td><td>권장사항</td><td>shallow 비교가 빠르므로 참조만 바꾸면 됨</td></tr></tbody></table>
<h3 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h3>
<p><strong>과제에서 좋았던 부분</strong></p>
<ol>
<li>단계별 구성: Reade.md에 순서가 정리되어 있어 따라가기 좋았습니다. VNode 정규화 → Context 관리 → DOM 조작 → 렌더 스케줄링 → Reconciliation → Hooks 순서로 자연스럽게 학습할 수 있었습니다.</li>
<li>테스트 주도 학습: 각 Phase마다 테스트가 제공되어, 구현이 올바른지 즉시 확인할 수 있었습니다.</li>
<li>주석과 가이드: 각 함수에 &quot;여기를 구현하세요&quot;와 함께 단계별 힌트가 있어서, 막막하지 않고 차근차근 진행할 수 있었습니다.</li>
</ol>
<p><strong>과제에서 모호하거나 애매했던 부분</strong></p>
<ol>
<li><strong>createChildPath의 inferredIndex</strong>: siblings를 필터링해서 같은 타입의 인덱스를 계산하는 로직이 처음에는 이해하기 어려웠습니다. 왜 이렇게 복잡하게 계산하는지 예시가 더 있었으면 좋았을 것 같습니다.</li>
<li><strong>Fragment 처리</strong>: Fragment가 DOM에 추가되면 사라진다는 특성 때문에, insertInstance와 removeInstance에서 어떻게 처리해야 할지 고민이 많았습니다. Fragment의 생명주기에 대한 설명이 더 있었으면 좋았을 것 같습니다.</li>
<li><strong>Effect 실행 타이밍</strong>: useEffect가 렌더링 후 비동기로 실행된다는 것은 알았지만, 정확히 언제 cleanup이 실행되고 언제 새 effect가 실행되는지 순서가 헷갈렸습니다. 타임라인 다이어그램이 있었다면 더 좋았을 것 같습니다.</li>
</ol>
<h2 id="리뷰-받고-싶은-내용"><a class="anchor" aria-hidden="true" tabindex="-1" href="#리뷰-받고-싶은-내용"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>리뷰 받고 싶은 내용</h2>
<h3 id="1-dom-property-처리-범위"><a class="anchor" aria-hidden="true" tabindex="-1" href="#1-dom-property-처리-범위"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. DOM Property 처리 범위</h3>
<p>현재 <code>value</code>, <code>checked</code>, <code>disabled</code>, <code>readOnly</code>, <code>selected</code>를 property로 처리하고 있습니다. 추가로 property로 처리해야 하는 속성이 있을까요? (예: <code>indeterminate</code>, <code>scrollTop</code>, <code>selectedIndex</code> 등)</p>
<h3 id="2-reconcile-함수-리팩토링"><a class="anchor" aria-hidden="true" tabindex="-1" href="#2-reconcile-함수-리팩토링"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. reconcile 함수 리팩토링</h3>
<p>약 150줄의 <code>reconcile</code> 함수를 타입별로 분리(<code>reconcileTextNode</code>, <code>reconcileFragment</code> 등)하는 것이 좋을지, 아니면 현재처럼 한 함수에서 처리하는 것이 전체 흐름 파악에 더 나은지 궁금합니다.</p>
<h3 id="3-createchildpath의-inferredindex-계산-로직"><a class="anchor" aria-hidden="true" tabindex="-1" href="#3-createchildpath의-inferredindex-계산-로직"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. createChildPath의 inferredIndex 계산 로직</h3>
<pre class="language-typescript"><code class="language-typescript code-highlight"><span class="code-line"><span class="token keyword">const</span> inferredIndex <span class="token operator">=</span>
</span><span class="code-line">  key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>siblings <span class="token operator">?</span> index <span class="token operator">:</span> siblings<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sibling<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> sibling<span class="token operator">?.</span>type <span class="token operator">===</span> nodeType<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</span></code><div class="copied" data-code="const inferredIndex =
  key != null || !siblings ? index : siblings.slice(0, index).filter((sibling) =&gt; sibling?.type === nodeType).length;
"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
<p>같은 타입의 컴포넌트들 사이에서만 인덱스를 계산하는 이유가 무엇인가요? 전체 siblings 배열의 index를 사용하는 것과 비교했을 때 어떤 장단점이 있나요?</p>
<h3 id="4-fragment의-dom-처리-방식"><a class="anchor" aria-hidden="true" tabindex="-1" href="#4-fragment의-dom-처리-방식"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>4. Fragment의 DOM 처리 방식</h3>
<p>Fragment가 DOM에 추가되면 사라진다는 특성 때문에 <code>insertInstance</code>와 <code>removeInstance</code>에서 어떻게 처리해야 할지 고민이 많았습니다. Fragment의 생명주기를 더 명확하게 처리할 방법이 있을까요?</p>
<h3 id="5-useeffect-cleanup-실행-타이밍"><a class="anchor" aria-hidden="true" tabindex="-1" href="#5-useeffect-cleanup-실행-타이밍"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>5. useEffect cleanup 실행 타이밍</h3>
<p>현재 구현에서는 의존성이 변경되면 이전 cleanup을 동기적으로 실행한 후 새 effect를 큐에 추가합니다. 이 순서가 실제 React의 동작과 일치하는지, 특히 cleanup이 동기적으로 실행되는 것이 맞는지 궁금합니다.</p>
<ol>
<li>이전 cleanup 함수 실행</li>
<li>새 effect 함수를 큐에 추가</li>
<li>렌더링 완료 후 큐의 effect 실행</li>
</ol>
<h3 id="6-전역-context-vs-인스턴스-context"><a class="anchor" aria-hidden="true" tabindex="-1" href="#6-전역-context-vs-인스턴스-context"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>6. 전역 context vs 인스턴스 context</h3>
<p>현재 전역 <code>context</code> 객체를 사용 중인데, 실무에서 여러 React 루트를 지원하려면 각 루트마다 별도 context 인스턴스를 생성해야 할까요?</p></div></div><div class="overflow-auto mt-9"><div data-color-mode="dark" class="wmde-markdown wmde-markdown-color p-6 max-w-full" style="word-wrap:break-word;overflow-wrap:break-word"><h2 id="과제-피드백"><a class="anchor" aria-hidden="true" tabindex="-1" href="#과제-피드백"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>과제 피드백</h2>
<p>고생하셨습니다 지영님!
굉장히 꼼꼼하게 회고 작성해주셔서 어떤 과정으로 과제 진행해주셨는지 잘 이해할 수 있었습니다. 필요로 하는 기능은 모두 잘 구현해주셨고, 배포된 페이지도 잘 동작합니다 :+1
과제를 통해 리액트의 실제 구현들을 잘 이해하게 되는 계기가 되신 것 같아 좋네요 ㅎㅎ</p>
<blockquote>
<ol>
<li>DOM Property 처리 범위</li>
</ol>
</blockquote>
<p>boolean이라든지, 스타일이라든지 등등 다양한 값들이 있지 않을까요!?
굉장히 많을 것 같아서 천천히 찾아봐도 될 것 같습니다.</p>
<blockquote>
<ol start="2">
<li>reconcile 함수 리팩토링</li>
</ol>
</blockquote>
<p>역할별로 분리하는 건 필요할 것 같아요! 진입점 분리를 잘 분리하면 역할별로 로직도 잘 관리되고 책임도 잘 나뉠것 같습니다. 이미 알고 있겠지만, 단계별로도 잘 나눠서 비교 후 바로 처리하는 것이 아니라 phase에 맞춰서 실행되도록 하는것도 좋아요!</p>
<blockquote>
<ol start="3">
<li>createChildPath의 inferredIndex 계산 로직</li>
</ol>
</blockquote>
<p>과제를 위한 보조적인 장치인 것 같은데요. 부모경로/컴포넌트타입/인덱스 요걸 키로 활용하기 때문에요.  시간복잡도 관점에서는 전체를 비교하는게 좋지만, 형제 요소, 부모요소가 수정될 때 상태가 유지가 되냐 아니냐에 대한 부분도 있어서 지금의 구조가 실제 리액트와 더 유사하다고 볼 수 있는 것 같아요.</p>
<blockquote>
<ol start="4">
<li>Fragment의 DOM 처리 방식</li>
</ol>
</blockquote>
<p>실제 리액트에서는 Fragment라는 타입의 노드를 별도로 관리하는 것으로 알고 있는데요. 렌더링할때만 별도로 처리하지, 실제로는 Fiber를 가지고 동일하게 처리를 하는걸로 알고 있어요!</p>
<blockquote>
<ol start="5">
<li>useEffect cleanup 실행 타이밍</li>
</ol>
</blockquote>
<p>구현상 이펙트 큐 내부에서 &#x27;이전 클린업 실행 후 새 이펙트 실행&#x27; 순서로 동기적으로 처리되도록 되어있는데요. 새 이펙트가 시작되기 전에 이전 상태를 정리하는 React의 의도와 부합한다고 볼 수 있을 것 같아요!</p>
<blockquote>
<ol start="6">
<li>전역 context vs 인스턴스 context</li>
</ol>
</blockquote>
<p>지금의 고민도 너무 좋은데요. 실제 리액트 구조에서는 루트마다 FiberRoot 인스턴스를 만들고 데이터를 각 컴포넌트 fiber안에 직접 저장하는걸로 알고 있어요. 만약 조금 더 나아간다면 context 객체 방식을 createRoot를 하는 시점에 상태 저장소를 생성하고 주입하는 형태로 간다면 조금 더 적절하지 않을까 싶습니다.</p>
<p>고생하셨고 다음 주도 화이팅입니다!</p></div></div><div class="mt-9"></div></div></main></div></div></div>
    <title>[4팀 박지영] Chapter2-2. 나만의 React 만들기  - 박지영 | 항해플러스 프론트엔드 7기</title>
    <meta name="description" content=" [항해플러스 프론트엔드 7기] 박지영님이 제출한 [4팀 박지영] Chapter2-2. 나만의 React 만들기  과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="keywords" content="항해플러스, 프론트엔드, 개발자교육, React, TypeScript, JavaScript, 기술면접, 웹개발, 박지영, [4팀 박지영] Chapter2-2. 나만의 React 만들기 , 과제상세, 코드리뷰, 피드백, Pull Request" />
    <meta property="og:title" content="[4팀 박지영] Chapter2-2. 나만의 React 만들기  - 박지영 | 항해플러스 프론트엔드 7기" />
    <meta property="og:description" content=" [항해플러스 프론트엔드 7기] 박지영님이 제출한 [4팀 박지영] Chapter2-2. 나만의 React 만들기  과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta property="og:image" content="/defaultThumbnail.jpg" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="[4팀 박지영] Chapter2-2. 나만의 React 만들기  - 박지영 | 항해플러스 프론트엔드 7기" />
    <meta name="twitter:description" content=" [항해플러스 프론트엔드 7기] 박지영님이 제출한 [4팀 박지영] Chapter2-2. 나만의 React 만들기  과제를 확인하세요. 코드 구현, 문제 해결 과정, 피드백 내용을 상세히 살펴볼 수 있습니다." />
    <meta name="twitter:image" content="/defaultThumbnail.jpg" />
  <!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="/front_7th/favicon.ico"/>
  <!--app-head-->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-6J8QP7YK1E"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-6J8QP7YK1E');
  </script>
  <script type="module" crossorigin src="/front_7th/assets/index-C-edMQf_.js"></script>
  <link rel="stylesheet" crossorigin href="/front_7th/assets/index-B1cXSvNG.css">
</head>
<body>
<div id="root"><!--app-html--></div>
</body>
</html>
