[
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/24"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/1"
    }
  },
  {
    "passed": true,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/56"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/79"
    }
  },
  {
    "passed": true,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/47"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/68"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/80"
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/78"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/76"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/9"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/54"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/53#issue-3532034010"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/63"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/62"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/69"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/44"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/73"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/70"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/71"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/74"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/66"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/5"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/52"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/38"
    }
  },
  {
    "passed": false,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/67"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/23"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/4"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/77"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/13"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP01 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/75"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "안녕하세요 승훈님!\n아쉽게도 테스트를 통과하지 못했네요 ㅠㅠ 난이도가 많이 높았던 것 같군요..!\n\n> 테스트 코드란 게 무엇인지는 알겠는데, 여전히 왜 써야하는가? 에 대한 고민이 됩니다. 이는 제가 여전히 활용하는 데 애먹고 있다는 것 같은데, 조금 더 테스트 코드와 친해져야 할 것 같습니다.\n\n저의 경우 테스트는 \"사이드 이펙트를 찾아내는 것\" 이라고 생각했어요.\n스펙이 잘 구현 되었는지 확인하는 용도로 사용할 수도 있겠지만, 변경에 대한 여파를 찾고 문제가 있을 때 이를 빠르게 발견하여 조치를 하기 위함인거죠 ㅎㅎ\n\n신입 개발자가 우리 팀 제품에 기여한다고 생각했을 때, 변경이 어떻게 퍼지게 될지 모르는 그런 상황이 있을 수 있고, 이 때 테스트가 이를 잡아 줄 수 있달까..!?\n\n> 전체적으로 봐주셨으면 좋겠습니다.\n\n음.. 앞으로는 피드백 요청 주실 때 \"전체적으로\" \"대략적으로\" 라고 요청하기보단 승훈님께서 궁금한 부분을 정리하여 질문에 남겨주시면 좋겠어요.\n\n텍스트로 남기는 피드백의 경우 승훈님과 직접적으로 상호작용 하는게 아니기 때문에 이런 질문에 대해 답변 드리기가 굉장히 난감하답니다 ㅎㅎ\n\nhttps://discord.com/channels/1288769861589270590/1430569844327055482\n\n이렇게 디스코드에 구체적으로 궁금한 부분 혹은 피드백이 필요한 부분에 대해 질문이 있다면 남겨주세요! 앞으로 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "안녕하세요 다솜님! \n1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 가장 좋았던 부분은 과제를 진행하면서 \"의미 있는 테스트인가?\"에 대해 끊임없이 고민할 수 있었던 점 입니다.\n\n테스트는 사실 혼자 개발할 때 보다 팀원들과 함께 개발할 때 의미가 있어진다고 생각해요!! 단순히 코드만 작성한게 아니라 깊이있는 고민을 계속 해주셨군요 ㅎㅎ 좋습니다.\n\n> 혹시 Lint 에러나는 것도 과제 내용이었나요?ㅠㅠ 만약 아니었다면 본 과제에 더 집중할 수 있게 코드가 정리된 상태면 좋겠다는 생각이 들었습니다.\n\nlint를 추가한 의도는 (제가 오프코치님은 아니지만..!?), 일단 lint나 prettier에 대해 아직 잘 모르는 분들고 계시고 자연스럽게 함께 체험해보면 했으면 하는 바람으로 추가했던게 컸을 것 같아요!\n\n> 현재 단위 테스트의 디스크립션이 충분히 명확하고 일관성 있는지 피드백 받고 싶습니다.\n\n충분히 명확하게 작성되어있네요! 스펙을 묘사하는 것 처럼 해주셔서 좋았습니다.\n\n> 단위 테스트에서 불필요하다고 느껴지는 부분에 주석 남겨두었는데, 제가 판단한 기준이 맞는지, 혹시 놓치면 안되는 엣지케이스가 있었는지 리뷰 받고 싶습니다!\n\n전체적으로 테스트 작성이 잘 되어 있고, 주석으로 남겨주신 판단 기준이 대부분 타당하다고 생각해요!\n\n<동의하는 부분>\n\n1. dateUtils.spec.ts\n- fillZero 중복 테스트 (314-328줄): 맞습니다. 이미 충분히 커버되고 있습니다\n- fillZero 소수점 테스트 (333-335줄): 함수의 실제 사용 맥락과 맞지 않아 제거가 적절합니다\n2. eventOverlap.spec.ts\n- 주석이 없지만 테스트가 간결하고 적절합니다\n3. eventUtils.spec.ts\n- 주석이 없지만 필터링 로직을 충분히 커버하고 있습니다\n\n<고려가 필요한 부분>\n\n1. getDaysInMonth 유효하지 않은 월 처리 (37-41줄): 제거보다는 유지를 권장합니다. JS Date의 자동 보정 동작을 문서화하는 의미가 있고, 향후 함수가 변경될 때 의도치 않은 동작 변경을 감지할 수 있습니다\n\n2. getWeekDates 경계 날짜 테스트\n- 일부는 유지를 권장합니다\n- 주의 시작/끝 테스트(66-98줄): 중복이므로 제거 가능\n- 연도/월 경계 테스트(103-153줄): 유지 권장. getWeekDates 함수가 date.setDate()를 사용하여 원본 Date 객체를 변경하는 버그가 있을 수 있고, 월/연도 경계에서 Date 객체의 동작이 복잡하므로 이 테스트들은 중요합니다\n\n3. getEventsForDay 유효하지 않은 날짜 처리: 유지를 권장합니다. 함수가 예상치 못한 입력에도 안전하게 동작함을 보장합니다. 특히 0이나 32 같은 경계값 테스트는 중요합니다\n\n> 가능하다면 점진적으로 회사에 테스트 코드를 도입해 보고 싶은데, 구성원 대다수가 테스트에 대한 이해도가 낮고 그로 인해 테스트를 부정적으로 보는 시각이 있는 상황입니다. 어떤 방식으로 테스트를 도입해야 구성원들이 테스트에 대한 경계심을 내려놓고 너그러운 마음으로 받아들일 수 있는지 궁금합니다!\n\n아마 무조건 경계를 할 수 밖에 없다고 생각해요. 그렇다면 그냥 테스트를 작성해서 적용한 다음에 \"이렇게 동작하고, 이런 효과가 있어요~\"를 이야기해보는거죠. 이미 작성되었고, 이미 추가되었고, 이미 돌아가고 있고, 코드를 눈으로 본다면 아마 단순하게 말로 하는 것과는 느낌이 아예 다를 것이라고 생각해요 ㅎㅎ\n\n결론은, 설득보단 용서!\n\n> 테스트 피라미드 전략에 따르면 단위 70%, 통합 20% 정도의 비율로 배분한다고 알고 있습니다..! 실무에서 단위/통합의 비율도 비슷한 지 궁금합니다!\n\n비율이 그렇게 중요하진 않아요. 내가 기여하고 있는 프로젝트의 성격이 중요합니다 ㅎㅎ\n저희 팀은 단위 테스트가 100%이고, 통합테스트는 아예 없어요. 이렇게 된 이유는, 통합 테스트의 난이도가 현재 프로젝트에 적용하기에는 너무 높고, 무엇보다 꼼꼼하게 검증하는게 어려워서...\n\n그래서 단위 테스트로 최대한 넓은 범위를 검증하고자 하는게 목표였답니다.\n즉, 서비스 성격마다 다르고 이건 경험적인 측면에 의존할 수 밖에 없다고 생각해요.\n\n그래서 질문을 바꿔야 해요. 다솜님은 어떤 프로젝트를 하고 있고, 프로젝트의 성격은 어떻고, 어떤 기능들이 있나요? 그리고 그 기능들에 대해 어떤 방식으로 검증을 하는게 제일 효괒거일까요?\n\n> 통합 테스트가 많아질수록 실행 시간이 길어지는데 실제 프로젝트에서 어떻게 관리하고 계신지도 궁금합니다!\n\n위의 내용을 참고해주세요!\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/24"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "곽정원",
    "feedback": "정원님 수고 많으셨습니다!\n\nQ. 저는 하나의 util과 hook은 하나의 기능만 수행해야 한다. 그리고, 코드는 80줄을 넘으면 안된다.는 나름의 철칙을 갖고 있습니다. 그러나, 이 경우 파일들의 depth가 깊어지고, 불필요한 리팩토링이 발생할 수 있다는 생각이 들어요. 다만, 저는 이 방식을 고수할 경우 설계단에서 더 깊게 고민할 수 있고, 공통 | 모듈화 작업을 계속 고민하며 코드를 작성하게 된다는 장점이 있다고 생각하기에 이 방법을 앞으로도 고수할 마음을 갖고 있습니다. 코치님께서 생각하시는 좋은 설계 | 구조는 어떤 것일지 궁금합니다,,! 요즘은 아키텍처나 설계단을 꾸준히 고려하는 연습을 하고 있는데, 코치님의 의견을 들을 수 있다면 정말 큰 공부가 될 것 같습니다🥹.\n\nA. 클래스, 메서드(함수)는 한가지 일을 잘 수행해야한다는 단일책임원칙은 정말 모든 개발 원칙에서 중요한 원칙중 하나 인 것 같습니다. 뎊스가 깊어진다는 것은 결국 추상회 래밸이 생긴다는 것이고 뎊스가 아무리 깊어봐야 분명 정도가 늘 있었던 것 같아요. 다만 80줄을 넘기면 안된다라는 원칙은 사실 잘 모르겠습니다 :) 클린코드에 보면 한파일당 몇라인 이상을 넘어가면 코드스멜로 본다는 엉클밥형님의 말씀도 있지만 더 중요한 것은 단일책임원칙을 지키고 중복을 제거하고 어플리케이션 구성요소들을 추상화해서 레이어를 잘 구성했다면 자연스럽게 지켜질 수 있고 또 이런 주요 원칙이 다 지켜졌다면 80라인은 넘어가도 되지 않을까 싶습니다 :) 그럼 굉장히 간결한 코드일테니까요.  정원님 이렇게 책에서 배운 내용이나 혹은 혼자 얻은 깨닳음으로 몇가지 원칙을 고수하는 습관은 굉장히 좋다고 생각해요! 다만 그 원칙은 언제든지 자의에의해 혹은 남에 의해 더 나은 원칙으로 교체될 수 있다라는 더 중요한 원칙만 유지해주시면 될 것 같습니다. 원칙을 유지하되 원칙도 변경되고 개선되어야합니다. 왜냐면 나는 성장하니까요 ㅎㅎ\n\nQ. 저는 현재 통합테스트를 describe 단위로 쪼개어 @/__tests__/integration/에 넣어두었습니다. 제가 나눈 이유는 바로 하나의 describe는 독립적으로 기능해야 한다. 였으며, 또한 가독성을 위해 나눈 것이었습니다. 테스트 코드는 말 그대로 spec이니까요. 그런데, 통합테스트의 의도 자체가 말 그대로 Integration이라면, 이걸 나눠도 되는 것일까? 하는 생각이 동시에 들었습니다. 만약 정말 유저의 모든 액션을 통합해서 보고 싶다면, 명세 시 하나로 합쳐야 하지 않나? 라고 생각해요. 그러나, 역시 의문이 있습니다. 통합 테스트에서 저렇게 여러 개의 단위로 나누는 행동은 지양해야 할까요? 아니면, 저렇게 하여도 무방할까요?\n\nA. 나누는 것이 나은가 안나누는것이 나은가가 중요하다기보다는 나눴다면 왜 나눴는지 명백한 이유가, 안나눴다면 왜 안나눴는지에 대한 명백한 이유가 있으면 됩니다. 그리고 더 중요한건 동일한 이유에 대해 항상 일관성을 유지하는 것입니다. describe를 어떻게 두는것에 대해서는 사실 답은 없을 것 같아요. 테스트를 분리할 수 있는 기준이 있고 테스트가 중복되지 않는다면 분리하는 것도 좋고, 반대로 파일을 여러개 오픈해서 보는 것이 가독성을 떨어트린다고 판단한다면 한 파일에 몰아둬도 될 것 같아요. 뭐든 설명할 수 있는 이유만 있으면 될 것 같아요~ 어떻게 보면 이것은 취향의 영역일 수도 있고 그때그때마다 판단도 다를 수 있어요. 테스트를 이해하고 파악하는데 현재로 더 좋다고 생각되는 것을 이유와 함게 선택하시면 될 것 같습니다.",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "수고 많았어요 연욱! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \n\n\"테스트 코드 작성을 처음 해봐서 어렵게 느껴지기도 했지만, 주어진 명세에 맞는 테스트를 작성하는 과정에서 검증하는 동작이 중복되거나 검증하지 못한 동작은 없는지를 고민해보는 과정 또한 쉽지 않았다\"고 하셨는데, 이 고민 자체가 정말 중요한 거예요. 처음 테스트 코드를 작성하면서 중복과 누락을 동시에 체크하려고 한 것, 쉽지 않았을 텐데 그 과정을 겪으셨다는 게 의미 있습니다.\n\n다만 회고가 거의 작성되지 않아서 연욱님이 과제를 수행하면서 구체적으로 어떤 어려움을 겪었는지, 어떤 개념을 새롭게 알게 되었는지, 어떤 부분에서 막혔는지를 전혀 알 수가 없네요. handlersUtils 질문이나 테스트 독립성에 대한 답변도 비어있고요. 회고는 단순히 형식적으로 채우는 게 아니라 학습을 완성시키는 과정입니다. 실습을 통해 몸으로 부딪힌 경험을 글로 정리하는 순간 막연했던 경험이 구체적인 지식으로 바뀌거든요.\n\n특히 연욱님처럼 처음 테스트 코드를 작성하셨다면 더더욱 회고가 중요해요. MSW는 어땠는지, 통합 테스트는 어땠는지, beforeEach나 afterEach는 어떻게 활용했는지, 어디서 막혔고 어떻게 해결했는지, 이런 구체적인 고민들을 기록해야 다음 학습 방향이 명확해집니다. 그리고 제가 연욱님의 고민 지점을 파악하고 도움이 되는 피드백을 드릴 수 있고요.\n\n다음 과제에서는 과제 하면서 어떤 게 어려웠는지, 새롭게 알게 된 개념은 무엇인지, 막혔던 지점을 어떻게 해결했는지, 테스트 코드를 작성하면서 내 기존 코드에 대해 어떤 생각이 들었는지를 구체적으로 써주세요. 시간이 부족해도 그 과정에서 느낀 점들을 기록하는 게 정말 중요합니다. 회고 쓰는 30분이 앞으로 9주간의 학습 효율을 몇 배로 올려줄 거예요. 과제는 끝이 아니라 시작이고, 회고는 그 경험을 진짜 내 것으로 만드는 과정이니까요. 다음 과제에서는 코드와 함께 깊이 있는 회고도 기대할게요. 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/56"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "안녕하세요 지현님! 1주차 과제..가 많이 어려웠군요 ㅎㅎ ㅠㅠ 2주차 과제는 잘 마무리할 수 있기를 바랍니다!\n\n---\n\n> medium.useNotifications.spec.ts 파일에서 요 두 케이스 해결 방법이 궁금합니다...ㅜㅜ 어렵네요 ....\n- 지정된 시간이 된 경우 알림이 새롭게 생성되어 추가된다\n- 이미 알림이 발생한 이벤트에 대해서는 중복 알림이 발생하지 않아야 한다\n\n해당 테스트에서는 날짜를 목킹하여 다뤄야 한답니다 ㅎㅎ 솔루션을 참고해보는게 제일 편할 것 같아요!\n\n가령 이런식으로...\n```tsx\n// 날짜를 강제로 지정함 \nvi.setSystemTime(new Date('2025-10-22T21:50:00'));\n```\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/79"
    }
  },
  {
    "passed": true,
    "name": "김단헌",
    "feedback": "단헌님 Hard 과제를 훌륭히 해주셨네요:+1\n데이터도 병렬 환경에서 잘 구성되어서 실패하지 않도록 작성해주셨구요.\n테스트도 딱 필요한 부분들에 대해서 명료하게 작성해주셨네요 :+1\nPR에 작성해주신것처럼 걱정하셨던거 보다 잘 작성하셨습니다.\n\n> createHandlers를 공통으로 관리하기 편하도록 setupTests.ts 파일에 집어넣고 보니 확장성이 떨어지는 것 같다고 느껴졌습니다. 코치님께서 handlerUtils.ts에 템플릿으로 남겨주신 방식대로 메소드별로 작성하여 테스트 시마다 넣어주는 것과 공통으로 넣어주는 것 어떤 방식이 더 적절할지 리뷰 요청드립니다.\n\n둘 다 크게 상관없을 것 같아요 ㅎㅎ 깊이 고민하지 않으셔도 되는 문제 같습니다. \n\n\n> 통합테스트 시 요소를 찾는 부분(getBy, findBy, queryBy..)을 시간 이슈로 제대로 학습하지 못하고 그냥 넣어보고 테스트 통과하면 이건가보다..하는 식으로.. 했어서 테스트코드가 통일성이 없는데(ex. 어떤 것은 testId로 찾고, 어떤 것은 role, labelText 등 중구난방), 어떤 기준으로 요소 찾는 메서드를 선택하고 통일성 있게 해야 할지 리뷰 부탁드립니다.\n\n요거는 제가 그때 말했던것처럼 유저 시나리오에 가깝도록 하는 쿼링의 priority를 꼭 참고해보세요!\n\n> 통합테스트 시 일정 등록, 수정, 삭제와 같은 api 호출이 있는 기능은 userEvent로 테스트 해야 할까요(ex. 버튼 클릭)? 아니면 server.use() 처럼 api 호출을 하는 것이 좋을까요? 리뷰 부탁드립니다.\n\n요것도 실제 유저 시나리오와 동일하게! 하는게 좋은데요. 일반적으로 통합테스트 관점에서 해당 API를 호출하는 컴포넌트 단에서 발생시키는 어떠한 방향으로 하면 상관없지 않을까 싶어요.\n\n> 통합테스트 시 UI 라이브러리에서 제공하는 컴포넌트 중에 복잡한 DOM 트리 구조를 가지고 있는 경우가 있었습니다. 해당 라이브러리의 이해도가 없는 채로 테스트코드를 작성하는데 어려움을 겪었는데요. 코치님께서는 이런 경우가 있을 때 어떻게 테스트 작성하셨는지 궁금합니다.\n\n의도했던 부분이긴한데요! 저희들이 일반적으로 요즘 개발을 하는 환경을 보면 머티리얼이든 shadcn이든 tailwind든 외부에 정의되어있는 라이브러리를 가져와 사용하는 경우들이 대부분이다 보니 이런것들을 테스트하는 경험이 필요하겠다라고 생각했어요. 결국 우리는 실제 구현된 결과, DOM을 보고 작성해야 하기 때문에 기존해 했던것처럼 디버깅 도구들을 활용해서 테스트를 해야하지 않을까 싶어요!\n\n> 그리고 컴포넌트 구조를 잘 모르면 테스트 코드를 작성하기 위해 또다시 컴포넌트를 이해하는 시간이 필요한데, 이런 베이스에서 테스트코드를 효율적으로 작성할 수 있는 방법이 있을까요??\n\n디버깅 도구에 익숙해지는게 필요하지 않을까 싶고, 대부분 컴포넌트를 다르게 구현하더라도 접근성은 지키려고 노력해뒀기 때문에 그런부분들로 쿼링을 한다면 쉽게 쉽게 풀어갔던것 같아요 ㅎㅎ\n\n> 통합테스트 시간이 오래 걸리는 것도 테스트 품질에 크리티컬한 부분인지 궁금합니다. 그리고 반복되는 코드가 많아서 코드가 길어지기도 하는데(ex. 유저 이벤트 작성하는 경우, mock 데이터가 긴 경우) 좋은 테스트코드의 요건?이 있다면 어떤것이 있을지 궁금합니다.\n\n넵 중요합니다! 이 부분은 다음주에 다루게 될 것 같은데요. 결국 이걸 유지보수 하는 비용과 테스트를 작성해서 피드백을 받는 비용 등의 특성이 테스트 방법마다 있고, 그걸 기준으로 테스트에서 얻고자 하는 것들도 달라지게 되는거져.\n일반적인 상황에서 가정을 해보면, 좋은 테스트라면 명확하게 검증하고자 하는것을 검증하는게 첫번째이고 실제 환경과 유사하게 검증하는것이지 않을까 싶구요! 말씀해주신 관점에서는 유지보수에 있어 크게 비용이 들어가지 않고 빠른 피드백을 받을 수 있는 테스트면 좋지 않을까 싶어요!\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김대현",
    "feedback": "오우 대현님! \n이번 주 과제에 있어서 아쉽게 작성해주시지 못했던 내용이 있네요 ㅠㅠ\nPR은 작성해주신거 봤는데 실제 PR에 작성해주셔야 반영이 될것 같아요 ㅎㅎ\n다른 분들의 코드를 참고하고 힌트를 얻고 확장해나가는건 절대 잘못된건 아닌것 같아요 ㅎㅎ 다른 분들 코드도 보고 팀원분들이랑 코드에 대해 이야기를 많이 해보신다면 더 많은것을 배우시지 않을까 싶습니다.\n\n대다수의 코드는 잘 작성해주셨는데요!\n그럼에도 언급을 몇개 좀 해보면..\n어설션하는 부분에 여러 로직들이 그대로 담겨있는 것 같아요! Q&A때 말씀드린것처럼 검증하고자 하는 동작과 그 결과는 딱 정확하게 스태틱하게 비교하는게 좋다고 말씀드렸었는데요. 이렇게 될 경우 테스트의 동작과 실제 동작에 있어 다르게 동작하는 부분이 무심코 발생할 수 있어 테스트의 신뢰도가 낮아질 수 있습니다. 잘 검증하고 계신데 종종 로직들이 보이는것 같아서 이런 부분들을 걷어내보는 연습을 해보시면 좋을것 같아요 ㅎㅎ\n\nmsw에 대한 부분도 꼭 더 늦기전에 한번 챙겨보시고 컴포넌트 테스트도 잘 작성해보시면 좋을것 같습니다. 다음주도 화이팅이고 고민되시거나 어려운 부분있으면 편하게 아고라에 질문주세요~\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "도현님 수고하셨습니다.\n\nQ. 클로저를 사용한 데이터 격리 방식이 적절한가요?: 클로저로 데이터를 격리했는데, 이게 실무에서도 통용되는 좋은 방법인지 궁금합니다. 혹시 더 나은 패턴이 있을까요.\n\nA. 실제 코드를 주셨으면 더 좋았을 것 같아요.\n자바스크립트에서 특정 데이터를 물리적으로 격리시키지만 특정 함수나 메서드에서는 접근이 가능하게 만들고 싶을 때 즉 캡슐화와 은닉화를 위해서는\n궁극적으로 클로저가 제일 명확한 답이라고 생각합니다.\n게터 세터로 프로퍼티 필드로 만들 수 있겠지만 이건 변수보다는 값을 연산해내는 도구로 더 활용이 되는 것으로 봐야할 것 같고욥.\n자바스크립트에서는 데이터를 격리하고 캡슐화하는 방법이 몇가지 없어요. 클로저는 아주 좋은 답입니다. \n\nQ. Factory 패턴 사용의 적절성 createMockEvent로 테스트 데이터를 만들었는데, 이게 좋은 접근인지 아니면 오히려 복잡도만 높이는 건지 확신이 서지 않습니다. 실무에서는 어느 정도 수준까지 추상화하는 게 적절한가요?\n\nA. 목데이터를 생성하는 함수는 자주 사용됩니다.\n다만 로직을 많이 단순하게 유지해야겠죠. 지금처럼 선언적으로 만든 함수라면 괜찮을 것 같아요.\n저는 어쨌거나 함수는 함수니까 테스트를 위해 사용되는 데이터는 가급적 스태틱하게 생성하는 것을 선호하는데요.\n이렇게 데이터의 양이 많고 중복적이라면 의도적은 필드의 가시적인 변경을 위해 비슷한 함수를 만들어 사용하고 있습니다.\n\n다만 가급적 테스트를 위해 사용하는 추가 함수(로직)는 지양하는 편입니다.(그 함수는 누가 테스트하나욥..ㅎㅎ)\n\nQ. 테스트 구조 개선 현재 describe를 나누지 못한 부분이 많은데, 어떤 기준으로 describe를 나누면 가독성이 좋아질까요? 예를 들어 \"정상 케이스 / 에러 케이스\"로 나누는 게 좋을지, 아니면 \"기능별\"로 나누는 게 좋을지 궁금합니다.\n\nA. 특정 모듈이 무엇을 할 수 있는지를 기준으로 TC를 작성하는 것이 좋습니다. 이말은 기능별에 가깝겠죠.\n궁극적으로는 describe-it 이런 뎊스를 가진 구조가 제일 이해하기 쉬워요.\n다만 조건이 복잡하거나 조건을 재사용하기 위해서 조건을 공유할 수 있게 describe로 중간 뎊스를 둘 수도 있을 것 같고요.\n여기서의 중간 뎊스는 필요에 의해서 필요할때 추가해도 될 것 같습니다.\n예를들어\n로그인 모듈이라면\n로그인 모듈이란 describe안에 기능적으로 분리가능한 \"비밀번호 찾기\", \"아이디 찾기\", \"로그인\", \"로그인 실패\" 이런 중간 뎊스로\ndescribe를 둘 수 있겠죠. 이건 그냥 의도했기 때문에 구분하는 것이고 이것에 대한 정답은 없을 것 같아요.\n현재로 제일 적합하다고 판단되는 의도가 있고 그 의도대로 작성하면될 것 같습니다.\n\n말씀하신 정상케이스와 에러케이스로 나누었을때 어떤 장점이 있을까요? 장점이 있다고 판단되면 그렇게 나누셔도 좋지만,\n저라면 특정 기능에서 정상 케이스 it와 에러케이스 it를 묶어서 보고 싶을 것 같아요.",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/47"
    }
  },
  {
    "passed": false,
    "name": "김민석",
    "feedback": "안녕하세요 민석님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 너무 물경력이고 그동안 너무 공부를 안 해서 지금부터라도 하려고 하는데 코딩 테스트, 개인 프로젝트 등등해야 할게 너무 많더라구요.. 뭐부터 시작을 해야 할지 모르겠습니다.. 혹시 당연히 다 중요하겠지만 추천해 주실만한 공부 순서나 중요도?? 같은 거 있으실까요??\n\n코테의 경우 \"문제를 풀이하는 행위\" 보다는, 문제를 풀이하는 과정 자체에 집중하시면 좋답니다. 채용담당자는 \"얼마나 어려운 문제를 잘 풀이하는가\"를 보고싶다기보단, 문제를 어떻게 발견하고, 어떤 과정이 풀이하는지에 대한 전체적인 내용이 궁금한거라서요.\n\n그래도 기본적인 알고리즘 문제는 잘 풀이할 수 있으면 좋답니다! 저는 프로그래머스 lv 3 까지는 풀이해보면 좋다고 생각해요 ㅎㅎ\n\n개인 프로젝트의 경우, 이게 정말 민석님의 실력 향상에 뚜렷한 도움이 되는지 고민해보시면 좋아요. 대체로 회사에서 하는 프로젝트가 개인 프로젝트보다 더 복잡하고 어렵기 떄문에 이를 어떻게 하면 개선하고 해소할 수 있을지 고민하는 과정이 필요합니다.\n\n혹은 지금 항해플러스에서 제공하는 미션처럼, 특정 기술에 특화된 학습을 할 수 있는 프로젝트를 찾아서 해보는 것도 좋은 방법입니다.\n\n저의 경우 할일 목록을 최대한 오버엔지니어링으로 구현하면서 다양한 기초 지식을 습득했어요. \n\nhttp://github.com/junilHwang/black-coffee-study\nhttp://github.com/junilHwang/black-coffee-study-lv3\n\n---\n\n과제에 대한 질문은 없는 것 같아서 여기서 마무리하겠습니다. 고생하셨습니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/68"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "수고 많았어요 민지! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Medium까지 도전하시고 코드도 많이 작성하셨네요.\n\n다만 아쉽게도 이번 과제를 평가하는 입장에서는 조건을 충족하지 못해서 불합격입니다. CI 체크에서 lint와 test 모두 실패하고 있습니다. 그리고 conflict도 해결이 필요한 상태고요. 개발에서는 90% 개발을 해도 완성이 안되면 완성이라고 볼수 없기에 테스트 코드가 통과하지 않는 상태로는 과제 완료로 볼 수 없어요. \n\n그리고 회고가 전혀 작성이 되어 있지 않네요. 회고는 단순히 형식을 채우는 게 아니라 과제의 핵심 부분이에요. 실습을 통해 몸으로 부딪힌 경험을 글로 정리하는 순간 막연했던 경험이 정말로 내것이 되는 순간입니다. 또한 개발자가는 컴퓨터가 이해하도록 코드를 작성하는 역할도 있지만 내가 작성한 코드를 다른 사람에게 인간의 언어로 소통을 하는 것도 아주 중요한 능력입니다. 코드만 보고서는 적절한 피드백이나 리뷰를 해줄 수가 없어요.\n\n코드의 양이 9,563줄이나 추가했는데 분명 많은 노력을 했을 거에요. 혹시 제출 과정에서 뭔가 누락되거나 실수가 있었나요? 아니면 정말로 시간이 부족해서 마무리를 못한건지 궁금하네요.\n\n만약 누락된 부분을 수정하고 싶으시다면 다음 사항들을 확인해주세요. 첫째, CI 테스트가 통과하도록 코드를 수정해주세요. 둘째, conflict를 해결해주세요. 셋째, 회고를 구체적으로 작성해주세요. 과제하면서 어떤 게 어려웠는지, 새롭게 알게 된 개념은 무엇인지, 막혔던 지점을 어떻게 해결했는지를 써주시면 됩니다. 넷째, Medium 질문들에 대한 답변도 작성해주세요.\n\n지금은 불합격이지만 이 부분들을 수정하시면 따로 연락주세요. 재검토해서 반영할게요 :) 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/80"
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "수고 많았어요 성민! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 회고를 보아하니 힘들었지만 잘 수행해준 것 같아요.\n\n특히 \"매일 꾸준히 새벽까지 했음에도 불구하고 만족스러운 진전이 나오지 않아 후반부에 고생했습니다\"라고 하셨는데, 그 과정에서도 끝까지 포기하지 않고 115개의 단위 테스트를 모두 작성하고 통과시킨 점이 정말 대단합니다. 이런 꾸준함이 장기적으로 큰 성장을 가져올 거예요.\n\n\"Hard 과제를 너무 오랫동안 붙잡은 탓일까요?\" ㅠㅠ 언제나 개발자에게는 시간이 부족하기 마련이지요. 우선순위에 대한 고민은 실무에서도 중요하니 시행착오를 통해 성장해봐요. 우리의 과제는 학습을 하기 위함이니 점수를 따기 위한 과제가 아닌 만큼 다양한 방법의 시도와 시행착오 속에서 성장하기를 바래요. 개발자에게 중요한건 마감과 완성인 만큼 지금처럼 Medium 과제를 다하고 할 수 있을 만큼 진행해본 접근 아주 훌륭합니다.\n\n코드 품질에 대해서 \"테스트 통과에만 급급한 나머지 코드의 품질에 대해서는 하나도 집중하지 못했다\"고 했는데 지금의 경험을 토대로 앞으로 이런 변수에 이런 상황에서는 이 이름을 써야겠다 라고 하는 아주 세세한 생각없이 통일되는 자기 컨벤션이 있으면 좋아요. 코드를 살펴봤는데 딱히 그런 코드가 심각하게 보이는건 없는데 아쉬움 때문이지 않을까 생각합니다. ㅎ\n\n\"실무에서 테스트 코드를 작성하던게 있었는데, 팀원 중 어느 누구도 MSW를 통한 API 모킹을 알지 못해 데이터를 실제로 업데이트하고, 다시 지우는 과정을 수기로 수행한 적이 있었습니다\" ㅋㅋ 언제나 개발은 필요에 의해 발전하므로 \"아.. 이걸 이렇게해야 되나? 더 편한 방법 없나?\" 하면 대개 있기 마련입니다ㅎ 이번 기회에 접하게 되었으니 꼭 써먹어 보기를 바래요\n\n테스트 코드 작성의 심리적 장벽을 넘으신 것을 축하드립니다. \"테스트 통과에만 급급\"했다고 했지만 완성했고 성공했고 잘 했어요. 아쉬운 마음은 다음 과제에서 보여줍시다 다음 주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/78"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "수고 많았습니다. 소리! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 휴가와 개강이 겹쳐서 목요일 하루만에 밤을 새워 과제를 완료하셨다니 ㅠㅠ 정말 고생 많으셨어요. 솔직히 과제의 분량이 적지 않은데 하루만에 할 수 있었다는건 이미 E2E 테스트를 주로 작성해서 테스트라는 과제가 낯설다거나 생소하지 않고 친숙한가 봐요. 대부분이 테스트를 실무에서 다뤄보는 경험이 없다보니 첫 과제로 접하게 한거였는데 이미 경험이 있다니 멋지네요.\n\nhandleUtils에서 클로저 활용해서 독립성을 보장하고 vi.useFakeTimers()와 vi.setSystemTime() 등으로 시간 의존적인 테스트도 잘 만들어 주셨네요. 잘했습니다.\n\n\"테스트 코드 내에서 다른 유틸 함수를 사용했는데 괜찮은지 모르겠다\"고 하셨는데, 전혀 문제없습니다. 다만 테스트 코드는 가독성과 직관성 그리고 독립성이 정말 중요합니다. 그래서 추상화가 너무 많이 되는것이 안 좋을 수도 있어요. 작성해준 assertDate, parseHM 같이 단순 변환/비교 유틸은 괜찮지만 expectWeekDates와 같이 뭘 검증하는지를 추상화하는 형태는 좋지 않아요. 가급적 테스트를 하는 것을 숨기는 형태의 코드는 지양해주세요.\n\n\"실무에서 이 정도로 테스트 코드를 작성하는 경우가 있는지\"에 대한 답은 회사와 도메인마다 다릅니다. 프로젝트가 후반부로 갈수록 그래서 새로운 기능 구현보다는 문제가 생겼을때 손실비용이 더 큰 순간이 오면 구현보다도 테스트 코드가 훨씬 더 가치가 빛나는데 솔직히 그럴만한 대형 서비스라는게 몇개 없잖아요. 초창기 서비스들의 경우에는 테스트코드가 없거나 효용체감이 많이 떨어지는게 사실입니다. \n\n물론 그 대형 서비스를 하는 곳에 가고 싶어 하는 사람들이 많고 실제로 하고 있으니 내 실무에는 효용체감이 떨어지더라도 할 수 있으면 좋죠. 테스트 코드를 잘 다루는 것을 테스트 코드의 효용체감 측면이 아니라 요구사항이나 명세를 구현의 관점에서 구조화 하고 좋은 코드를 만들 기 위한 장치로 생각해주세요.\n\n앞으로의 과제들도 분량은 제법 있을거라 물리적으로 시간이 부족하겠지만서도 앞으로 9주 동안 계속 밤샘하면 체력이 안 될 테니 조금씩 분산해서 잘 해보세요. 동룔들과 함께 나눠보는 것도 좋아요! 너무 너무 수고했습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/76"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "안녕하세요 우정님! 1주차 과제 꼼꼼하게 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 회사 프로젝트에도 테스트를 도입해보고 싶은데, 다국어 서비스(i18n) 환경에서는 어떤 점을 주의해야 할까요? 텍스트 검증이 필요한 경우, setup에서 언어를 하나로 고정한 뒤 해당 언어 기준으로만 검증하는 방식이 적절할지 궁금합니다.\n\n다국어 환경에서 중요한건, Message key를 어떻게 한 번에 반영할 것인지? 라고 해야하나.. 테스트 파일도 생기면 테스트에도 반영을 해야하니까요 ㅎㅎ\n그리고 정책에 대한 결정이 필요할 것 같은데요, key를 기반으로 테스트를 관리할 것인지, value를 기반으로 테스트를 관리할 것인지 결정하면 좋을 것 같아요!\n\n아예 테스트용 다국어 json을 하나 만들어서 관리하는 것도 하나의 방법이겠죠!?\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/15"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "준모님 고생하셨습니다!\n\n> 다음에는 과제 Hard 잡고 첫날부터 밤새 하고싶다.\n너무 무서운 말인데요 ㅋㅋㅋㅋㅋ 처음부터 너무 무리하지 마세요 ㅎㅎ\n\n우선 이번주에는 테스트 자체에 익숙해지는거에 목표가 있었기 때문에 작성해주신 코드 보니까 충분히 잘해주신것 같아요 ㅎㅎ\nmsw 사용하는데에도 어려움이 없으셨던것 같고, 테스트를 작성하는 논리도 잘 정립하고 계신 것 같습니다 ㅎㅎ 병렬적이게 테스트를 구동하게 할 때에도 잘 고민해주신 것 같구요.\n\n> unit 부분에서 테스트 코드가 코치님께서 보시기에 가시적인지 확인 해주시면 좋겠습니다.\n\n말씀해주신게 utils에 대한 테스트를 말씀해주시는거라면, 잘 작성해주셨어요!\n\n> 최대한 가시적이게 변수 명을 지어봤지만 함수나 비교부분(expect) 에 직접 값을 써 넣는게 더 좋은지, 변수로 지금처럼 빼서 변수명 잘 지어주는게 좋은지 조언 부탁드립니다.\n\n잘 작성해주셨지만 ㅎㅎ 제 개인적인 취향으로는 여러번 선언되지만, 굳이 여러번 선언할 필요가 없는 변수들도 존재하는 것 같아요! 전체를 관통하는 테스트 케이스를 유지하면서, 필요할때만 이벤트를 재선언하는 형태로 하면 더 깔끔할것 같아요. 이벤트도 종종 여러개를 넣어 처리하는게 있는데, 필요한 만큼만 같은 그룹의 값이라면 사용하지 않는 형태로 처리하면 좋지 않을가!\n\n> 테스트 helper 함수 만들때 함수니까 효율적이지만 복잡하게 만들어도 되는지, 아니면 그것도 확인 해야 하기 때문에 단순화 해야 하는지 알고 싶습니다.\n\n요거도 결국 테스트를 위한 테스트가 필요해질수 있으니 최대한 단순하게 목적에 맞게 가독성을 올려주는 형태로만 운영하는게 저는 좋다고 생각하는 편입니다.\n\n> GPT 없이 개발 지식 수급처가 궁금합니다.\n\nㅋㅋㅋㅋ구글과 공식 가이드, 그리고 책입니다. 이제 사용하셔도 됩니다. 고민하지 않으셔도 됩니다.\n\n> 하루에 8시간씩 한다고 했을때 몇일 걸릴 만큼의 난이도 인지 궁금합니다.\n\n사실 이게 크게 의미는 없을것 같지만..\n제가 지금 수준에서 받았다면 4-8시간 내외면 작성하지 않을까 싶었고 테스트가 익숙하지 않은 수강생분들이라면 4-5일정도 걸리지 않을까라고 가정하고 만들었던 과제입니다. (물론 Hard라는 이름인 이유가 있지만요)\n\n> 계속 선언 되어 있던 wait 사용처\n\n요거는 waitFor라고 이해했는데요. 훅에 대해 테스트를 할때 종종 필요한 경우가 있어서 필요에 의해 사용하지 않았을까 라고 생각이 듭니다. 근데 지금은 없어도 되는 경우들도 있는것 같아요! 이거도 체크 한번 부탁드립니당\n\n앞으로도 잘 부탁드리고 PR템플릿도 꼼꼼하게 채워주시면 좋겠습니다~ 그 과정에서 정리되는게 많으시다고 하더라구요. 고생하셨습니다!!\n\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "수고 많았어요! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Hard까지 완주하시고 회고도 정말 상세하게 작성해주셨네요!\n\n\"테스트코드의 중요성에 대해 막연하게 생각하고 있었는데 과제를 제출 후 중요성에 대해 깨달은 게 제일 좋은 결과\"라고 하셨는데 너무 뿌듯하네요. 정확합니다! 테스트 코드가 단순히 동작 검증이 아니라 코드의 명세서 역할을 한다는 걸 깨달으셨다니 이번 과제의 목표를 정확히 달성하셨네요. 특히 handlersUtils에서 클로저를 활용해 테스트 독립성을 확보한 부분과 beforeEach에서 서버 핸들러를 등록하는 설정들을 정확히 이해하고 계셔서 좋습니다.\n\n헬퍼 함수 renderHookAndWaitForLoad 작성한 부분이 만족스러웠다고 하셨는데 ㅎㅎ 좋네요. 개발자들은 반복을 참지 못하죠. 아주 좋은 접근입니다. \"반복되는 로직을 최소화\"하려는 생각이야말로 좋은 개발자의 시작이에요. 실무에서도 테스트 코드에서 반복되는 패턴을 헬퍼 함수로 추출하는 건 필수적인 작업이죠. 이름은 살짝 아쉽네요. \"renderHookAndWaitForLoad\" 라면 뭔가 대단히 보편적인 행동을 할 것 같은 이름인데 하는 행동은 꽤 구체적이라 수준에 맞는 이름을 지었다면 더 좋았겠어요.\n\n\"어디까지 테스트를 해야하고, 이 테스트가 과연 어디까지 보장해줄 수 있을까\" 하는 의문이 들었다고 하셨는데 그것이 테스트 코드의 진짜 실무의 능력이죠. 지금은 영어 회화를 배우는 거라면 실전 영어는 완전히 다른게 지금 상황에 필요한 말을 할 수 있는가잖아요? 그리고 이건 어떻게든 말로 설명을 해 줄 수 있는게 아니니 \"효용체감을 느낄 수 있는 테스트 코드 작성\"이라는 최종 미션은 꼭 실무에서 경험해보게 되기를 바랍니다. \n\n통합테스트에서 비동기 렌더링과 타이밍 처리가 어려웠다고 하셨는데 프론트엔드에게 비동기는 누구나 어렵게 만드는 녀석이죠. findBy는 자동으로 기다려주지만 getBy는 즉시 찾으려 하고, waitFor는 조건이 충족될 때까지 기다려주는 등 유사해보이지만 왜 각각 만들어 두었을까를 고민해보면서 각각의 특성을 생각해보면 왜 이렇게 만들었을까? 를 생각해보면 더 머리속에 잘 남겨둘 수 있습니다.\n\ndescribe 블록 기준과 beforeEach/afterEach 사용에 대해 궁금해하셨는데, 지금처럼 \"같은 전제조건\"을 가진 테스트들을 묶는 게 맞습니다. 대개 같은 목적을 가지고 것들을 기준으로 한데 묶어준다거나 그렇기에 지금처럼 유사한 조건에서 시작하는 경우등을 묶어내는데 사용할 수 있죠. 공통점이 있다면 자연스러게 유사한 곳에 둬야 하는 구조적 사고들도 테스트 코드에서 발휘해야 합니다.\n\nbeforeEach/afterEach에 대한 성능 걱정은 하지 않아도 됩니다. 오히려 테스트의 최적화(?) 보다는 각 테스트가 독립적인 환경에서 실행되는 게 훨씬 중요합니다. 테스트 A가 테스트 B에 영향을 주면 그게 더 큰 문제가 됩니다.\n\n블로그 잘 봤습니다. 멋져요! 첫 하트는 제가 눌렀답니다. 이렇게 배운 내용을 글로 정리하는 습관이 장기적으로 엄청난 성장을 가져올 거예요. 다음 주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/9"
    }
  },
  {
    "passed": false,
    "name": "김현우",
    "feedback": "수고 많았어요 현우님! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \n\n\"...테스트 코드를 직접 코드로 구현해보는 건 이번이 처음이여서 그런지, 기본과제를 하는데도 여러 고민들이 들었고, 그로 인해 과제 속도도 나지 않았다. medium, hard레벨까지 풀지 못해 아쉽기도 하지만, 지금까지 풀은 과제를 통해서 테스트 코드에 대한 여러 내용들을 학습한 것 같다.\" 라고 했는데 우선 테스트 코드라는 것에 익숙해지기만 해도 충분히 가치가 있어요. (그렇다고 찍먹만 하는건 아니고 꼭 다 마스터 해야겠죠?)\n\n특히나 \"책으로 테스트 코드에 대해 익혀 두었으니 hard까지 시간 쏟으면 풀 수 있지 않을까\" → \"생각보다 생소하고 공부해야 할 것들이 많다\" 처럼 책으로 아는 것과 직접 코드로 부딪혀 보는 건 완전히 다른 경험이에요. 저희가 발제는 세상에 이런게 있다라고 시야를 틔여주는거라면 실습은 직접 부딫히면서 이런 것들이 필요하고 중요하고 알게 해주는 시간이랍니다.\n\nfetchHolidays 함수에 대한 고민과 접근 아주 좋아요. 테스트는 단순히 결과만 확인하는 게 아니라 \"문제가 생겼을 때 어디서 잘못됐는지 빠르게 파악\"할 수 있게 하는 도구예요. 각 함수를 개별적으로 테스트하면 에러의 원인을 정확히 특정할 수 있죠. 이런 고민을 스스로 해내신 게 정말 멋집니다. 과제를 비록 다 하지 못하는 순간이 오더라고 지금처럼 회고에서 고민의 깊이는 계속 가져주길 바래요!\n\n리뷰 받고 싶으신 내용인 description 작성에 대해 답변드리자면, 테스트 description은 \"이 테스트가 무엇을 검증하는가\"를 누가 봐도 명확히 알 수 있게 작성하는 게 목적입니다. \"getDaysInMonth는 2024년 2월에 29일을 반환한다\"처럼 구체적이고, 실행 가능한 문장으로 작성하면 좋아요. 지금 작성하신 description들 보면 이미 잘하고 계실 것 같은데 구체적으로 어떤 부분이 고민되셨는지 알려주시면 더 자세히 피드백 드릴 수 있을 것 같아요. 질문이 피상적이면 저도 답변히 같은 수준에서 밖에 답을 못드리겠네요.\n\n다음번 회고는 보다 더 깊은 고민과 구체적인 질문으로 가득차기를 기대합니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "엇 은주님 ㅠㅠ\n따로 올라온게 없군요\n바쁘신 일정이 있으셨는지 실수였는지 모르겠지만 혹시 잘못 올리신거라면 다시 올리고 알려주세요 ㅎㅎ\n꼭 다음에는 해보신데까지 올려보고 피드백 받아보시면 좋을것 같아요~\n\n고생하셨고 다음주도 파이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/54"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "유리~ 과제 제출 수고하셨어요! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n다만 정말 아쉽게도 회고가 작성되지 않아서 유리님이 과제를 수행하면서 무엇을 느끼고 배웠는지, 어떤 부분이 어려웠는지, 어떤 고민을 했는지를 전혀 알 수가 없네요. 템플릿만 붙여넣고 내용이 비어있어서 구체적인 피드백을 드리기가 정말 어렵습니다.\n\n회고는 단순히 제출을 위한 형식이 아니라 **학습의 핵심**입니다. 실습을 통해 몸으로 부딪히면서 느낀 것들을 글로 정리하는 순간, 막연했던 경험이 구체적인 지식으로 바뀌게 돼요. \"아, 이게 어려웠구나\", \"이 부분은 이해했구나\", \"다음엔 이렇게 해봐야겠구나\" 이런 생각들을 글로 쓰는 과정 자체가 학습을 완성시키는 거예요.\n\n특히 테스트 코드처럼 생소한 영역을 처음 접할 때는 더더욱 중요합니다. 다른 분들 회고를 보면 \"fetchHolidays를 왜 테스트에서 호출해야 하는지 고민했다\", \"테스트가 명세서 역할을 한다는 걸 체감했다\", \"내 코드가 역할이 불명확하다는 걸 깨달았다\" 같은 구체적인 인사이트들이 있어요. 이런 고민의 흔적들이 쌓여야 진짜 내 것이 되는 거죠.\n\n그리고 회고를 작성해야 제가 유리님의 고민 지점을 정확히 파악하고 도움이 되는 피드백을 드릴 수 있어요. \"이 부분이 어려웠어요\"라고 써주시면 \"이렇게 접근하면 좋아요\"라고 구체적으로 답변드릴 수 있는데, 지금은 그게 불가능하네요.\n\n과제하면서 어떤 게 어려웠는지, 새롭게 알게 된 개념은 무엇인지, 이전에 몰랐던 걸 이번에 깨달은 게 있나요? 다음에 더 잘 해보고 싶은 지점등에 대해서 깊이있게 솔직하게 답하다 보면 학습이 훨씬 더 깊어질 거예요. 과제는 시험이 아니라 학습과 성장을 하고자 하는 것이니 완성이 다 되지 않더라도 그 과정에서 고민들을 한번 기록해보길 바래요.\n\n다음 과제에서는 코드와 함께 꼭 회고도 채워서 제출해주세요. 기대하고 있을게요. 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/53#issue-3532034010"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "안녕하세요 희정님!\n과제가 많이 어려웠나보군요 ㅠㅠ 일단 테스트는 다 통과히지 못했네요.\n2주차는 잘 해낼 수 있기를 바랍니다!\n\n> easy.useCalendarView.spec.ts 에서 각 테스트 하기 전에 renderHook()을 한번 해서 그것을 사용할 수 있나요? 그리고 모킹 테스트 시간도 마찬가지로 한번 실행시켜서 유지되게 할 수 있나요?\n\n그럼요 ㅎㅎ 충분히 가능합니다. 다만 매번 renderHook을 해주는 이유는 \"테스트 환경을 초기화 하기 위함\" 입니다. 일관성을 유지하기 위함인거죠.\n그래서 웬만하면 매번 해주는게 제일 좋답니다!\n\n혹은 beforeEach 에서 renderHook을 실행하여 매번 렌더링 초기화는 유지하고 코드는 제거하는 방식으로 할 수 있어요.\n\n여튼, 이렇게 해야 하는 이유는, \"병렬 실행\" 상황을 가정해보며 좋아요. 동시에 렌더링이 되어 테스트가 진행된다고 가정했을 때 순서에 영향을 받을 수도 있고, 데이터에 영향을 받을 수도 있어요.\n\n> 하나의 act() 안에 두개의 상태변화 set()을 넣으면 안되나요? 두 개를 사용하면 마지막 set() 만 실행되는 것 같아요\n\n이건 act의 문제라기보단, 구현의 문제라고 할 수 있습니다.\nsetState(prev => ...)\n이런 방식으로 값을 세팅하게 되면 이전 값을 계속 이어받아서 재활용할 수 있는데, setState(1) 처럼 실행하게 되면 마지막 값으로 덮어쓰게 되는 문제가 있어요 ㅎㅎ\n\n리액트의 배치처리와 관련된 부분이라, \"리액트 배치\" 혹은 \"스케쥴링\" 이라는 키워드로 찾아보시면 좋답니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/63"
    }
  },
  {
    "passed": false,
    "name": "박수범",
    "feedback": "수고 많았어요. 수범. 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 4일이라는(ㅠㅠ) 촉박한 시간 속에서도 102개의 테스트를 통과하느라 고생많았어요.\n\n\"50%도 제대로 이해하지 못하고 넘어갔다\", \"아직 테스트 코드에 대해 20%도 이해하지 못한 것 같다\"고 했는데 우선 학습의 시작은 내가 뭘 모르고 있고 얼마나 모르고 있는데 아는데 시작이니까요. 과제의 완성이 아니라 학습과 성장에 초점을 두어보아요! 자신의 이해도를 정확히 파악하는 것이 성장의 시작이니까요. \n\n가령 Date 객체를 피상적으로 알고 있어서 예상치 못한 동작을 마주했다고 하셨는데, 아주 좋습니다. 그 지점에서 너무 좌절하지 말고 무엇을 알아야 하는지 알게 되고 새로운 것을 마주하는 그 모먼트를 즐겨보세요. 앞으로 10주간 계속 마주게 하게 될 감정이니 오히려 부족함과 새로움을 느낀다면 돈값(?)을 하고 있구나라고 생각해주길 바래요. ㅋㅋ\n\n마지막에 작성한 msw와 모킹 개념을 확실히 이해하고 넘어가야겠다고 스스로 정리하신 부분. 마음만 남기지 말고 꼭 내것으로 만들어 보세요. AI와 함께 수다를 떨어가면서 내용의 깊이를 챙겨보고 꼭 실습(!)을 통해서 내가 피상적으로 알고 있는 것인지 확실히 알고 있는것인지를 구분하는 습관을 가져보기로 해요.\n\n\"다음 과제에서는 궁금한 점과 논의하고 싶은 내용으로 가득 채워질 만큼, 깊이 있는 성찰과 고민을 해오겠습니다. 감사합니다.\" <- 기대하고 있겠습니다! 혼자서 어렵다 느껴지면 주저하지 말고 주위 사람들을 찾아요!\n\n다음 주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "안녕하세요 용태님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 전체적인 테스트 코드의 가독성에 대해 간략한 피드백 부탁드립니다.\n\n가독성은 나쁘지 않다고 생각합니다 ㅎㅎ\n다만 이럴 때 용태님께서\n\n\"~~~ 처럼 작성했는데 이럴 때 XX 때문에 가독성이 좋다고 생각합니다. 이에 대해서 어떻게 생각하나요?\" 처럼 질문을 남겨주시면 제가 더 좋은 피드백을 드릴 수 있을 것 같아요!\n\n> handlersUtils.ts에 대한 해결 방식이 적절했는지에 대한 피드백 부탁드립니다.\n\n음 기존에 존재하던 인터페이스를 없애고 아예 새로 만들어주셨군요 ㅎㅎ\nSEED 를 통해 초기화하고 있는데, 나쁘지 않은 방식이라고 생각합니다!\n데이터로 분기해서 관리할 것인가, 함수로 분기해서 관리할 것인가의 차이랄까..\n\n다만 함수로 분리 + 데이터로 분리 한다면 그 의도가 더 명확하게 드러나지 않았을까 싶어요!\n\n> 테스트 편의성을 위해 data-testid를 구조적으로 붙이는 것이 어디까지 허용될까요?\n\n사실 저는 아예 안 붙이는걸 선호합니다 ㅎㅎ 꼭 붙여야 한다면 테스트 내부에서 별도의 컴포넌트를 선언한다거나, 목킹을 하는 방식으로 다루고 있어요.\n이건 정답이 있다기보단 함께 테스트를 작성하는 사람들과 합의가 필요하다고 생각해요. \ntestid가 있다고 해서 기능에 문제가 되진 않지만 그냥 \"찝찝함\"이 느껴지는 차이랄까... 저는 그렇게 생각합니다!\n\n> 테스트 코드(TC)와 서비스 코드 간의 관계에서, TC가 서비스 코드 구조에 영향을 받는 것은 자연스럽지만, 반대로 서비스 코드가 TC를 위해 data-testid나 특정 aria-* 속성을 추가해야 하거나, <Select/> 의 옵션에 대한 식별을 위해 option-${value} 같은 형태의 label/testid 를 강제해야한다면, 이는 테스트 주도(TC → 코드)가 지나치게 코드 구조에 간섭하는 것이 아닐까요? 다시 말해, “접근성 속성(aria-label 등)”이 테스트 용도로 강제되거나, “테스트 전용 식별자(data-testid)”가 실제 서비스 코드의 구조에 영향을 주는 상황은 어디까지 허용될 수 있을까요?\n\n말씀해주신 것 처럼 테스트 식별자를 테스트 때문에 계속 추가하는건 문제가 될 수 있다고 생각해요. 다만 접근성 속성은 필요하지 않을까요? 이게 테스트 때문이라기보단 말 그대로 접근성을 위한 도구라서요 ㅎㅎ\n\n사실 위의 질문과 이어지는 내용인 것 같은데, 테스트를 위한 장치들은 웬만하면 추가하지 않으려고 하는 편입니다. 다만 테스트 때문이 아니라 구조적인 문제가 있고, 구조를 개선하여 테스트 하기 더 자연스러운 구조로 논리를 만들어갈 수는 있을 것 같아요!\n\n테스트를 계속 작성하다보면 자연스럽게 이에 대한 숙련도가 높아지게 된답니다. 계속 고민 해보시면 좋겠어요!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/45"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "지영님 수고하셨습니다.\n\nQ. 테스트 격리 방식의 적절성 현재 handlersUtils에서 단순히 깊은 복사(JSON.parse(JSON.stringify()))를 통해 초기 데이터를 보존하고 있습니다. 이 방식이 적절한지, 더 나은 방법이 있는지 피드백 부탁드립니다. 추가로, 테스트 코드를 작성할 때 재사용성을 고려하여 매직 넘버나 문자열을 상수로 추출하는 것을 선호하는데, 테스트 코드에서도 이런 패턴이 권장되는지 궁금합니다.  예를 들어: const expectedDate = '2025-10-21'; expect(targetBox?.textContent).toContain(expectedTitle); expect(targetBox?.textContent).toContain(expectedDate);\n\nA. 깊은 복사를 위해 JSON을 사용하는 것은 저도 종종 사용했던 방법이긴 하지만 structuredClone를 쓰는 것을 권장합니다~\n매직넘버를 변수에 담아쓰는것은 아주 강력하게 권장하고 테스트 코드에서도 충분히 의미가 있을 것 같은데요.\n적어주신 expectedDate, expectedTItle은  그냥 expected만 썼을때와 큰 차이는 없어 보여요.\n예를들어 selectedDate 이렇게 좀더 의미 있는 변수명이여야 효과가 있을 것 같습니다. 그런데 이미 디스크립션으로 설명이 되기때문에 expected만 쓰는것도 나쁘지 않을 것 같아요. \nQ. MSW 핸들러에서의 직접 접근 handlers.ts에서 events 배열을 직접 조작하는 것이 괜찮은지 의견 부탁드립니다. 현재는 핸들러는 직접 접근을 허용하고 테스트만 handlersUtils를 통하도록 했는데, 일관성을 위해 모든 접근을 handlersUtils로 통일하는 것이 더 나을까요?\n\nA. 이건 사용하기 나름인것 같은데요handler.ts와 handlersUtils의 목적을 지영님이 새로 정의해도 될것 같아요. \n말씀하신대로 일관성 측면에서 통일하는 것도 괜찮지만\n발제해주신 코치님의 의도는 조금 다릅니다 ㅎㅎ 이건 솔루션 코드를 보시면서 의도가 파악해보시면 어떨가 싶어요\n근데 그건 뭐 정답이 아니고요 이 과제엔 그런 의도로 만들어진것일 뿐입니다~\n\nQ. MSW의 실무 활용 범위 A. 넵 맞습니다. 실무에서 실제 API를 받기전에 백엔드와 API 스펙협의를 통해 미리 스펙을 파악해두고 MSW로 모킹해서 병렬 개발합니다.\n모든 회사가 그런다고는 할 수 없겠지만, 저는 그렇게하는것을 권장하고 아마 많은 회사가 그럴것 같습니다.\n\nQ. 테스트를 위한 extension\nA. 속도는 통합테스트에 가까워질수록 느려지고 유닛테스트에 가까워질수록 빠릅니다. 이건 어쩔수 없는 트레이드 오프같아요~ 사람 손으로 해도 비슷하니까욥.\n다만 불필요한 속도 저하가 가끔 있을 수 있으니 디버깅하는 테스트 코드도 개선할 필요는 있을 것 같아요.\nHTML을 찾거나 테스트에 유용한도구는 아시다시피 testing-library가 있습니다 :)\n\nQ. 테스트 전략과 균형\nA. 비율은 중요하지 않은것 같습니다. 테스트 전략을 짜기 전에 중요한 것은 적절하게 어플리케이션이 목적과 역할에 맞게 레이어로 추상화되어 분리되어야 합니다. 그리고 이 레이어 별로 유닛테스트(통합) 혹은  E2E테스트 중 어떻게 테스트를 진행할지 정하는 것입니다.\n\nQ. 어느시점에 getBy, findBy 이고 await를 써야 하는지 여전히 어렵습니다.\nA. getBy와  findBy 차이는, 찾아봤는대 없다면 getBy는 바로 에러를 던지고 findBy는 프로미스롤 반환해 일정 기간 기다리고 없으면 reject한다는 차이가 있습니다.",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/62"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "수고 많았어요 창수! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Medium까지 도전하셨네요 좋습니다 기본 과제는 합격입니다.\n\n그렇지만 회고가 너무 아쉽네요. \"시간 관리를 제대로 하지 못해 해결에 급급했던 거 같다\"고 하셨는데, 그 급급한 상황 속에서 어떤 문제가 막혔는지 혹은 왜 시간 관리가 제대로 되지 않았는지에 대해서 무엇을 고민했고 느끼고 배웠는지가 중요해요. 회고는 형식적으로 채우는 게 아니라 학습을 완성시키는 과정입니다. 실습을 통해 몸으로 부딪힌 경험을 글로 정리하는 순간 막연했던 경험이 구체적인 지식으로 바뀌거든요. \n\n가령 \"혼자서 더 파고들어봐야 할 것 같다\"고 하셨는데 무엇을 어떻게 파고들지에 대해서 구체적으로 생각해보고 적어 보는 것도 좋아요. 테스트 코드의 기본 개념일지, MSW 활용법일지, 통합 테스트 작성일지 그때 그때 떠오른 생각들이 있을 거에요. 이런 구체적인 고민들이 회고에 담겨야 다음 학습 방향이 명확해집니다. \n\n생각이라는 것 당시에는 선명해보이지만 막상 글로 적어 보려고 하면 어렵습니다. 무엇이든 구체적으로 적어내려고 하는 시도가 굉징히 중요해요. 지금처럼 그냥 추상적으로만 적어두면 창수님도 저도 다음에 뭘 해야 할지 알 수가 없고 같이 의논해볼 얘기들도 없답니다.\n\n다음 과제에서는 과제하면서 어떤 게 어려웠는지, 새롭게 알게 된 개념은 무엇인지, 막혔던 지점을 어떻게 해결했는지를 구체적으로 써주세요. 시간이 부족해도 그 과정에서 느낀 점들을 기록하는 게 정말 중요합니다. 회고 쓰는 30분이 앞으로 9주간의 학습 효율을 몇 배로 올려줄 거예요. 다음 과제 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/69"
    }
  },
  {
    "passed": false,
    "name": "박형우",
    "feedback": "형우님 고생하셨습니다! \n테스트 코드는 잘 작성해주셨습니다.\n재료라는 표현도 좋네요 ㅎㅎ 뭔가를 준비하는 느낌이니까요.\n테스트를 작성하는 맥락이나 어떻게 작성하시는지는 이제 완전히 이해하신것 같아요 :+1 \n미디엄을 진행하셨는데, 여러 환경 구성이 되어있는 부분에서 진행하셨으니 제가 구성해놓은 부분이 왜 그렇게 되어있는지는 한번 꼭 짚고 넘어가보시면 좋을것 같습니다!\n\n> 자바스크립트 이해도가 부족하여 테스트 코드 작성이 더욱 어렵게 느껴집니다. 자바스크립트 숙련도를 높이기 위한 방법이 궁금합니다. (예: 추천 도서, 학습 방식, 자바스크립트 사고 방식을 구축하는 방법) 사전 스터디 문서에서 API를 읽는 것은 했지만, 실제로 사용하는 것은 처음이라 async와 await 개념 이해가 어렵습니다. 관련하여 참고할 만한 자료나 책이 있다면 추천 부탁드립니다.\n\n좋은데요! 사실 뭔가 다양한걸 먼저 경험하기보다는 하나를 깊게 경험한 뒤에 다양한 걸 공부하는게 좋다고 생각하는 편인데요. \n저는 자바스크립트 코드 작성 방법 자체에 익숙해지는걸로는 코딩문제풀이를 하는것을 추천드리고, 개념을 공부하는건 책을 읽으면서 정리하는 것을 추천드려요! 익숙하지 않은 개념은 실제로 우리가 시험공부하듯이 외우기도 하구요. 강의를 듣는것도 좋지만, 앞으로 우리가 하는 제일 기반이 되는 지식이기 때문에 깊게 천천히 완전 머리에 남도록 하는게 좋거든요. 저는 책을 하나 잡고 누군가에게 강의해주듯이 하면서 책을 한권 다 외웠었는데 그런식도 매우 오래걸리고 피곤하지만 지금까지도 도움이되는 좋은 내용이였던거같아요. 책은 딥다이브도 좋고 코뿔소 책도 좋은데, 전체 내용을 빠짐없이 다루는 책이면 좋을것 같습니다! \nasync와 await의 개념은 당장 필요한 부분이니 강의같은걸 참고해서 우선적으로 개념을 잡고 사용해보시면 좋을것 같구요.\n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/44"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "수고 많았어요 희정! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \n\n과제는 아쉽게도 다 마무리하지 못한 것 같네요. 시간이 부족했거나 개념이 잘 이해가 되지 않았더거나 하는 본인만의 어려움이 있었을테고, 과정에서 뭔가 막혔던 부분이 있었으리라 생각합니다. 과제를 다 완료하는 것도 중요하지만 더 중요한 건 그 과정에서 무엇을 고민했고 어디서 막혔는지를 아는 거예요. 학습을 하러 온거지 시험을 보러 오는건 아니니까요.\n\n그런면에서 회고가 전혀 작성되지 않아서 정말 아쉽습니다. 희정이 어떤 부분에서 어려움을 겪었는지, 테스트 코드 작성이 처음이라 생소했는지, 시간이 부족했는지, 아니면 개념 이해가 안 되어서였는지를 전혀 알 수가 없어요. 사실 과제를 100% 완성하지 못했더라도 \"여기까지 했는데 이 부분에서 막혔어요\", \"이 개념이 이해가 안 가요\", \"시간이 부족해서 여기까지밖에 못했어요\" 이런 솔직한 기록이 있으면 그게 훨씬 더 가치 있는 학습이 됩니다. 그리고 그래야 부족한 부분에 맞춰서 피드백도 하고 도와줄 수도 있어요.\n\n항해하는 10주 동안 매 과제마다 완벽하게 끝내기는 현실적으로 어려울 거예요. 그렇지만 못한 만큼이라도 회고를 통해 내가 무엇을 배웠고 무엇이 부족한지를 기록해두면 그게 쌓여서 나중에 큰 자산이 됩니다. 과제의 진짜 목적은 점수를 따는 게 아니라 내가 뭘 모르고 있는지를 아는 거니까요.\n\n다음 과제는 곧 시작될 텐데 이번 경험을 발판 삼아서 시간 관리를 조금 더 신경 써보세요. 그리고 완성하지 못하더라도 꼭 회고는 솔직하게 써주세요. \"어디까지 했고 왜 못했는지\", \"어떤 게 어려웠는지\"만 적어도 충분히 의미 있는 학습이 됩니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/73"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "수고 많았어요 승현! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \"어 못하겠는데?\"로 시작해서 \"어 못하겠는데?\"로 끝났지만 ㅋㅋ 그래도 Medium까지 완주하셨네요!\n\n\"어 못하겠는데? 로 시작하였으나 일단은 테스트코드를 맛이라도 봐보고 한줄이라도 작성했다는 것에 의의를 두고자 했다. 이전에 나였으면 누군가 테스트 코드를 아냐고 물었을 때, 알지만 경험해 본적이 없다는 뻔한 답변을 하였겠으나 현재는 알고 작성해 본적이 있다라고 답변할 수 있게 되었다. 이 전의 나보다 조금 더 나아진 나라면 그것만으로도 의미 있는 경험이라 생각한다.\" 멋지네요. 해외여행 마냥 한번도 해보지 않은거랑 한번이라도 해본것의 차이는 엄청 큽니다. 테스트를 알고 있다고 한들 한번도 해보기 전과 경험을 해본 나는 전혀 다르죠.\n\n\"테스트 코드에만 너무 집중하고 구현해는 함수 및 훅에 대해서 이해를 못(안)하고 넘어간 부분들 때문에 테스트가 중간중간 막힌적이 많았다.\" 이러한 것들만 봐도 알 수 있습니다. 그냥 테스트 코드를 학습만 했다면 내가 구체적으로 뭘 이해를 못했는지를 전혀 알지 못했을 거에요. 그리고 이러한 함수와 훅등에 주의를 가지게 되고 자연스레 필요에 의해서 학습을 했을거에요. 아마 이 전에는 이러한 코드들을 한번 쯤 보긴 했었겠지만 주의깊게 볼 생각은 못했을 거에요.\n\nvitest, MSW, RTL 모두 생소했을텐데 용어부터 차근차근 정리한 점 좋습니다. 복습하러 넘어가기전에 회고에 주어지는 질문에 대해서 더 답변해보려고 노력하면서 공부를 해보는걸 추천합니다. 내가 많은 것들을 기록하려고 할 수록 훨씬 더 크게 성장할 거에요. \n\n실습 한번으로는 다 알지 못해요. 과제의 실습의 의미는 내가 무엇을 알지 못하고 있는가 무엇을 실제로 중요하게 알아야 하는가를 몸으로 체득하는 과정이라면 회고는 그 인사이트를 아주 구체적으로 기술해서 온전히 내것으로 만들어 가는 과정이랍니다. 다음번에는 훨씬 더 깊이 있는 회고 기대할게요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/70"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "수고 많았어요 수빈! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n커밋 로그를 보니 시간 검증, 알림 검증, 공휴일 검증, 이벤트 검증, 날짜 검증, 달력 뷰 검증, 검색, 이벤트 겹침까지 하나씩 차근차근 쌓아가신 흔적이 보이네요. 특히 마지막에 \"ci 통과를 위한 medium 파일 삭제\"라는 커밋을 보니 medium을 하다가 완성을 위해서 정리하고 마무리를 하는 흔적까지 잘했습니다. 어려운 과제였을텐데 열심히 임해주어서 고마워요.\n\n회고에 이러한 이야기들이 적혀있었다면 했는데 회고가 거의 작성되지 않아서 정말 아쉽습니다. 수빈님이 체계적으로 하나씩 테스트를 작성해 나가면서 분명 많은 시행착오가 있었을 텐데 그게 전혀 기록되지 않았어요. 시간 검증 테스트를 작성할 때 어떤 고민이 있었는지, 알림 검증에서는 어떤 부분이 어려웠는지, 이벤트 겹침 로직을 테스트하면서 뭘 배웠는지, 이런 것들이 회고에 담겨야 해요.\n\n코드만 보고서는 구체적인 피드백을 드릴수가 없어요. 다음 과제에서는 작업하면서 느낀 점들을 꼭 기록해주세요. 여기는 학습을 하러 온 곳인만큼 잘해서 잘 했다는 회고보다는 어디가 고민이고 어렵고 막히고 뭘 해야겠다등을 기록하면서 스스로 방향성을 잡아가는 연습을 해보는게 중요하니까요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "소은님 수고많으셨습니다.\n\n소은님 질문이 조금 디테일하게 남겨주셨으면 많은 도움이 됐을 것 같은데요\nhandlerUtils은 변경내용이 적어서 로직이랄게 없는 것 같은데 제가 뭔가 잘못 보고있는 걸까요?\n리펙토링부분도 조금 디테일하게 궁금한것을 말씀해주시면 좋을 것 같고요.\n작성해주신 테스트를 몇개봤을때 크게 가독성이 문제가 될 만한 부분은 없을 것 같습니다.\n\n수고하셨습니다~",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/32"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "안녕하세요 재현님! 1주차 과제 잘 진행해주셨네요! 고생하셨습니다!\n\n> 과제 내용과는 별개로 이번 과제를 하면서 공식 문서를 잘 못 읽는 것 같다는 생각이 많이 들었는데, 코치님은 공식 문서를 어떤 방식으로 읽으시는지 궁금합니다.\n\n저의 경우 필요한 부분만 찾아서 읽는 편이랍니다 ㅎㅎ\n그리고 cursor 같은 도구를 사용한다면 docs에 연결하여\n\n\"내가 XX 등의 문제를 해결하려고 해. XX 문서에서 관련된 내용을 찾아줄 수 있을까?\" 처럼 남기곤해요.\n\nAI가 있기 이전에는 전체 문서를 한번 쭉 훑어보고(일단 전체 내용을 파악하기 위함) 그 중에서 관심있는 내용만 집중적으로 읽었습니다.\n\n그런데 이런 방식도 1년에 1~2번 있을까 말까...? 였어요. 꼼꼼히 읽진 않았던 것 같네요 ㅋㅋ\n\n여튼 이젠 AI를 적극적으로 활용해보면 좋답니다!\n\n> 테스트 코드를 작성하면서 데이터 세팅 부분을 beforeEach, afterEach 메서드로 분리해보려 했으나, 각 테스트마다 필요한 데이터의 형태가 조금씩 다른 부분이 있어 매 테스트마다 필요한 데이터를 하나하나 설정한 경우가 많았습니다. 따라서 중복 코드가 많아져 코드 가독성이 떨어지는 문제가 발생했습니다. 코치님은 필요한 데이터를 세팅하실 때 어떻게 구성하시는 지 노하우가 궁금합니다 :)\n\n그렇다면 함수로 묶어서 사용할 수 있답니다 ㅎㅎ 잘 묶을 수 있는 구간만 describe를 통해 묶어준다거나!?\n보통 describe로 묶으면 해결되었던 것 같아요!\n\n> 현재 작성된 테스트 코드는 명세서의 역할을 잘 하고 있는가? -> 특히 통합 테스트 부분은 명세서의 역할을 한다기 보단 또 따른 하나의 구현체라는 생각이 많이 듭니다. 한편으론 ui 테스트를 위해선 추가되어야 할 코드가 많기 때문에 테스트 코드가 길어지는 건 어쩔 수 없는 부분이라는 생각도 듭니다.\n\n어떤 방식으로 테스트를 전개할 것인가에 대한 문제라고 생각해요. 지금은 사실 통합테스트가 e2e 와 유사하게 전개되고 있다보니... 어쩔 수 없는 부분이라고 생각합니다. 한 번 테스트를 체험해본거죠 ㅎㅎ\n\n노하우가 조금 쌓인다면 \"정확하게 테스트 하고 싶은 구간\"을 선정하여 테스트를 작성하다보면 효과적이면서도 유지보수하기 용이한 테스트가 될 수 있답니다!\n\n(가령 불필요한 컴포넌트에 대해 목킹을 한다거나..)\n\n\n> 사실 hook 간의 검증을 위해선 코드를 어떻게 작성해야 할 지 감이 안오는데, hook 간의 검증을 위해선 어떤 부분을 고려하여 코드를 작성해야 하는지 코치님의 노하우가 궁금합니다.\n\n```tsx\n// as-is\nconst { result: eventOperations } = renderHook(() => useEventOperations(false));\nconst { result: search } = renderHook(() => useSearch(events, new Date('2025-10-22'), 'month'));\n\n// to-be\nconst { result } = renderHook(() => {\n\treturn {\n\t\teventOperations: useEventOperations(false),\n\t\tsearch: useSearch(events, new Date('2025-10-22'), 'month'),\n\t}\n});\n\nresult.current.eventOperations\nresult.current.search\n```\n\n이렇게 하나의 renderHook에 묶어서 사용하면 자연스럽게 상호작용이 된답니다 ㅎㅎ\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "안녕하세요 진성님! 1주차 과제 잘 진행해주셨네요! 고생하셨습니다\n\n> 단위 테스트의 경우, 테스트 간 데이터 종속성을 없애기 위해 각 테스트 컨텍스트 안에서 독립적인 mock 데이터를 생성하여 일관된 테스트 결과를 보장하는 것이 맞다고 생각합니다. 그런데 통합 테스트의 경우는 상황이 조금 다르다고 느꼈습니다. 여러 모듈이 실제처럼 상호작용해야 하므로, 테스트 전체가 하나의 큰 mock 데이터(가상 DB 개념) 를 기반으로 상태를 공유하는 편이 더 현실적인 시나리오 검증에 가깝지 않을까 생각했습니다. \n\n단위 테스트: 독립성 중심 (mock 데이터 각자 정의)\n통합 테스트: 현실성 중심 (공통 mock 데이터 기반)\n\n이런 식으로 관리하는 접근이 적절할지 궁금합니다. 멘토님께서는 통합 테스트에서 mock 데이터를 어떻게 관리하시는지, 또 테스트 간 상태 공유를 어느 정도까지 허용하는 편이신지도 듣고 싶습니다.\n\n단위 테스트도 공통 mock 데이터 기반으로 관리하면 어떨까요?\n물론 각각의 상황에 필요한 데이터는 직접 만들어서 사용해야할 것 같은데, 이 또한 공용 데이터를 랩핑하거나 오버라이딩해서 사용하면 편하답니다 ㅎㅎ\n\n그리고 저희 조직에서는 테스트간 상태 공유는 허용하지 않는 편이랍니다. 대신 테스트 공용 데이터를 항상 복제하여 사용하는거죠.\n\n목 데이터의 경우 __mocks__ 혹은 __dummies__ 등의 폴더를 구성하여 해당 폴더 내에 테스트용 데이터를 만들어서 관리하고 있답니다!\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "수고 많았어요! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. \"어렵다\", \"답답하고 짜증\", \"한숨만 나온다\" ... 음..  많이 어려웠나 보네요 ^^; 그래도 통과 했으니 한잔하시죠! ㅋ\n\n\"실무에서 리액트를 써본 경험이 거의 없어서 코드 구조 파악에도 시간이 좀 걸렸다\"고 하셨는데, 지금 테스트 코드도 처음이고 리액트도 익숙하지 않은 상태에서 이 과제를 한다는 건 사실 남들보다 두 배는 어려운 상황은 맞아요. 리액트도 해보고 했는데도 불합격하는 사람도 있는데 우선 해냈다는 점에도 앞으로도 9번은 아찔해야겠지만 원래 등산도 하는 동안에는 힘들다가도 일단 오르고 나면 주어지는 성취감이 있잖아요? 화이팅입니다! 내가 해메고 힘든만큼 내 것이 된다고 생각해주세요!\n\n여기 커리큘럼은 모르는 것을 알려주려고 하는 것이니 이미 다 알고 있는 것을 와서 배워보야 시간과 노력만 아까운 거니 오히려 모르는 것을 만나는게 더 낫다고 생각해주세요. \"테스트 코드 라이브러리 자체를 처음 알게 되었으며 전반적으로 테스트 코드에 대한 개념,Vitest API의 전박적인 사용법을 알게 되었다. 단위 테스트를 작성하면서 처음에는 시작을 어떻게 해야될 지 몰라서 고민하는 시간이 많았으나 헤딩하다보니 느낌이 조금 온 것 같다.\" 라는 표현에서 저는 고무적이라고 느껴집니다.\n\nMSW에 대한 이해도가 떨어진다고 느끼신다면, 그냥 실무에서 한번만 써먹어 보려고 한번 해보세요. 실제 repo에 반영하지 않아도 좋습니다. MSW의 개념을 이제 모르는 것이 아닐테니 내 실무에 응용하는 법만 한번 해보고 나면 허탈할 정도로 별거 아니네 하는 순간이 옵니다. 알고 나면 아무것도 아니니까요. 꼭 처음에는 실습을 통해야만 내것이 되므로 개념숙지나 Usage 공부를 넘어서 내 실무에 응용하는 것까지는 꼭 해봐야 합니다!\n\n다음은 궁금한 내용에 대한 답변입니다.\n\nQ) 대부분 테스트 코드를 작성할 때 디스크립션에 맞는 상황 데이터(예시)를 무조건 박아놓고 시작하나요?? 아니면 내부로직에서 상황에 맞게 데이터를 변경해가면서 하나요? 후자의 방법으로 하면 테스트 코드도 길어지고 복잡해 질 것 같다는 생각이 듭니다.\n\n=> 네, 맞습니다! 테스트는 예측 가능해야 하니까 값이 나오는 데이터를 동적으로 만드는게 아니라 상황에 맞는 고정된 데이터를 미리 만들어놓고 시작하는 게 일반적입니다. INPUT -> PROCESS -> OUTPUT 과정에서 구현은 PROCESS를 작성하는 거라면 테스트는 INPUT와 OUTPUT의 틀을 만드는 거죠. \n\n\"확실히 내가 프론트엔드 지식이 부족한 만큼 남들보다 시간이 오래 걸리고 진도가 잘 안나가니 너무 답답하고 짜증이 낫다.\" 답답하다는 마음은 내가 생각하는 이상이 있는데 그 만큼 되지 않기에 느끼는 갭에서 오는 것인데 그만큼 성장에 따른 목표하는 바가 높다고 보여요! 힘들겠지만 지금처럼 꾸역꾸역 해내기를 바래요! \n\n다음 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/71"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "수고하셨습니다 태준! 이번 과제는 테스트 코드 작성의 심리적 장벽을 허물고 테스트의 본질을 이해하는 데 있었는데, 회고를 보니 그 목적을 충분히 달성하신 것 같아 정말 좋네요. 다행입니다. 제가 제출 못한 PR만 보고 너무 빨리 불합격을 줬네요. 미안해요 ^^;\n\n\"테스트 코드는 단순히 Mock을 통해 잘 돌아가는지 확인하는 것이 아닌, 나의 코드의 가장 불안정한 경계부분을 return함으로 완성된 구조를 만들어나가는 과정\"이라는 인사이트가 인상적이네요. MSW를 이용한 상태 분리 과정에서 클로저를 활용해 각 테스트마다 독립적인 스토어를 생성하고, server.use가 함수 실행 시점에 데이터를 캡처한다는 점을 활용한다는 점도 좋았습니다. 이를 통해 병렬 테스트 환경에서의 안정성을 보장할 수 있겠죠.\n\n통합 테스트 부분에서 \"화면상의 값들이 있는지 없는지만 구현\"했다고 아쉬워하셨는데, 이는 충분히 의미 있는 테스트입니다. 사용자 관점에서 보이는 것을 검증하는 것이 통합 테스트의 핵심이니까요. 검색 기능의 경우 단순히 결과 존재 여부를 넘어 올바른 결과만 필터링되었는지, 검색어 변경 시 실시간 반영되는지 등을 추가로 검증하면 더 탄탄한 테스트가 될 수 있습니다.\n\n질문 주신 handlersUtils 구조는 충분히 잘 모듈화되어 있습니다. 제안하신 통합 방식도 좋지만, 현재처럼 명시적으로 분리된 것이 각 함수의 용도가 명확하고 필요한 핸들러만 선택적으로 setup할 수 있어 오히려 더 나을 수 있습니다. 추상화를 하면 나는 잘 알지만 AI가 작성한다거나 혹은 누구든 작성하기에는 복붙이 되더라도 그게 최소한의 코드라면 이렇게 쓰는 편이 가독성과 수정과 독립성 측면에서 더 낫습니다. 추상화된 유틸이 에러나서 테스트 코드가 와장창 깨지는 경험을 하게 된답니다.\n\n테스트 실행 시간에 대해서는 115개 테스트 기준 10초는 합리적합니다. Vitest는 기본적으로 병렬 실행을 지원하므로 테스트가 많아져도 선형적으로 시간이 늘지 않는 편이니 너무 걱정마세요. 테스트 자체가 오래 걸리기보다는 테스트를 띄우는 것에 대한 예열 단계에서 오래 걸리는 것이니 실무에서도 크게 문제되지 않을 거예요. 현재 afterEach에서 cleanup을 잘 하고 계신 것도 메모리 관리 측면에서 좋습니다.\n\nAI 도움 없이 구현해낸 도전정신과 Vitest vi 객체에 대한 체계적 학습이 정말 훌륭했습니다. 이번 경험으로 테스트 코드에 대한 두려움이 사라진 만큼, 실무에서도 꼭 한번 시도해보면서 그 가치를 계속 확인해보길 바라요. 현재 수준이라면 다음에는 심화 과제도 충분히 도전 가능해 보입니다. 다음 과제도 기대할게요! 화이팅!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "수고 많았어요 지훈! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Hard까지 완주하시고 회고도 정말 깊이 있게 작성해주셨네요. 잘했습니다. 합격입니다!\n\n\"첫 날만해도 암흑 속을 걷는 기분이 들었지만\" → \"어려운게 아니라 낯선거였다! 해보면 안될게 없다\"로의 변화가 정말 인상적입니다. 특히 \"마지막 handler 파트는 당장이라도 포기하고 medium으로 내려가고 싶었지만, 꾹 참고 끝까지 도전한 스스로에게 박수를 보내봅니다\" 이 말이 정말 와닿네요. 저도 박수 보냅니다 ㅋㅋ 과제의 취지에 맞게 생소함을 극복하고 끝까지 해줘서 고맙습니다. 테스트의 진짜 어려움은 그 생소함과 왜 해야 하는거지? 를 극복하는거라고 생각해요.\n\n\"테오 코치님께서 멘토링 때 조언해주셨던 '나만의 패턴'이 아직 정립되지 않음을 절실히 느끼게 됐다. 바쁘고 정신없으니 여기서는 공통화, 저기서는 하드코딩\"이라고 하셨는데, 그걸 벌써 의식해주고 적용해주고 있다니 너무 고맙습니다. 나의 코드 일관성을 의식하다보면 둘다 만족할만한 패턴을 뭘까를 고민하면서 적재적소에 좋은 코드를 쓸 수 있을거에요. 9주뒤가 기대가 됩니다! \n\nQ) 통테 시나리오 중 '일정을 삭제하고 더 이상 조회되지 않는지 확인한다'부분에서, 통합테스트에서 \"데이터 변화에 의한 분기처리\" 가능한지 궁금합니다.\n\n통합테스트에서 데이터 기반 분기 처리에 대한 질문이 정말 좋습니다. 답변드리자면, 통합테스트는 기본적으로 \"사용자가 보는 UI\"를 기준으로 검증하는 게 원칙이에요. 그래서 filteredEvents 배열 길이를 검증하기 보다는 눈에 보이는 그대로 화면에 \"검색 결과가 없습니다\"라는 글자가 보이는지 테스트를 하는거죠. 테스트를 INPUT과 OUTPUT을 고정시켜서 구현을 변경했을때 잘 되던게 안되는 회귀 테스트의 목적이 강하므로 분기를 하도록 하기 보다는 각 케이스마다 간결하고 명세와 사용자에게 노출되는 UI를 근거로 작성되는 편이 좋습니다.\n\n남은 9주간 많은 경험을 하면서 자기만의 패턴들을 잘 정립해 나가길 바랍니다. 정말 잘했습니다. 다음 과제도 화이팅입니다! \n\nps. 아! 그리고 같은 팀들이 이번에 생각보다 제출이 부족한데 다음에는 진행을 하고 나면 조금더 적극적으로 팀원들을 도와주면서 더 성장해보길 바래요. 그러면 훨씬 더 다채로운(?) 패턴들을 경험할 수 있을거에요.\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/74"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "예인님 과제는 아쉽네요 :) 차주에는 꼭 완수하시길 바랄게요.\n\nQ. dateUtils 테스트 작성 중 들었던 생각입니다. 많은 분들이 궁금해하셨던 getDaysInMonth 함수의 \"유효하지 않은 월에 대해 적절히 처리한다\"는 테스트 설명 관련해서 고민하다가, 함수가 호출되는 부분이 어디인지 살펴보았습니다.\n// getWeeksAtMonth()\nconst month = currentDate.getMonth();\nconst daysInMonth = getDaysInMonth(year, month + 1);\ngetDaysInMonth 함수는 위 부분에서만 호출되며, month는 currentDate.getMonth()를 통해 얻은 값으로 항상 유효한 범위(0~11)인데, 이런 경우에도 테스트 작성이 의미가 있는지 의문이 들었습니다. 한편으로는 유틸 함수이므로 향후 재사용 될 가능성을 고려해서 작성을 해두는 게 좋은가 싶기도 했는데요. 코치님의 생각은 어떠하신지 궁금합니다.\n\nA. 일단 테스트는 모듈단위로 작성을 해야해요 관계에서 당연했던것이 언젠가는 당연하지 않은 코드가 될 수 있으니까요.\n\ncurrentDate.getMonth() 메서드 테스트에서는 유효한 범위의 값이 리턴되어야하는지를 테스트 하고\ngetDaysInMonth는 유효하지 않은 월에 대해 처리를 하는지 테스트를 하는 것이죠.\n\n그래야 온전한 테스트가 됩니다. 같이 쓰인다고 꼭 셋트로 이렇게 안전하게 사용된다는 보장이 없으니까요\ngetDaysInMonth는 언제든 다른 함수와 사용해도 되는 것이고 그게 안되는 이유도 없는것이잖아요? 그러니까 독립적으로 생각해야합니다.\n이것이 예인님이 말씀하신 재사용에 대한 이야기겠네요.\n\n그리고 \"적절히\"라는 디스크립션은 가급적 피하는게 좋을 것같아요. 정확히 어떻게 처리하는지를 작성해야 나중에 테스트 읽을때 훨씬 수월한 경우가 많습니다 :)\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/59"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "윤지님 고생하셨어요!\nPR도 꼼꼼하게 작성해주시고, 내용을 읽어보니 어떤 부분들에 고민이 많았고 어떻게 해결을 했는지 잘 이해할 수 있었습니다 :+1\n잘 읽었고 그 과정에서 윤지님이 핵심을 잘 파악하고 해결하시는 부분이 드러나는것 같아요! 앞으로가 기대됩니다 ㅎㅎ\n\n궁금하셨던 부분 답변을 가볍게 남겨보고 마무리해볼게요.\n\n> 1. 테스트 독립성 검증\n\n\n> 1. 목 데이터 관리 방식\n\n데이터가 어디 있다! 라고 명확한 규칙을 만들고 관리하는건 가독성 측면이나 추후 유지보수성에 있어서도 중요한 지점인것 같아요. 지금도 나쁘지는 않지만 명확한 규칙을 만들고 이름에서 이 테스트 케이스가 어떤 의미인지드러나도록 해서 운영하면 더 좋을것 같아요!\n\n> 2. 테스트 검증 범위\n\n지금도 나쁘지 않은데요! 결국 유저가 가능한 모든 케이스들에 대해 대응을 하는것도 필요하고 극단값, 경계값등을 기준으로 테스트를 작성하면서 운영하고, 내가 예측하지 못한 범위에서 문제가 발생한다면 회귀 테스트 관점에서 테스트를 지속적으로 늘리면서 운영을 하면 된다고 생각해요.\n\n> 1. 테스트 코드 작성 시작점\n\n기준이 있다면 각자가 너무 상대적인 기준을 갖게되서 제가 회사에서 운영했을때는 가능하면 대부분의 케이스는 테스트를 작성한다로 갔을 때 효과적이였던것 같아요! 별개로 지금처럼 이미 있는 코드를 기반으로 테스트를 작성하는 경우도 있고, 새로운 피처에 맞춰 작성하게 되는 경우도 있는데 이런 관점에서 판단을 한다면, 비즈니스 관점에서 중요도와 복잡도를 기준으로 테스트를 작성할지말지 결정하면 될 것 같아요!\n\n> 2. 적절한 테스트 방법 찾기\n\n결국 이건 사용하는 라이브러리의 철학을 따르는게 중요하다고 생각해요! 발제때도 언급하긴 했지만, RTL이라는 라이브러리가 유저의 시나리오와 유사하게 테스트를 운영하는것에 중요함을 강조하고 쿼링, 이벤트 발생 방식등 모든게 이 것을 기준으로 우선순위가 작성되어있다보니 우리도 이런것들에 맞춰 선택하고 발생시키면 되지 않을까로 맞춰지는거죠. 추가로, 제가 이 테스트를 설계하고 무엇인가를 검증하고자할때 내 의도를 잘 드러내는 API가 있는지를 확인해봐야하는데, 지금은 익숙해지시느라 AI의 사용을 막았지만 앞으로는 AI도구들을 잘 활용해서 필요한것들을 찾아서 검증해보고 사용해보는 방식으로 좀 더 편하게 할 수 있지 않을까 싶어요!\n\n고생하셨고, 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/25"
    }
  },
  {
    "passed": false,
    "name": "이정민",
    "feedback": "안녕하세요 정민님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> setupTests에서 전역적으로 타이머를 설정했을 때, 각 테스트 내에서 타이머를 독립적으로 관리하려면 어떤 방식이 가장 안전할까요? 특히 테스트 간 타이머 충돌 문제를 방지하는 방법이 궁금합니다.\n\n테스트간 타이머 충돌이 발생하는 이유는, 타이머를 \"비동기\" 상태로 관리하기 때문인데요\n자바스크립트의 경우 싱글스레드를 사용하기 때문에 fakeTimer를 사용하여 동기식으로 변경하여 병렬로 실행해도 콜스택에 쌓이도록 한다면 큰 문제가 없답니다 ㅎㅎ\n\n여튼 beforeEach에서 페이크 타이머를 만들어서 사용하면 아마 타이머간 충돌이 발생할 확률이 굉장힌 낮지 않을까요!?\n\n근데 이게 제가 이해한 내용이 맞는지 모르겠네요.. ㅋㅋ\n필요할 때만 초기화 하고 싶다면 setupTests 에서 관리하면 안 되겠죠? 필요한 곳에서만 초기화를 해야 한답니다.",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/66"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "수고 많았어요 현지! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.\n\n커밋 로그를 보니 40개나 쌓으면서 getDaysInMonth, getWeekDates, getEventsForDay, eventOverlap, notificationUtils 등 정말 체계적으로 하나씩 작성해 나간 흔적이 보이네요. \"이번주 급하게 회사 일정이 마구 잡혀서 정말 진득하게 못봐서 아쉽다\"고 하셨는데, 그 바쁜 와중에도 이렇게 끝까지 포기하지 않고 40개 커밋을 쌓은 게 정말 대단합니다.\n\n지금 CI에서 lint와 test가 실패하고 있고 conflict도 해결이 필요한 상태예요. 혹시 로컬에서는 테스트가 통과했는데 CI에서만 실패하는 건지, 아니면 마지막 마무리를 못한 건지 궁금하네요. 아무리 코딩을 많이 해도 빌드가 안되는 코드 PR은 완성이 안된거고 merge할 수 없듯이 코드도 중요하지만 마무리가 중요합니다.\n\n그리고 정말 아쉬운 건 회고가 거의 작성되지 않은 거예요. 현지가 40개 커밋을 쌓는 과정에서 많은 시행착오나 혹은 고민들이 있었을 텐데 그 스토리가 전혀 기록되지 않았어요. \"테스트가 처음\"이라고 하셨잖아요. 그렇다면 더더욱 어떤 부분이 어려웠는지, 어디서 막혔는지, 어떻게 해결했는지를 기록하는 게 중요합니다. 학습을 하러 온 거지 내 능력 측정을 하러 온게 아닌만큼 성장을 위해서는 그 과정을 아주 구체적으로 기록해보는 연습을 해보세요.\n\n지금은 요구조건을 충족하지 못해서 불합격이지만 언제라도 수정을 하게 되면 알려주세요. 재검토할게요. `npm run test`와 `npm run lint` 돌려서 에러 확인하고 수정해주세요. Medium 질문들에 대한 답변도 채워주시고요. 회고는 바쁜 와중에도 \"여기까지 했는데 이런 부분이 어려웠어요\", \"시간이 부족해서 이 부분은 못했어요\" 이렇게 솔직하게 써주시면 됩니다. 그것만으로도 충분히 의미 있는 학습이니까요. 수정하시면 연락주세요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/5"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "수고 많았어요 이진님! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Hard까지 완주하시고 회고도 정말 깊이 있게 작성해주셨네요. 잘했습니다. 합격입니다!\n\n\"이전 회사에서 테스트 코드를 작성해야만 코드 리뷰 요청을 할 수 있어서 반강제적으로 테스트 코드를 작성하곤 했었는데요. 사실 테스트 코드에 대한 지식도 전무했는데 시간내어 공부할 수 있지도 않았습니다. 부끄럽지만,,, 팀원들이 이미 잘 작성해놓은 테스트 코드를 훔쳐보며 작성하다보니 어렴풋이 느낌으로만 알고 지나쳤던 것들을 되돌아볼 수 있는 과제였습니다.\" 라는 회고가 제일 눈에 들어오네요. 사실 실무에서 테스트 경험이 없는 친구들을 중심으로 만든 과제이지만 테스트에 대해서 생각이 더 깊이있게 해볼 수 있게 된 계기가 된것 같아 좋습니다.\n\n사실 많은 개발자들이 실무에서는 정작 마감에 쫓겨서 제대로 이해할 시간 없이 일단 돌아가게만 만들고, 왜 그렇게 하는지는 깊이 고민하지 못하는 경우가 많죠. 이번 과제가 실무에서 접하는 것들을 어떻게 하면 내 것으로 만들 수 있는지를 고민해보는 시간이 되었기를 바랍니다. 앞으로도 남은 9개의 과제들을 통해서도 실무와 연관 지어서 어떻게 확장할 수 있을지 고민해보면 좋겠습니다.\n\n\"대충 시키는대로 하면 되지 않나?~!\"에서 시작했는데 몰입하면서 \"한 번 의문을 가지니까 다른 것들에 다 의문을 가지게 되고\"로의 변화가 정말 멋지네요. 실무에서 반강제로 했던 경험이 있었기에 오히려 이번에 더 깊이 파고들 수 있었을 거라 생각하며 실무 경험을 되돌아보고 제대로 이해하는 시간을 가지는 방법을 이번 전체 커리큘럼에서 가져가게 되길 바래요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/57"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "안녕하세요 희재님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n> mock 데이터의 위치와 변수명에 대한 고민이 많았습니다. 테스트 코드를 작성하다보면 비교가 필수적이라 자연스럽게 많은 양의 변수가 필요하게 되는데, 이 변수명의 가독성과 팁이 궁금합니다.\n\n흠.. 굳이 변수를 선언할 필요가 있을까? 라는 생각도 들어요 ㅎㅎ 선언하지 않아도 되는 구간은 그냥 리터럴로 표현하면 어떨까 싶습니다.\n\n> 전체적인 테스트코드의 가독성이 어떤지, 가독성이 떨어지는 부분이 있다면 어느 부분이고 어떻게 개선할 수 있을지 궁금합니다.\n\n전체적으로 중복코드를 제거하기 위한 노력을 많이 해주신 것 같아요. 그런데 테스트의 목적이 중복코드 제거가 맞을까요? 저는 \"정확한 값을 검증하는 것\"과 내가 아닌 다른 사람이 테스트를 읽었을 때 쉽게 이해할 수 있는지가 중요하다고 생각해요. 그래서 테스트를 작성하는 방식과 일반적인 코드를 작성하는 방식이 달라야한다고 생각합니다.\n\n지금은 변수와 다양한 함수로 랩핑되어 \"코드가 감춰진\" 상태로 값을 검증하는 경우가 많아요. 그니까, 테스트를 통해 값을 해석하는 과정이 필요하다는거죠.\n\n가독성에 대한 견해를 어떤 기준으로 정해야 할지 모르겠으나.. 개인적으로 \"깔끔한 코드\"는 맞지만 \"읽고 이해하기 쉬운 테스트\" 와는 다른 결이라고 생각합니다.\n\n> 테스트 코드의 성능과 효율성에 대해서는 거의 고려하지 못하고 코드를 작성했는데, 실무에서는 이 부분에 대해서도 충분히 고려해야 할 것 같다는 생각이 듭니다. 비효율적인 테스트 코드의 특징이 있다면 어떤 것일지, 제 코드에서 부족한 부분이 있는지 궁금합니다.\n\n아직은 성능에 대한 병목이 없는 상태인데요, 병목이 있다면 보통 비동기 코드 때문에 발생할 확률이 높답니다 ㅎㅎ 혹은 테스트 코드가 아닌, 실행 코드 자체가 오래걸린다거나!?\n\n그리고 어떤 테스트 라이브러리를 사용하냐에 따라 속도가 달라요. 어떤 테스트 도구가 있고, 각각 어떤 차이가 있는지 찾아보시면 좋을 것 같네요!\n\n> 약간 포괄적인 질문이지만 제가 미처 생각하지 못한 관점에서 놓친 부분이 있다면 알려주시면 감사하겠습니다.\n\n사실 전체적으로 포괄적인 질문인데요, 이럴 경우 좋은 피드백을 드리기가 어려워요.\n\n희재님이 신경쓴 코드와, 그 근거에 대해 설명을 해주셔야 더 정확한 피드백을 드릴 수 있답니다 ㅎㅎ\n\n\n\n\n\n\n\n\n\n\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/52"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "안녕하세요 나리님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 테스트 디스크립션 작성과 테스트 케이스 분리가 적절하게 된 것인지 궁금합니다.\n\n어떤 부분을 신경쓰면서 작성했고, 어떤 기준으로 분리했는지를 말씀해주셔야 더 정확한 피드백을 드릴 수 있답니다!\n\n가령 이런 질문에 대해 답변드릴 수 있는건.. \"적절하게 되었네요\" 인데요 왜 적절한지가 궁금한거겠죠?\n\n마찬가지로 나리님이 가지고 계신 적절함의 기준에 대해 이야기 해주시면 좋아요.\n\n어쨌든 답변 드리자면,\n\n<1. 명확한 테스트 구조>\n\n- describe로 함수별 그룹화가 잘 되어 있음\n- 각 it 블록이 하나의 명확한 시나리오만 테스트\n\n<2. 구체적인 테스트 설명>\n\n- \"1월은 31일 수를 반환한다\" - 입력과 예상 결과가 명확\n- \"윤년의 2월에 대해 29일을 반환한다\" - 특수 케이스 명시\n- \"유효하지 않은 월에 대해 '유효하지 않은 월입니다...'라는 에러를 반환한다\" - 에러 메시지까지 명확히 기술\n\n<3. 경계값 테스트>\n\n- 월초/월말, 연초/연말, 윤년 등 엣지 케이스 잘 포함\n- 유효/무효 입력 케이스 구분\n\n\n> events 객체를 각 describe 함수 스코프 내에서만 동일하게 사용하도록 정의한 경우가 많은데, expect(result).toBe()로 검증할 때 events.title 이렇게 참조로 사용하는 것보다 ‘일정 타이틀’ 이라는 원시값 그대로 사용하는게 나을까요? 원시값으로 사용하면 너무 코드가 길어지고, 참조로 사용하면 데이터가 오염되었을 수 있어서 고민되었습니다.\n\n변수로 검증할경우 어떤 값이 들어있는지 다른 사람이 파악하기가 어렵기 때문에, 테스트 목적에 적합하지 않다고 생각해요! 그래서 리터럴(원시값)을 사용하는 방식을 추천드립니다!\n\n코드가 길어지는게 사실 그렇게 문제일까? 라고 생각해보면 큰 문제는 아니라고 생각해요 ㅎㅎ\n\n코드를 에디터에서 접어서 사용할수도 있으니까요!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "한슬님 그래도 시도해본 게 어디입니다 :)\n다음에는 조금 더 난이도를 낮춰서 도전해보시면 어떨까해요!\n수고많으셨습니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/38"
    }
  },
  {
    "passed": false,
    "name": "주민수",
    "feedback": "민수님 한 주간 고생 많으셨습니다\n작성해주신 테스트를 보니 각 순서에 맞게 필요한 코드들을 잘 작성해주셨어요\n어느정도 자주 작성을 하다보니 어떤 패턴으로 테스트가 운영이 되는건지 감을 잡으셨으면 좋았겠네요 ㅎㅎ\n이벤트는 필요에따라 5개나 운영을 하고 있는데, 이게 꼭 다 필요한 이벤트인지는 고민해보면 좋을것 같습니다.  컴포넌트 테스트도 꼭 작성해보시면 좋을것 같아요!!\n\n> '새로 정의된 'title', 'endTime' 기준으로 적절하게 일정이 업데이트 된다' 에 대한 테스트 과정에서 useEventOperations의 onSave 함수를 사용해서 테스트를 할 수 있지 않을까 하는 생각이 들었습니다. 일반적으로 테스트 대상이 되는 코드에 enqueueSnackbar처럼 스파이 하기 좋은 함수가 항상 딸려있지는 않을 것 같은데 이런경우의 테스트는 어떻게 진행되는지 궁금합니다. 목킹을 조금 더 고도화하는 방법으로 가게 되는지, 그 외의 방법이 있을까요?\n\n결국 모킹하는 방식은 다 거기서 거기라고 생각하는 편인데요.\n지금처럼 스파이 하기 좋은 함수를 넣기 좋게 만드는 방법도 있을것 같고, 모듈 자체에 대한 모킹을 재정의할수도 있구요. 내가 작성하는 코드라면 테스트하기 좋은 검증방향으로 리팩토링할 수도 있구요. 말씀하시는것처럼 고도화라기보다는 약간약간씩 틀어서 다른 방법으로 하는거니 크게 걱정하지 않으시고 그 상황이 닥치면 고민해보는걸로 하셔도 충분할겁니다 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!!!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/67"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "재윤님 수고 많았어요! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다.... 만 그걸 뛰어넘어서 Hard까지 완주하시고 회고도 정말... 압도적이네요. \"항해 시작하고 면도할 시간도 없었다\"는 말에서 얼마나 몰입했는지 느껴집니다! 수고했습니다.\n\n무엇보다 준형님과 영서님과의 협업 학습 과정을 엿볼 수 있어서 너무 좋았습니다. Fake Timer의 동작 원리를 바탕으로 함께 의논하고 고민하면서 깊이있는 개발적 고민을 함께 나누는 과정에서 피상적으로 그치는게 아니라 아주 상세하고 구체적인 내용까지 이어져가는 부분이 너무 인상적이네요. 피드백을 어떻게 써야 할까 되려 막막해지네요. 많은 사람들이 볼 수 있도록 Best Practice를 줘야겠다 생각 뿐입니다. \n\nQ) 테스트 코드의 리팩토링 시점이 궁금합니다! 테스트가 통과하면 테스트 코드는 건드리지 않는다 vs 테스트 코드도 지속적으로 개선한다 중,\n\n=> 테스트는 말 그대로 명세이자 검증의 도구인 만큼 테스트 코드가 기준이 되고 소스 코드를 그에 맞게 바꿔야 하는게 맞습니다. 그렇지만 테스트 코드는 명세를 구체화 한것인만큼 명세가 바뀌었다면 당연히 테스트 코드도 그에 따라 리팩토링이 되어야겠지요. 명세 > 테스트 > 구현 순으로 변화의 의존성이 있고 이를 따라가는 것이라고 생각하면 되겠습니다. 그래서 요구사항이 너무 자주 바뀌는 순간에는 테스트 코드를 만들기가 참 어려운 것이지요.\n\n너무 너무 잘했습니다. \"아직도 잘한건지,,맞는건지도 사실 모르겠습니다🥲\" 라고 했지만 그랬다면 이렇게 상세한 회고를 쓸 수가 없어요. 잘한다의 기준은 얼마나 나의 경험과 기술적 해상도가 선명해지는가 라고 생각해주세요. 아주 선명한 고민들의 지점들이 어느순간 다 촘촘하게 연결이 될거에요! 다음 과제도 기대할게요!\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/23"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "안녕하세요 진아님! 1주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 테스트코드는 명세의 역할을 할수 있다고 알고있습니다. 그렇다면 테스트 작성시에 함수의 반환값을 그대로 비교하는 것이 좋은 방식인지, 아니면 올바른 조건을 찾아내서 그 조건을 검증하는것이 좋은 방식인지가 궁금합니다.\n\n저의 경우 반환값을 그대로 비교하는 것을 선호한답니다! 그래야 인풋에 대한 아웃풋을 정확하게 알 수 있다보니, 작성자가 아닌 다른 사람도 \"아~ 이 값을 만들어내기 위함이구나!\" 라고 생각할 수 있지 않을까요!?\n\n테스트는 중복을 줄이는 것을 목표로 하기보단, 정확한 값을 표현하는 것을 목적으로 하는게 좋아요! 그리고 사이드 이펙트를 찾아내야 하기 때문에, 어떤 변수에 연결이 되어있다면 변경에 대한 여파를 찾아내기가 어려울 수 있답니다.\n\n> hadlersUtils에서 제가 사용한 방식이 맞는 방식인지가 궁금합니다. http.post핸들러에서 요청한걸 가로채는(?) 방식을 사용했는데, 현재 코드상에서는 post요청의 응답에 영향이 가지는 않을 것 같긴합니다. 하지만 요청 중간에 어떤 동작을 넣은지라 해당 코드가 이후에 다른 누군가에 의해 수정되거나 하면 기존에 보내는 post 요청의 응답에 문제가 생길 수도 있지 않을까 하는 찝찝함이 있는 것 같습니다.\n\n말씀하신 것 처럼 다른 사람이 수정하게 되면 문제가 생길 수 있죠 ㅎㅎ 그러면 그 분이 해결해야셔 하는게 아닐까요..? ㅋㅋㅋ\n그리고 문제가 생기는게 당연하다고 생각해요. 저는 테스트가 \"문제를 발견하기 위한 과정\" 이라고 생각하는데요, 현재 작성된 방식으로 원래 잘 동작하다가 다른사람이 수정해서 무언가 잘 안 된다면, 테스트로 잘 기능하고 있는게 아닌가!? 라고 생각합니다!\n\n문제가 있는데 잘 동작하면 안 되니까요!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/4"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "선민님 과제는 아쉽지만 차주에는 꼭 완수하길 바랄게욥!\n\nQ. medium.useEventOperations.spec.ts 의 주석내용\nA.  handler.ts를 보면 404를 처리하도록 되어있어서 유효하지 않은 id를 전달하면 404가 뜨게되어있습니다.\n굳이  setupMockHandlerUpdating를 실행하지 않아도 될 것 같습니다~\n\nQ. easy.notificationUtils.spec.ts의 주석내용\nA. 데이터를 재현하기 힘들거나 사이드이팩트를 재현하기 힘들때는 끌어다 쓸때도 있는데요.\n독립적인 테스트를 위해 지금 코드와 같은상황에서는 title에 해당하는 스트링을 직접 사용하는것이 더 나아보입니다.\n그게 더 코드가 간결하고 이해하기 쉬우며, 내부구현도 드러나지 않는 것 같아요.\n\nQ. easy.useCalendarView.spec.ts의 세번째 주석내용\nA. 모든 경우의 input에 대해 테스트를 진행하는 것이 맞습니다.\n값의 범위 인경우 중앙값(근처)과 경계값만 테스트해도 충분한 경우가 많은데요.\n지금 테스트 코드는 범위도 아니고 명확한 기능에 해당하기 때문에 테스트를 작성하는 것이 맞습니다.",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/77"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "한세준",
    "feedback": "세준님 고생하셨습니다~\n굉장히 깔끔하게 후기도 정리해주시고 어디에 집중해서 과제를 진행하셨는지도 알게 될 수 있어서 좋았어요 :+1\n의도에 맞게 잘 작성해주시고 적절한 API들도 사용해주셨네요\n\n특별히 언급드릴만한건 없고, https://discord.com/channels/1288769861589270590/1406181037045973132/1431268008478773430 요기 있는 내용만 한번 테스트에 녹여보시면 좋지 않을까! 싶습니다.\n\n따로 피드백 요청 주신건 없어서 많이 작성하진 않았어요 ㅎㅎ\n지금처럼 앞으로도 잘 진행해주시면 좋겠습니다. 파이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/13"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "수고 많았어요 채은! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. 처음으로 테스트 코드를 작성해보셨다니 비록 하지만 합격 조건은 충족하질 못했지만 Easy 과제 완료 축하드립니다. 합격 / 불합격은 학원측에서 동기부여를 위한 장치일뿐 결국 핵심은 이를 통해 얻어가는 새로운 성장인만큼 지금처럼 할수 있는데까지 계속 해보고 제출해보길 바래요!\n\n\"사실 테스트 코드는 만든 서비스 기반으로 AI가 만들어준거 사용하면 되지않나?? 라고만 생각했다가 직접 짜보니 신경쓸 부분이 상당히 많았다. 그러다보니 문득 AI가 짠 테스트 코드에 대한 불신이 생겼다\"는 인사이트가 정말 좋네요! 맞아요, AI는 문법적으로 맞는 코드를 만들 수 있지만 제대로 만들어 줄 확률이 너무 낮기에 꼭 내가 다 확인을 할 수 있어야만 합니다. AI를 시킬때 내가 못하는건 대신 시킬수는 없으니까요. 역시 개발자라면 기본기가 중요한거겠죠!\n\n\"개념을 좀 더 익히고 과제해야지\" → \"일단 부딪혀보기\"로의 변화도 정말 중요한 깨달음이에요. 처음에 강의 듣고 개념 이해하는데 시간을 많이 쓰셨다고 하셨는데, 사실 개념만 익히는걸로는 절대 실전 감각이 안 생겨요. 발제는 어떤 세상이 있는지를 알려주는 것일만 일단 부딪혀보면서 \"아 이게 이런 거구나\"를 몸으로 체득하면서 궁금증을 다시 이론으로 찾아가면서 점점 깊어지는 학습을 하는것이 정말 중요합니다. 결국 개발도 운동 같은거라서 해야 늘거든요. \n\n질문 주신 부분들에 답변드리면, 검색 기능에서 결과값이 실제로 title, description, location에 포함되어 있는지까지 검증하는 건 과도할 수 있어요. 검색 결과가 있다는 것만 확인하면 충분하고, 상세한 검증은 검색 함수 자체의 단위 테스트에서 하면 됩니다. 데이터 설계는 지금처럼 테스트 케이스를 보고 필요한 데이터를 만드는 게 맞아요. 미리 완벽한 데이터를 만들려고 하면 오히려 복잡해집니다. 테스트 코드의 핵심은 필요한 만큼 하는건데 그건 그때 그때 달라서 이렇게 해야 한다고 말해도 상황에 따라 달라지므로 일단 잘 배워뒀다가 실무에서 써먹을 수 있을때 써먹으면서 효용체감을 높여보길 바래요.\n\n회사 다니면서 학습 병행하려면 루틴과 습관을 만들어 두고 싶다 했는데, 아재 앞으로 9개 과제 남았으니 조금씩 페이스 잡아가면 됩니다. 갓생 루틴과 습관 만들어 보자구요. 다음 과제도 화이팅입니다!\n\n",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "수고 많았어요 준태! 이번 과제는 테스트를 하는 다양한 방법들을 접하면서 테스트 코드를 작성한다는 그 심리적 장벽을 허물고 친숙해지는데 있었습니다. Hard까지 완주하시고 회고도 정말 깊이 있게 작성해주셨네요. 잘했습니다. 합격입니다!\n\n\"항해 1주차를 시작하는 주간에 회사 업무가 갑자기 바빠져서 과제를 푸는 데에만 급급했다\"고 하셨는데, 그 바쁜 와중에도 Hard까지 완주한 게 정말 대단합니다. 특히 \"머릿속에 정리가 안 되어 있던 개념들이 과제를 풀면서 하나 둘 씩 이해되는 과정이 재밌었다\"는 표현이 너무 좋아요. 사전 스터디를 해온 준비성도 훌륭하고요. \"간단한 유틸 함수 테스트로 시작해서 커스텀 훅, 컴포넌트로 늘려나가면 되겠다\"는 인사이트도 정확합니다. 이게 바로 테스트 코드 도입의 시작점이에요.\n\n\"평소 테스트 코드에 관심이 있어서 예전부터 책도 읽어보고 강의도 찾아 봐왔는데, 막상 실제 업무에서 사용하기에는 우선 순위에서 밀리고 도메인 특성 상 어디서부터 시작해야 할지 막막했다\"고 하셨는데, 많은 개발자들이 똑같은 고민을 해요. 그런데 이번 주차를 통해 자신감이 들었다니 정말 뿌듯하네요. 이제 실무에 적용해보면서 효용체감을 느껴보길 바랍니다.\n\n질문 주신 부분들 답변드릴게요.\n\nQ) 시간과 관련된 테스트 유틸 함수들을 적절히 잘 사용했는지, 더 좋은 방향이 있는지 궁금합니다! HTML 요소에 접근할 수 있는 방법이 다양하다고 느껴졌는데, 적절히 잘 사용했는지 궁금합니다. 이벤트(일정) 데이터를 관리하기 좋은 디자인 패턴이 있을까요?\n\n=> 네. 코드 확인해 봤는데 시간 관련 유틸 함수들 잘 사용하셨습니다. vi.setSystemTime, beforeEach/afterEach 조합이 정석이에요. 테스트가 많아지면 setupTests.ts에 타이머 설정을 전역으로 두는 것도 방법입니다. \n\n=> HTML 요소 접근은 data-testid 잘 활용하셨네요. 나중에 getByRole, getByLabelText 같은 쿼리들도 살펴보시면 좋아요. 사용자 관점에서 요소를 찾는 방식이라 접근성 테스트에도 도움됩니다.\n\n=> 이벤트 데이터 관리는 클로저로 격리한 방식 훌륭합니다. \"이벤트 객체를 생성하는 함수\"라고 개선안에 적으신 것처럼 createMockEvent({ title: '회의' }) 형태의 Factory 함수를 만들면 기본값은 다 채워두고 필요한 속성만 덮어쓸 수 있어서 편해요.\n\n=> 리뷰를 원하는 것에 비해서 대답이 피상적인데, 질문이 추상적이다보니 답변의 추상화 수준도 비슷할 수 밖에 없네요ㅠㅠ 다음에 조금 더 구체적으로 물어보면 더 구체적으로 리뷰를 해볼게요.\n\n\nQ) server.js에 있는 API 메서드들을 똑같이 참고하여 msw handler를 작성하는 것을 의도하신 걸까요? \t* 예컨대, server.js의 delete 메서드에는 id가 HIT인 경우만 있고 MISS인 경우에 대한 예외 처리는 없는데, msw handler에서도 해당 예외 처리가 없어야 하는건지 궁금합니다.\n\n=> MSW는 실제 서버에서 테스트하기 어려운 동작들을 mocking을 테스트를 하기 위한 용도입니다. 테스트를 위해서 삭제를 반드시 해야만 한다면 테스트하기가 어려울테니 HIT인 상황을 만드는 것이죠. 반대의 경우 삭제 실패의 경우 에러메시지를 테스트해야 하는데 서버에서 실패를 하도록 만들기는 어려운 상황이니 이 테스트를 위해서는 MSW에서 MISS를 만들어야겠죠. 서버의 의존도 없이 테스트를 하기 위한 도구라는 측면에서 예외처리가 아니라 무엇이 필요한지를 생각하면 어떤 핸들러를 만들면 좋을지 도움이 될거레요.\n\n\nQ5. 인플루언서 마케팅 도메인 테스트 방향\n\n=> 테스트 커버리지가 100%이면 좋겠지만, 그래서 사실 처음부터 테스트를 만들어가면 되겠지만 현실은 대부분 그러지 못하고 (심지어 대기업 현업에서도 그렇게 하는 팀이 소수입니다 ㅠ) 한번에 대청소를 하려고 하면 힘들죠. 일단 테스트가 필요하다고 느껴진다면 앞으로 새로 만드는 것은 항상 테스트를 만든다는 식으로 컨벤션을 가져가야겠지요.\n\n=> 그리고 모든 테스트의 용도 측면에서 우선순위를 조정해볼 수 있습니다. 리팩토링시 장애감지등을 원한다면 최초 랜딩이 제대로 되는지를 먼저 확인해볼 수 있고, 매번 복잡한 시나리오라 항상 자주 버그가 나는 곳이 있다면 해당 구간은 테스트를 만들어 두면 좋습니다. 사람이 재현하기에 복잡한 상황이나 테스트 경로가 깊은 곳의 디버깅이 어렵다면 그 부분을 테스트로 먼저 만들어 보는 것도 좋습니다.\n\n=> 진짜 어렵기는 한테 디버깅을 하다가 막혔을때 테스트를 고민해보면 좋습니다. 물론 이때는 그 생각을 잘 못하게 되고 버그를 고치고 나면 일단 되니까 다음에 하지 뭐 이렇게 되는게 보편적이기는 하나 자주 버그가 나는 곳에는 테스트가 필요하다는 의미죠. \n\n정말 잘했습니다. \"간단한 유틸 함수 테스트로 시작해서 커스텀 훅, 컴포넌트로 늘려나가면 되겠다\"고 하셨는데, 이제 실무에서도 그렇게 시작해보세요. 인플루언서 마케팅 도메인에서 24가지 케이스를 한 번에 다 하려고 하지 말고, 앞으로 새로 만드는 기능부터 테스트를 작성하거나 자주 버그가 나는 부분 하나부터 시작하면 됩니다. 이번 과제로 자신감이 생겼다고 하셨으니 충분히 할 수 있어요. 다음 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP02 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-1/pull/75"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/35"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/14"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/41"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/63"
    }
  },
  {
    "passed": false,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/18"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/51"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/8"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/36"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/17"
    }
  },
  {
    "passed": true,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/9"
    }
  },
  {
    "passed": false,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/64"
    }
  },
  {
    "passed": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/24#issue-3554698751"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/37"
    }
  },
  {
    "passed": false,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/32"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/26"
    }
  },
  {
    "passed": false,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/19"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/46"
    }
  },
  {
    "passed": false,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/15"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/30"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/50"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/43"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/12"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/16"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/6"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP03 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/49"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "수고 많았어요 승훈! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. \n\n\"AI에 대해 항상 가볍게 질문하고 문제에 대해서만 쉽게 질문했었는데, 에이전트라는 개념과 실제 사용을 통해 많이 배웠습니다\"라는 회고가 과제 취지를 잘 경험한 것 같아 좋네요. 무엇보다 프롬프트를 점점 더 구체화하고 정교하게 만들어가며 5개 에이전트 시스템을 설계한 과정이 좋았습니다. GPT → Cursor → Notion AI로 넘어가며 프롬프트를 개선하고, 각 에이전트마다 페르소나·역할·승인 프로세스·재시도 메커니즘을 체계화 해가는 부분이 참 좋았습니다.\n\n기술적으로도 31일 매월 반복, 윤년 2월 29일 같은 엣지 케이스를 처리했고, 기존 코드베이스를 분석해 재사용한 점도 괜찮았습니다.\n\n아쉬운 점은 이렇게 열심히 했는데 과제에서 요구한 심화 과제 리포트를 요구사항에 맞게 작성을 해봤으면 좋았을거라 생각을 해요. 그러면 AI에 대한 경험을 넘어 승훈의 깊이 있는 생각을 들어 볼 수 있었을텐데 하는 생각이 들었습니다. \n\n리포트 보완하고 싶으시면 언제든 알려주세요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/35"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "수고 많았어요 다솜! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 아주 잘했습니다.\n\n\"AI에 대한 불신이 강했는데, 이번 과제를 통해 AI를 단순한 코드 생성기가 아니라 함께 일할 수 있는 협업 파트너로 바라보게 되었습니다\"라는 회고가 과제 취지를 정확히 경험하신 것 같아 너무 좋네요. 심화과제의 마지막 멘트인 \"사람이 가드레일을 깔고, AI가 가속한다\"는 멘트가 인상적이었습니다.\n\n우리가 문제 해결에 있어서는 창의적이어야 하지만 코딩은 사실 창의적이지 않는 편이 좋습니다. 클린코딩이나 lint만 보아도 죄다 뭘 하지 않도록 하는 것이지요. AI가 너무 창의적인(?) 나머지 정해진 작업 내에서는 인간보다 빠를 수 있고 편리할 수는 있지만 여전히 개발자의 컨트롤 하에 있어야 하죠. 작성해준 코멘트처럼 가드레일을 확실히 깔아두고 항상 지켜보는 연습을 하면 더 나은 문제 해결의 도구로써 잘 활용할 수 있을거에요. 이번 과제가 그런 계기가 되었기를 바랍니다.\n\nQ) 멀티에이전트 시스템을 설계할 때, 에이전트 간 워크플로우를 정의한 협업 문서를 먼저 작성하고 그 내용을 기반으로 각 에이전트를 구성한 방식이 적절했는지 피드백 받고 싶습니다. 이 접근의 의도는 각 에이전트가 자신의 역할과 목표를 명확히 이해해야 협업 과정에서 일관성과 품질을 유지할 수 있다고 판단했기 때문입니다. 이러한 ‘역할 기반 워크플로우 설계’가 실제로 효율적인 구조인지, 더 나은 방법이 있을지 조언을 받고 싶습니다.\n=> 네 잘했습니다. 에이전트에 역할을 부여하고 실제 사람이 협업하듯이 흉내내는 방식은 새롭게 검증해보고 있는 분야입니다. 단순한 LLM에서 추론모델, RAG 등으로 사람을 흉내내는 생각의 도구가 주어지듯이 역할 기반의 협업이 더 나아지더라 하는 식으로 발전하고 있는 중입니다. 이게 검증된 보편적인 방법이 될지는 아직 확정적이진 않아도 대부분 인정하는 분위기인듯해요. 결국 사람이 일을 잘하는 법에서 많이 차용을 하고 있네요. 역할이라기 보다는 실제 업무의 파이프라인을 고려해서 INPUT -> OUTPUT의 파이프라인을 고민해보면 더 좋은 워크플로우를 만들어 볼 수 있으리라 생각합니다.\n\nQ) AI에게 지시를 내리는 단위를 과제의 진행 단계(1~5단계 구조)에 맞춰 각 단계별(1, 2, 3...) 단위로 작업을 분리해 전달하는 방식으로 진행했는데, 이 단위 구성이 TDD 워크플로우나 멀티에이전트 운영 관점에서 적절한 설계인지 궁금합니다.\n=> 네 잘했습니다. 단위 구성의 적절함은 실제 결과물의 퀄리티를 바탕으로 최적화 조율은 얼마든지 해보면서 판단하는 것이니 이번 과제는 방법론 자체를 익혀보는데 있습니다. 다행히 테스트라고 하는 방식은 아주 오래전부터 꽤나 정형화된 패턴이라 잘 맞아떨어진 것이죠. 단계를 더 세분화 해본다거나 혹은 그정도로 하지 않아도 괜찮은지 등을 적절히 테스트 해보면서 찾아가는 방법도 고려해보길 바래요 \n\nQ) 각 에이전트들이 상태를 공유하는 방식을 전체 오케스트레이션이 관리하는 컨텍스트 문서로 일원화했는데, 이 접근이 멀티에이전트 구조에서의 상태 관리 전략으로 적절한지 피드백을 받고 싶습니다.\n=> 이게 최선이고 좋으냐? 라고 하기에는 한계가 있지만 적절하냐? 라는 측면에서는 적절한 수준이라 생각합니다. 저희가 일반적으로 다루는 LLM은 언어와 문서를 기반으로 정의가 되는 만큼 잘 정의된 프롬프트 문서가 퀄리티를 좌우하니까요. API를 바탕으로 다양한 옵션등을 수정한다거나 여러가지 Agent들을 더 관리하는 방법도 연구되고 있지만 아무래도 범용 LLM모델에 비해서는 접근성이 떨어지니까요. 적절하냐라는 질문은 언제나 대답하기가 참 힘든것 같아요. 그 적절함을 선택하고 결정할 수 있는 게 곧 연차가 높아지는 개발자의 역량인만큼 스스로 여러가지로 판단해볼 수 있기를 바래요.\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/14"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "고생하셨습니다 정원님!\n정확한 이유는 모르지만..지난 주 과제를 이어서 하면서 반복일정으로 주석처리 되어있던 UI와 기능이 모조리 날아갔던 것 같네요.\n앱을 실행해보면 반복일정 기능 구현이 화면에서 전혀 구현이 안되어 있는 것 같아요. 너무 아쉽네요 ㅠㅠ\nAI를 활용하신 부분은 굉장히 잘 해주셨는데, 가장 기본이 되는 기능구현이 누락되었네요.\n어떻게 보면 AI가 테스트도 잘 작성해줬고 리팩토링도 잘 해줬지만.. 기능 구현확인은 현실이라는 교훈을 줬던것 같네요 ㅜㅜ 그래서 AI에게 첨부터 너무 많은 일을 시켜서는 안되는거 같아요.\n과제의 목적이나 의도는 내일 조금 더 설명드리겠지만, 주는 Agent였지 TDD가 아니였어요 ㅎㅎ TDD의 개념을 익숙하게 하는것도 조금은 있었지만 AI에 집중하는게 목적이였습니다.\n\n질문 드린 부분 차근차근 답변 드려볼게요 \n\n> Q. 에이전트가 여전히 제가 정한 규칙을 어기는 경우가 많습니다.\n\n일단, 80줄 81줄 같은 카운팅은 잘 못하더라구요 ㅎㅎ\n해당 부분은 AI가 잘 못하는 일로 생각해주시면 좋을것 같아요.\n말씀해주신 그런 규칙들은 한 번 작업이 완료되면 수정한 코드, 작성한 코드에 대해 체크리스트를 검증하는 단계를 만들고 다음단계를 진행해보면 좋을것 같아요. \n\n> Q. 사실 저는 이번 주차를 바이브 코딩을 해보자는 생각을 갖고 시작했습니다.\n\n위에서 언급한것처럼 제 의도대로 정원님은 최선을 다 해주신것 같아요 ㅎㅎ 감사합니다. 저도 이걸 'AI는 다 잘하니까 우리 모두 잘되는걸 하는 방법을 찾아봐요'는 목적이 아니였어요. AI에 대한 의심이 있는 사람들은 이정도로 해준다는것에 놀랐을거고, AI에 대해 과신하고 있던 사람들은 생각보다 깊게 해보니 못하는게 너무 많다는거에 놀랐을거거든요. 저는 이런 과정들을 지금 저희가 너무 관심없게 바깥에서 지켜보기보다는 경험을 하는게 중요하다고 생각했거든요. 그런 관점에서 좋은 접근이였다! 라고 생각합니다.\n\n> Q. 지난 주차에도 드린 질문이기는 한데, 다른 코치님의 의견도 궁금하여 복붙해서 여쭤보겠습니다..!\n\n좋은 관점이고 접근이라고 생각하는데요! 저도 계속 공부를 하고 좋은 설계는 뭔지, 관점이 뭔지 공부하고 있는데요. 지금까지 제가 가진 생각으로는 선배들이 말하던 단일 책임 원칙, 응집도, 결합도, 의존의 방향을 정의하고 함께 두는 코드들의 단위는 어떻고 하는 이야기들이 다 어느 맥락에서 나온 이야기인지 이해하고 필요한 규칙을 우선순위에 맞춰 적절한 강조로 선택하는것이 중요하다고 생각해요. 이런 관점에서 정원님도 저런생각을 하고 있는 것이라고 생각하는데요. 저런것을 집중하고 공부하는것은 좋지만, 코드는 혼자 작성하는 경우보다는 함께 작성하는 경우가 많기에 제가 좋다고 생각하는 코드를 모두에게 강요할 수는 없다고 생각해요ㅎㅎ 그래서 함께 일하는 사람들이 무슨 생각을 갖고 이런 부분에 대해 이야기할수 있는 동료들이 중요하다고 생각하구요.\n\n> 브랜치 전략\n\n너무 모든 과정을 보여주려고 하지 않으셔도 괜찮습니다 ㅎㅎ\n회사에서 업무를 하실때 한 커밋단위를 정하시는것처럼 단위를 잡으시는게 저도 그렇고 다른 코치님들도 정원님의 과제를 이해하는데 도움이 되실거에요.\n\n질문 남겨주신다고 했는데 따로 없는것 같아서 ㅠㅠ 질문주시면 답변드릴게요 ㅎㅎ\n\n과제 잘 진행해주셨는데 너무 아쉽네요. 고생하셨습니다~\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "안녕하세요 연욱님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 과제를 다 마무리하기에는 시간이 부족했나보군요 ㅠㅠ 고생하셨습니다!\n\n---\n\n> bmm-activity-log.md 파일에서 각 에이전트의 작업 내역은 기록되고 있지만 에이전트가 체크리스트 항목을 실제로 수행했는지 여부를 확인할 수 없었습니다. 각 항목의 수행 여부가 명확하게 드러나도록 로그 구조나 기록 포맷을 개선하려면 어떻게 설계하는 것이 좋을까요?\n\n흠... 하나의 파일에 기록하기보단 작업 단위로 나눠서 구체적으로 어떤 명령에 대해 어떤 일을 했는지 체크리스트로 표현하도록 만든다거나\n날짜별로 분할해서 표현하는 등 분할 하고 구체화하는 과정이 필요할 것 같아요!\n지금은 너무 간략하게 표현되어있는 것 같네요!?\n\n> AI Agent끼리 디버깅 작업을 시킬 때 엉뚱한 수정이 일어나지 않도록 성공 / 실패 판정 기준이나 종료 조건을 어떻게 설정해야 하나요?\n\n어떻게라기보단.. 개인적인 경험으로는 의도하지 않은 동작 패턴을 계속 수집한다음에 문서에 지침을 계속 쌓아나가야 할 것 같아요.\n다만 \"의도하지 않은 동작\"에 대한 기준이 사람마다 다를 수 있기 때문에 이건 연욱님이 어떤 기준을 가지고 있는지가 중요하답니다 ㅎㅎ\n\n실패 판정 기준이나 종료 조건도 사실 연욱님의 기준이 필요한거라서.. 무어라 정답을 이야기 하기가 어렵네요.\n제일 정확한게 결국 테스트인데, 테스트가 통과하면 끝, 통과하지 못하면 재시도 등으로 구분할 수 있겠죠?\n\n그렇다면 테스트를 먼저 작성하도록 해야하고, 테스트 작성에 대한 나만의 기준이 필요해요.\n\n이렇게 이야기하다보면 결국 AI를 잘 사용하기 위해선 \"나의 능력치\"가 중요해진답니다. 내가 얼마나 깊이있게 알고 있는지에 따라 AI가 할 수 있는 일도 많아지고 정확도도 높아져요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "권지현",
    "feedback": "수고 많았어요 지현! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 수고 많았어요.\n\n\"똑똑하지만 멍청한 천재와 노는 느낌\"이라는 표현이 AI를 사용하면서 느낀 양면성을 잘 표현한 것 같네요. BMAD를 참고해서 Agent를 구성하고 업무 자동화를 시도한 점, 그리고 \"범위를 명확히 제공하지 않으면 1000줄 넘는 프롬프트가 나왔다\"는 경험에서 현재 AI의 활용의 어려움과 핵심을 잘 경험한 것 같아요.\n\n이번 과제는 AI에게 무작정 맡기기만 하면 어떤 결과를 초래하는지를 느껴보기 위함도 있었습니다. 올바른 방향성과 구체적인 지시가 부족하면 원하지 않은 코드를 마음대로 만들어 내고 책임을 지지 않는다는 점에서 AI를 잘 다룬다는 것이 무엇인지에 대해 몸으로 느껴보는 시간이 되었으리라 생각합니다.\n\n심화과제의 경우 AI를 통해 완전히 내가 원하는 만큼 완성을 하는 수준까지는 못 미치다보니 깊이 있는 인사이트에 도달하지는 못한 느낌이지만 계속적으로 항해를 하는 과정에서 AI를 다뤄보게 될 것이고 깊이 있는 고민으로 이어지게 되기를 바랍니다.\n\n다음은 질문 주신 부분 답변입니다.\n\nQ1. 디버깅하기 너무 어려웠어요. AI로 하다보니 모든 코드를 다 훑어볼 순 없고, 근데 원하는 대로 구현이 안될 때 어디서부터 손봐야할 지 난감하더라구요. 디버깅 잘하는 방법 있을까요 ㅜㅜ\n\n=> 맞아요. 이게 AI 개발의 가장 큰 함정입니다. 내가 직접 짠 코드는 어디가 문제인지 알지만, AI가 짠 코드는 어디서부터 봐야 할지 막막하죠. 그래서 AI에게 일을 시키기 전에 내가 어떻게 만들어야겠다에 대한 청사진과 구체적인 코드가 분명하게 있어야 합니다. 그래야 그걸 타이핑하거나 에러를 맞추는 편리함을 얻을 수 있지 AI에게 작성해달라고 하면 아직 그정도는 하지 못한다는 것을 알아야 해요. \n\n그래서 익숙하기 전까지는 AI에게 물어가되 직접 내가 코딩을 하면서 우선 코딩 자체에 익숙함을 먼저 가지고 확실해졌을때 AI에게 시키는 식으로 연마하고 AI에게 한번에 너무 많은 것을 요구하지 않도록 피상적으로 요구하지 않고 매우 구체적으로 그리고 작은 태스크 단위로 요청하는 요령을 익히는게 필요합니다!\n\nQ2) 한글로 파일을 작성하면 인코딩 오류가 나는 경우가 많아서, 바로 잡으려고 온갖 명령어를 넣어봤는데 안되더라구요, 이런 경험 있으신가요 ? 이 부분 때문에 cursor-agent 쓰기가 번거로워서 혹시 해결 방법을 여쭤보고싶습니다.\n\n=> 맞아요. 파일을 생성할때 혹은 Agent가 생성하라고 할때 반드시 \"파일 작성 시 UTF-8 인코딩 사용\"을 명령에 포함시켜 보세요. \n\nQ3)  ‘리펙토링’이라는 원하는 행동에 크게 영향을 주는 프롬프트가 아닌 것 같습니다. 리펙토링 에이전트는 특히 원하는 방식으로 동작하게 하기가 쉽지 않네요.\n\n=> 사실 \"리팩토링 해줘\" 라는 이 6글자만 가지고 AI가 어떻게 하면 좋을지를 항상 일관되게 만들어 내기를 바랄수는 없습니다. 아주 정교하게 리팩토링 자체의 컨벤션과 패턴을 만들어내야 하고 그렇게 할 수 있도록 해야하죠. 그렇기에 우선 내가 리팩토링을 어떻게 해야 하는지 어떤 설계와 패턴을 유지하려고 해야 하는지를 익혀야 합니다. AI를 다루는 가장 좋은 방법은 내가 충분히 선명하게 알고 있어서 명확하게 지시하거나, 아니면 아주 조금씩 진행하면서 구체적인 패턴을 만들어내서 일관성을 유지한다에요. 모호하지 않게 구체적으로 쓰라라는 피드백도 모호하고 막연하겠지만 어쩌겠나요? ㅠㅠ 리팩토링에 대해서는 또 함께 항해 챕터에서 다뤄보게 될테니 계속해서 선명하게 좋은 코드의 패턴에 대해서 익혀가기로 해요.\n\n\"AI를 사용하면 개발자에게 기술적 기반으로 구체적으로 설명하는 능력과 AI의 결과를 판단하는 능력이 중요하다\"는 것을 이번 과제를 통해 잘 알았으리라 생각해요. AI에게 너무 많은 걸 맡겨버리게 되면, 그 결과물을 검증하는 부메랑을 꼭 맞게 되니 답답해도 최대한 내가 수용할 수 있을만큼 조금씩 그리고 구체적으로 늘려가는 법을 앞으로 함께 계속 해봐요\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/25"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "안녕하세요 단헌님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ\n심화과제는 리포트를 작성해야 되는데, 작성해주신 내용이 없는 것 같아서 불합격으로 남겨놓겠습니다..!\n\n학습한 내용을 잘 소화하려면 심화과제에 언급한 것 처럼 \"정리\"를 해보면 좋아요! 앞으로도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김대현",
    "feedback": "안녕하세요 대현님!\n\n> 현재처럼 입출력 규칙을 엄격히 고정한 함수형 에이전트 방식이 구조적으로 어떤 제약을 만드는지 알고 싶습니다.\n\n어떤 제약이라고 한다면... 솔직하게 말해서 저도 잘 모르겠어요 ㅎㅎ\n보통 에이전트를 직접 만들어서 사용하기보단 간단하게 프롬프트를 만들어서 사용하는 편이라서요.\n\n그리고 이 또한 어떤 AI를 사용하냐에 따르 무척 다른데요,\nopenai의 codex 같은 경우 제약이 많을 경우 오히려 원하는 결과를 만들어내기가 어렵고\n반대로 claude의 경우, 명확한 지침이 있을 때 원하는 결과를 더 빠르게 도출할 수 있다고 합니다.\n\n그래서 실제로 하나하나 다 실험해보지 않으면 뚜렷한 결과를 알기가 어려우리라 생각해요.\n특히 모델이 달라지면 결과값도 대체로 많이 달라져서요.\n\n결론은... \"잘 모르겠다!\"로 추론되네요 ㅎㅎ\n\n\n> 이 접근을 유지하면서도 프로젝트 간 재사용성을 높일 수 있는 방법이 있을까요?\n\n아마 도메인과 프로젝트의 아키텍쳐가 다르다면 사실 재활용할 수 있는 부분이 많진 않으리라 생각해요.\n처음부터 똑같은 에이전트로 계속 프로젝트를 만들어가는게 아니라면!?\n\n\n> BMAD 방식으로 에이전트를 설계하면, 실제로 여러 프로젝트에 범용적으로 활용 가능한 A2A 시스템을 만들 수 있을까요?\n\n\"범용적\"이라고 이야기할 수 있는 범위가 어느정도냐에 따라 다르지 않을까요!?\n그래서 기준에 따라 만들 수도 있다고 이야기할 수도 있고, 아니라고도 할 수 있다고 생각해요.\n\n그니까 반대로, \"어떤 부분을 범용적으로 활용하면 좋을까?\"에 대한 기준을 정해야 한다고 생각합니다!\n그 외에는 프로젝트에 종속적으로 설계할 수 밖에 없지 않을까요!? 그리고 그렇게 해야 성능도 좋아지리라 생각해요!\n\n\n> 만약 가능하다면, 초기 설계 시 어떤 관점(페르소나 설계, 역할 정의, 입력·출력 구조 등)에 우선순위를 두는 게 좋을까요?\n\n프로젝트 도메인과 성격에 따라 다르다고 생각해요.\n가령, 운영 프로젝트의 경우 QA가 훨씬 중요할 수 있고,\n신규 프로젝트의 경우 다양한 시나리오가 중요할 수 있고,\n플랫폼 성격의 프로젝트의 경우 코어가 중요하기 때문에 설계가 중요할 수 있겠죠?\n\n그래서 우선순위는 내가 어떤 프로젝트를 하냐에 따라 다를 것 같아요.\n\n\n> 앞으로 에이전트를 만들 때, 함수형 접근과 BMAD 접근 중 어떤 방식으로 확장하는 게 장기적으로 더 효율적일지 조언 부탁드립니다.\n\n앞선 이야기와 동일한데요, 어떤 프로젝트, 어떤 성격의 서비스를 수행하냐에 따라 다를 수 있다고 생각합니다.\n초기부터 만들어가야 하는 프로젝트는 BMAD가 좋을 수 있고, 중간에 투입되는 프로젝트의 경우 함수형 접근이 좋을 수 있으니까요!\n\n---\n\n내용을 정리해보자면, 내가 처한 환경에 적합한 AI를 활용하고 에이전트를 구축하는게 중요해요. 다양한 전략이 필요한거죠!\n정답이 있다기보단, 최선이 있다고 생각해요.",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/63"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "앗 도현님 ㅠㅠ\n반복일정 추가는 잘되지만, 모달에 따른 수정 삭제 동작이 명세와 전혀 다르게 동작하는거 같네요 ㅠㅠ 너무 아숩군요 ㅠㅠ\nAI를 활용하신 부분은 굉장히 잘 해주셨는데, 가장 기본이 되는 기능구현이 누락되었네요. 어떻게 보면 AI가 테스트도 잘 작성해줬고 리팩토링도 잘 해줬지만.. AI가 한 일의 마지막은 확인이라는 현실을 보여 줬던것 같네요.\n\n전반적으로 에이전트를 구성해주신 부분을 보면 잘 작성해주셨어요!\n오케스트레이터에서는 사실 각 에이전트의 작업이 있으니까 꼭 중복해서 작성하지 않아도 각 단계에 넘어가면 잘 진행했을거에요 ㅎㅎ\n지침이 중복되면 AI가 혼란스러워져서 작업을 잘 못하는 경향이 생기더라구요.\n잘 작성된 프롬프트를 보면 꼭 구체적이고 길게 작성하는게 다는 아닌것 같더라구요.\n\n> TDD의 RED 단계에서 \"import 에러\"도 유효한 실패로 볼 수 있을까요? 아니면 \"assertion 실패\"가 진정한 RED 단계의 실패일까요?\n\nTDD에서도 컴파일에 관련된 이야기들이 언급되곤 하는데요. 어설션이 진정한 레드 단계라기보다는 과정으로 가는 단계로 보면 좋을것 같아요. 동일하게 RED단계이지만 어설션으로 도입하기 위해 서둘러야 한다 관점으로 보면 좋을것 같습니다. \n\n> \"빈 함수 스텁 먼저 생성\" 접근 방식이 TDD 정통 방식에 부합하는지 궁금합니다.\n\n실제 TDD 단계를 깊게 제가 이야기를 드리지 않았는데도 잘 확인해서 작성해주셨던것 같은데요. 실제로 TDD를 이야기 할 때 켄트벡은 스텁 -> 페이크 -> 실제 구현 사이클을 매우 짧게짧게 가져가는것으로 이야기해요. 제가 이번 발제에서는 TDD에 집중하기 보다는 Agent를 이야기 하다보니 중심이 되는 이야기들을 가볍게 다뤘었는데, 정통방식에 부합한다 라고 이해해주시면 됩니다.\n\n> 실무에서는 어떤 방식을 더 선호하시나요?\n\n위에서 언급한대로 진행하는 경우도 있고 페이크 없이 바로 구현을 하는 경우도 있는데, 상황에 따라 다르게 적용한다라고 가이드하고 있거든요. 좀 더 깊게 다룬다면 TDD By Example을 읽어봐도 좋을것 같아요!\n\n고생하셨고 잘 해주셨는데 너무 아쉽네요.. 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "수고 많았어요 민석! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 잘했습니다.\n\nAI 활용 개선 노력도 인상적이었습니다. \"반복 기능 추가해줘\" 대신 \"일정 생성 시 '매주 반복'을 선택하면 다음 주에도 동일한 일정이 표시되도록 테스트 설계해줘\"처럼 프롬프트를 구체화한 경험이 좋았고, TestDesignerAgent가 설계만 해야 하는데 코드를 작성하려는 경향을 발견하고 예시 MD 파일로 개선한 것도 훌륭했습니다. \"한 테스트 시나리오(한 it 블록) 수준\"으로 작업 범위를 좁힌 시도도 정확한 접근이었어요.\n\n심화 과제 리포트도 잘 작성해주셨네요. \"처음에는 무슨 말인지 잘 이해하지 못했다\"에서 시작해서, ChatGPT에게 하나씩 물어보며 개념을 정리하고, 최종적으로 \"AI를 이렇게도 활용할 수 있구나\"까지 도달한 학습 과정이 정말 좋았습니다. 특히 Cursor는 코드 기반의 툴로 ChatGPT는 테스트 설계등으로 각 도구에 맞게 잘 활용해 주었네요.\n\n질문 주신 부분에 답변드리면, 명세서가 제공되어도 기능 설계 에이전트는 만드는 게 더 좋습니다. 주어진 명세서를 \"AI가 이해할 수 있는 형태\"로 재구조화하고 테스트 가능한 단위로 분해하는 작업을 하는게 좋기 때문이고 에이전트의 역할은 컨텍스트가 섞이지 않도록 단일 책임 형태인게 더 나으니까요.\n\nrepeat.spec.tsx 코드량이 어마 어마 하더라구요. 아마 직접 작업을 하려고 했으면 엄두가 안 났을 양인데, 그렇다고 그냥 만들어달라고 한다고 제대로 만들어지는건 아니죠. 개발자가 기술과 지식을 이용해 AI를 활용한다는 것이 어떤 것인지 느껴보는 시간이 되었기를 바랍니다.\n\n수고 많았어요. 다음 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/18"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "안녕하세요 민지님!\n2주차 과제를 진행하기에는 시간이 많이 부족했나보군요 ㅠㅠ\n다음주는 잘 해낼 수 있기를 기대하겠습니다! 화이팅입니다!!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/51"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "안녕하세요 성민님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 끝까지 완수하기에는 시작이 부족했던 것 같군요 ㅠㅠ\n\n> 에이전트에게 컨텍스트로 제공할 지침들도 AI가 작성해준 항목들이 많은데, 작성한 항목들은 처음 들어보는 개념이지만 그냥 제 눈에는 좋아 보여서 다 넣게 되었습니다. 불필요하거나 의도에 방해가 되는 항목이 있을까요?\n\n흠.. 하나하나 다 판단하기에는 어렵다고 생각해요.\n저는 웬만하면 지침 자체는 AI가 작성하도록 두는 편이라서요.\n대신 https://docs.claude.com/ko/docs/build-with-claude/prompt-engineering/prompt-improver 혹은 https://platform.openai.com/chat/edit?optimize=true 이런 도구를 이용해서 프롬프트를 최적화해볼 수 있답니다!\n\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/8"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "소리님 수고하셨습니다!\n\nQ. 최대한 tdd 순서대로 커밋을 하려고 했지만 앞선 테스트가 잘못되었을 경우가 있습니다. 구현 단계에서는 절대 테스트를 수정하지 말라는 지시가 있지만, 그래도 테스트가 잘못되었을 경우가 있는데 이런 때는 테스트 코드로 돌아가야 할까요?\n\nA. 구현단계에서 테스트를 수정하지 말라는건 테스트가 옳게 만들어 졌다는 전제인것 같아요. 구현해보다보니 테스트가 잘못되어서 테스트를 정상적으로 할 수 있도록 테스트 코드를 수정하는건 잘못된 것이 없다고 생각해요. 그리고 일단 TDD 사이클을 활용해볼 필요는 있지만 실무에서는 사이클 자체에 연연하기 보다는 코드 자체에 집중하면 좋을 것 같아요.\nTDD사이클은 대상 모듈의 입력과 아웃풋이 데이터일때 유용해요 저희가 다루는 UI는 입력과 아웃풋이 데이터가 아니기 때문에 테스트케이스의 전제가 잘못된 경우가 종종있습니다.\n\nQ. 오케스트레이터가 에이전트를 안 부르고 자기 혼자 일을 열심히 할 때가 있어서 제가 지정을 해 줘야 할때가 많았는데 개선 방법이 있을까요?\n\nA. 명확하게 오케스트레이터의 역할을 제안하는 방법 (DO NOT), 권한을 제안하는 방법, 위입 규칙을 정량적 정성적으로 가이드 하는 방법등이 있을 것 같아요. 요건 솔루션 코드를 보시면서 비교해보시면 좋을 것 같습니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/36"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "수고 많았어요 우정! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 잘했습니다.\n\n\"AI를 사용하고는 있지만 제대로 활용은 못하고 있다고 생각했는데, 멀티 에이전트를 만들어서 일을 시킬 수 있다는 개념 자체가 신기했다\"는 회고가 과제 취지를 잘 경험한 것 같아 좋네요. BMAD를 참고해서 역할이 분리된 에이전트들을 설계하고, TDD 사이클을 자동화해본 경험이 좋았고, 특히 \"칭찬 피드백\"이나 \"명시적인 단계 지시\"를 주면 응답 품질이 향상된다는 발견을 몸으로 느껴본것 같아서 좋네요. 잘했습니다!\n\n다음은 질문 주신 부분 답변입니다.\n\nQ) 만약 에이전트가 짜준 코드에 마음에 안드는 부분이 있으면 제가 직접 고치는 게 좋을까요 아니면 프롬프트로 디렉만 해주고 직접 수정하게 하는 게 나을까요? 만약에 목표가 완전한 자동화라면 디렉을 하면서 계속 에이전트 룰을 업데이트를 하는 방식으로 가야할까요? (예를 들어, ‘테스트 케이스가 중복 되는 거 같아’, ‘루프를 최소한으로 만들어줘’ 라는 식으로 피드백을 주었습니다.)\n=> 아직까지는 완전한 자동화라는게 LLM의 구조상 불가능합니다. 그걸 해소하기 위해 Agent에 대해 계속 연구하고 있고 같은 입력에 대해 최대한 일관성을 확보하고자 하는게 지금의 노력이지만 LLM이 같은 입력에 대해 같은 결과를 내어주는 구조가 아니니까요. 어떤 시점이 오면 사실 내가 원하는 바대로 말로 설명하는게 더 어려운 순간이 있어요. 그럴때는 그냥 내가 어떻게 고치면 될지 바로 보인다면 고치면 좋겠죠.\n\n=> 완전환 자동화 혹은 퀄리티를 높이기 위해서 혹은 내가 프롬프트를 구체적으로 서술하기 위한 연습이라면 얼마든지 AI에게 최대한 맡겨보도록 하는것도 좋은 AI의 활용이라고 생각합니다. 사실 내 목적이 어디에 있는지가 분명하다면 내가 수정을 하거나 프롬프트 수정을 하거나 하는건 선택이지 비교우위를 논할 부분은 아니라고 생각해요.\n\n\nQ) 코치님은 에이전트들로 얼마나 자동화를 의지하시는지 궁금합니다. 테스트 코드를 통과하고, 룰과 컨벤션에 따라 코드를 짜는 게 안정적이라고 해도 항상 제가 원하는 방식으로 되지는 않을 것 같아서요\n\n=> 네, 그래서 저도 자동화를 최대한 해보려고 했는데 제가 하고 있는 실무에서는 사실 반 포기하고 다음 버전을 기다리고 있는 중입니다. 최근에는 Agent를 통한 코딩도 최대한 줄이고 스스로 코딩을 하려고 하고 있어요. 다만 이건 제 업무가 자동화가 아니니까 할 수 있는 것이고 생산성을 높이고자 노력하는 행위와 고민은 개발자로써 아주 중요하다고 생각합니다.\n\n\nQ) TDD를 자동화 할 때는 최선의 방법으로 코드를 짜지 못할 것을 염두에 두고 자동화의 장점을 필요로 해서 AI를 활용하는 걸까요?\n\n=> 제가 모르는 분야가 있을 때 막막함을 덜어주는 용도로는 AI를 잘 쓰고 있습니다. 내가 어떻게 해야 하는지 분명한데 귀찮을때도 요긴하죠. 테스트 코드와 같은 부분들을 내가 작성하는 것보다 간혹 잘 작성하는 편이니 자주 시키곤 합니다. 다만 한번에 될거라는 기대나 자동화가 될거라는 기대는 하지 않습니다. 내가 하는 일의 귀찮음을 덜거라는 생각으로 계속 시켜보면서 감을 잡고나면 다시 제가 작성하는 편이긴 합니다. 그래야 내 손에서 관리가 되니까요. \n\n=> AI에게 최선을 요구하는 건 지금의 구조에서는 말이 안된다 생각합니다. 첫 대답과 첫 고민에 들어가는 에너지를 덜어주는 도구이지 마지막과 자동화 그리고 최선을 위한 도구는 아니라고 생각해요. 적어도 지금의 도구는 그렇습니다. 나중에 더 좋은게 나오면 그때 해보려구요. ㅎ\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/17"
    }
  },
  {
    "passed": true,
    "name": "김준모",
    "feedback": "안녕하세요 준모님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n> 현재 프로젝트에 AI 에이전트가 BMAD에 따라 'analyst', 'architect', 'dev', 'orchestrator', 'pm', 'qa', 'scrum-master' 이렇게 있는데 추가로 만들면 좋은 AI 에이전트가 뭐가 있는지 궁금합니다.\n\n음.. 굳이 더 필요할까 싶긴해요.\n코드를 작성하기 위한 에이전트는 충분하고, 코드 작성 외의 무언가를 찾아내자면\n\n- UX / DX Reviewer: Figma, 화면 카피, 인터랙션 플로우, API 사용 플로우를 보고 “여기서 사용자가 길을 잃는다 / 온보딩 드랍 포인트다 / 네이밍 불일치 있다”를 잡아줌. 컴포넌트/훅/서비스의 DX를 평가해 “이 API는 옵션이 7개라 학습비용 높음 → 분리 권장” 같은 피드백. 마이크로카피 톤, 에러 메시지 가독성도 리뷰\n- 테크 라이터: 신규 팀원이 이해 가능한 온보딩 문서, README, API 문서 자동 유지보수. “지금 이 기능 고장났는데 어디부터 보면 돼?”에 대한 1st responder용 가이드 생성\n- Cost/SLO Manager: “성능/안정성/SLO. 비용/리소스 사용량”을 관리함. 특히 AI/infra 비용은 하루만 잘못 돌려도 불필요한 돈을 사용하게 됨.\n- Compliance / Risk Guard: 법 / 개인정보 / 보안 / 라이선스 위반은 개발 끝나고 들이대면 이미 늦음. 초반 설계 단계에서 자동으로 막아줘야 함.\n\n그런데 잘 생각해보면 \"굳이 항상 필요할까?\" 라고 생각할 수 있어요. 프롬프트만 따로 만들어놓고 사용해도 충분하답니다!\n\n\n> 현재 AI 에이전트가 만들어준 산출물들이(mockdowns 폴더) 현업에서 사용할 만한 수준인지, 현업에서는 산출물을 어떤 템플릿으로 쓰고 있는지 궁금 합니다.\n\n어떻게 정의하냐에 따라 다르지 않을까요!? \"도입할 의도\"가 있다면 충분히 사용할만하다고 생각해요. 대신 계속 발전을 시켜야겠죠 ㅎㅎ\n\n저희 팀은 cursor rules 정도만 정의하는 편이랍니다!\n\n\n> 에이전트 간의 호출 구조에는 모든 에이전트가 서로를 자유롭게 호출하는 평등 구조와, Orchestrator 에이전트만 다른 에이전트를 호출할 수 있는 구조가 있습니다. 두 구조 중 어느 쪽이 더 효율적인지 궁금하며, 또한 현업에서는 일반적으로 어떤 구조를 선택하여 사용하는지도 알고 싶습니다.\n\n흠.. 뭐가 정답이라기보단 어떤 목적을 달성하고 싶냐에 따라 다르다고 생각해요. 현업에서는 비용때문에 자유 호출보단 절제된 호출을 하는 편입니다. 오케스트레이션을 하는거죠!\n\n> 에이전트의 수가 많아질수록 효율이 얼마나 향상되는지, 혹은 일정 수 이상이 되면 오히려 효율이 떨어지는지 궁금합니다. 또한 많은 에이전트를 사용하는 상황에서 에이전트 수를 줄이면서 통합할 때의 전략도 알고 싶습니다. 이러한 경우, 에이전트를 어떻게 합치는 것이 가장 효율적인지에 대한 방법이 궁금합니다.\n\n프로젝트 특성에 따라 분리해야겠죠!? 내가 하는 일이 \"운영\"과 관련되어 있다면 QA를 적극적으로 활용하고, 개발과 관련 있다면 전체적으로 골고루 사용해야해요.\n\n그래서 효율적인건 \"나 자신\"이 프로젝트에 대한 지식을 많이 가지고 있고, 이를 토대로 적절하게 호출해서 사용하는거죠 ㅎㅎ\n아직은 사람이 어느정도 개입해야 제일 효율적이라고 생각하고, 그게 아니면 토큰을 극단적으로 많이 사용해서 퀄리티를 높이는 방법이 최선인 상황이라고 생각해요.\n\n> 제가 작성한 .cursorules 의 규칙에서 추가할 만한 규칙이 있는지 궁금합니다.\n\n이야기 하고자 하면 끝이 없죠 ㅋㅋ\n다만 .cursorfules 는 구버전의 규칙이라서, .cursor/rules 폴더를 만들고, 여기에 여러가지 규칙을 만들어서 필요할 때 가져다가 사용하는 방식을 선호하는 편이랍니다.\n\n필요한 규칙은 프로젝트마다 다르다고 생각해요.",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "안녕하세요 채영님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n테스트 명세(spec-agent.ts)와 실제 코드(code-agent.ts) 간 싱크를 유지할 때 어떤 방식으로 하는지 조언해주실 수 있나요?\n\nQ)\n- RefactorAgent가 테스트 품질 기준(test-metrics.md)을 더 잘 반영하게 하려면 어떤 구조와 명세를 담으면 좋을까요?\n\nA)\n음.. 굳이 더 잘 반영해야할까요!? 라는 질문을 먼저 던지고 싶어요.\n여기서 불필요하다고 생각하는 것들을 제거하고, 꼭 달성해야 하는 것들 위주로 우선순위를 높인 다음에 그것들을 어떻게 하면 더 잘 달성시킬 수 있을지 고민해보면 어떨까요?\n\nAI로 \"완벽함\"을 추구하기보단 \"최선의 목적\"을 달성하는데 초점을 두면 더 잘 활용할 수 있답니다 ㅎㅎ\n\n\nQ)\n- Hard를 진행하려다가 GREEN 단계에서 막혔는데 실무에서도 GREEN이 제일 어려운 단계일까요? 그렇다면 그 이유는 무엇이고 어떻게 설계를 하면 더 쉽게 진행할 수 있을까요?\n\nA)\n테스트에 대한 경험이 아직은 부족하기 때문이라고 생각해요. \"좋은 형태\"에 대한 감이 없기 때문에, 어떤 모습으로 만들어내야 할지에 대한 인식이 아직은 부족한거죠.\n\n다만, 꼭 Green 단계가 필요한가? 라고 하면 그렇진 않다고 생각해요.\n저희 팀에서는 테스트를 먼저 작성하는 편은 아니라서요!\n\n1. 일단 현재 내가 작성한 코드에 대해 어떻게 테스트를 적용할지 생각해보고\n2. 테스트를 적용한 다음에 리팩토링을 해보고\n3. 리팩토링을 한 코드에 대해 다시 테스트를 작성해보고\n\n1~3에 대한 훈련이 잘 되었다면,\n\n이제 거꾸로 가는거죠 ㅎㅎ\n\n1. 테스트를 먼저 작성하면서 함수를 설계하고\n2. 테스트가 잘 통과하도록 구현을 하고\n\n이렇게 점진적인 숙련을 하는 게 제일 빠른 방법이라고 생각해요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/9"
    }
  },
  {
    "passed": false,
    "name": "김현우",
    "feedback": "현우님 \n11/1 오후 5시 기준으로 과제의 내용이 비어있는데요.\n시간이 조금 부족하셨던 것 같습니다!\n다음에 과제는 꼭 완수하시길 빌겠습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "안녕하세요 은주님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 끝까지 완수하기에는 시간이 많이 부족했던 것 같군요 ㅠㅠ\n\n--\n\n> 1. 1주차에 이어 2주차까지 학습을 따라가지 못한다는 느낌을 많이 받고있는데  이런 경우 이번 주말 간 어떤 방향으로 공부를 해야 학습을 좀 따라잡을 수 있을까요? 현재 상태면 다음 주차에도 영향이 갈 거 같아 문의드립니다!\n\n흠.. 이미 주말이 다 지나버렸군요 ㅠㅠ\n개인적으로, 쉴때는 쉬어야 한다고 생각해요 ㅋㅋ\n3주차의 경우 테스트를 이어서 진행하기 때문에, 2주차 과제를 AI가 아닌 스스로 한 번 해보는 것도 좋은 방법이라고 생각합니다!\n\n> 2. 어느정도로 1,2주차 정보를 이해해야 다음 주차때 무리가 없을까요??\n\n\"테스트\" 라는 개념 자체에 대해서만 잘 숙지해주신다면 큰 어려움은 없으리라 생각해요 ㅎㅎ\n\n\n> ** 코드의 대한 피드백이 아닌 개인 질의를 남겨도 되나 싶네요... ㅠㅠ \n\n그럼요! 과제에 대한 이야기가 제일 좋긴 하지만, 개인적인 질문도 좋답니다 ㅎㅎ\n다만 꼭 과제 PR에만 남겨야 하는건 아니라고 생각해요.\n디스코드를 통해 문의주셔도 좋답니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/64"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "유리님~ 내용있는 MR다시 제출 받아서 다시 채점했어요.\n심화는 리포트를 작성해야 패스인데 리포트는 없어서 불합이고 기본은 합 확인했습니다 :) \n\nQ. 반복 일정 생성 알고리즘의 효율성\nA. 미리 한번만 계산해서 계산된 값을 반복사용하는 것은 그냥 숨쉬듯해야할 것 같고요 :) 예를들어 어떤 로직에 병목이 있을 것이다 판단되거나 실제로 병목이 보이는 경우 구글 데브 툴을 활용에 병목을 찾고 좀 더 빠른 대안을 찾아나갑니다.\n\nQ. MSW 핸들러의 상태 관리\nA. 일반적으로는  server.use() 를 활용해 테스트별로 핸들러를 교체하는 방식이 더 간편하고 유연하며, 테스트의 독립성을 유지하는 데 유리한 것 같습니다~\n그리고 테스트를 병렬적으로 돌리기 위해 인스턴스를 격리할 수 있는 Boundary라는 기능이 있는데요 질문에 부합되는 기능 같아요 :) 한번 확인해보시면 좋을 것 같습니다. https://mswjs.io/docs/api/setup-server/boundary/\n\nQ. Agent 시스템의 실무 적용 가능성\nA. 저는 아직 없지만 이번 발제 코치인 오프 코치님은 이런 방식으로 일종으 솔루션을 개발하신 적이 있습니다~\n\nQ. 타입 안전성 개선 방향\nA. 저는 항상 태그드타입 즉 Discriminated Union를 선호합니다. 제일 깔끔하게 코드가 추론되고 힌팅도 좋은 것 같아요!\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/24#issue-3554698751"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "작업은 진행을 했던 것 같은데 과제의 통과 기준을 달성하지 못했고 회고 입력이 되지 않아서 아쉽지만 불합격을 드려요. 혹시 제가 PR링크를 확인하지 못해서라면 꼭 확인 후 연락 주세요. 수고하셨습니다.",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "안녕하세요 수범님!\n2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n현재 테스트도 실패하고 있고, 반복일정 기능이 제대로 구현이 안 되어있군요 ㅠㅠ 기본과제는 불통으로 남겨놓겠습니다..!\n\n---\n\n\nQ)\nAI 에이전트를 구축할 때, 저처럼 프로그래밍 방식으로 API를 직접 제어하고 전체 워크플로우를 자동화하는 방식과, 일반적인 케이스처럼 마크다운 프롬프트를 활용해 대화형으로 빠르게 결과를 얻는 방식 중, 장기적으로 어떤 방식이 더 견고하고 확장성이 높다고 보시나요?\n\nA)\n재밌는 아이디어라고 생각해요! 다만 확장성 측면에서 보면, \"확장하기 좋은데!?\"라고 말하기 어려운 부분이 있다고 생각합니다. 현재 구현해주신 내용을 MCP(Model Context Protocal)로 만들어서 배포해놓고 사용하면 꼭 코드를 읽어서 수행하지 않아도 충분할테니까요!\n수범님처럼 시도하다가 결국 MCP 같은 도구가 나온게 아닐까요!?\n\nQ)\n제가 선택한 SDK 방식이 '나만의 에이전트 만들기'라는 과제의 본질을 잘못이해한걸까요?\n\nA)\n본질 자체는 \"나만의 에이전트를 어쨌든 만들어보고, 이를 토대로 경험을 쌓는 것\" 이라고 생각해요 ㅎㅎ 그래서 충분히 취지에 부합한 시도라고 생각합니다.\n여기서 어떻게 하면 더 확장성있게 사용할 수 있을까? 에 대한 고민을 계속 해보시면 좋겠어요.\n개발자 뿐만 아니라 \"기획자\"도 잘 사용하게 하려면?\n혹은 기획이나 개발 지식이 없는 \"일반인\"도 잘 사용하게 하려면?\n\n이런 질문들로 이어지면 좋겠어요 ㅎㅎ",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/32"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "수고 많았어요 용태! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 아주 잘했습니다.\n\n방향을 잘못 잡아 심연도  몇 번을 갔다오고 Agent를 돌려깍는 것도 수십번했다는 말에서 진정성이 느껴졌습니다. BMad Method 철학을 자신만의 방식으로 소화해 Multi-Agent 협업 시스템을 구축한 과정을 너무 상세히 적어주어 놀랬습니다.\n\n단순 질답으로써의 AI의 활용이 아니라 Agent의 결합으로 workflow를 만들고 이를 내가 관리하는 방식으로도 AI를 쓸 수 있다라는 인사이트와 이를 제대로 활용하기 위한 경험들을 이 짧은 시간내에 다 경험하고 이렇게 상세한 회고까지 썼다는 점에서 너무 멋집니다.\n\n다음은 문의한 내용에 대한 답변입니다.\n\nQ) 정말 Multi Agent를 활용하는 구조가 단일 Agent로 Persona를 전환해가며 작업하는 것보다 효율적인 방향일까? 상황에 따라 다르겠지만, 전자가 효과적으로 힘을 발휘하는 시기는 제품 개발 관점에서 어떤 시점일까?\n\n=> 아직까지 LLM은 컨텍스트가 많아질 수록 이른바 멍청해지는 현상은 여전히 발생하고 있습니다. 게대가 Agent가 책임이 많아지고 원하는 요구사항에 대한 것들이 달라질 수록 더 심화가 되죠. 그러다 보니 하나의 페르소나만으로는 제대로된 결과를 수행하지 못할 때가 많습니다. 그래서 컨텍스트를 고정하고 각자가 자신의 역할을 중심으로 수행할 수 있도록 하는 Multi Agent를 활용하는 방식을 쓰죠. 이 방식을 쓰기 위해서는 다만 workflow가 분명해야 한다는 점이 필요합니다. 결국 Context의 변화를 최소화 하겠다는 것인데 알아서 하라고 하면 퀄리티가 낮아지겠죠. 그래서 지금의 테스트와 같이 다소 정해진 규격와 틀이 있는 방법론이 있을 수록 Multi Agent 방식이 빛을 바라게 됩니다. 아직은 단일 LLM의 한계에 따른 실험적인 새로운 접근법 중이긴 하지 만 추론모델, RAG 등의 방식이 보편화 된 것처럼 어떻게 될지 지켜보면 좋겠네요.\n\n\nQ) 지금도 LLM의 성능은 하루가 멀다 발전하고 있기에, 현재의 활용구조가 한 분기 후에는 크게 의미 없어질 수도 있다고 생각합니다. 고런 흐름에서 좋은 판단은 뭘까요? 오버엔지니어링에 대한 적절한 감각을 찾는 방법은 뭘까요?\n\n=> 그래서 꾸준히 그리고 직접 해보면서 체감을 하고 있어야 합니다. 만약 지금의 경험이 없다면 이후 새로운 것이 나왔다 했을때 실제로 더 나아졌는지 얼마나 더 나아진건지 아니면 그냥 하이프로 인한 설레발이었을지 내가 비교하지 못한다면 결국 판단을 하지 못할 것입니다. 그러니 조금씩이라도 새로운게 나왔다고 하면 찍먹(?)을 통해서 감각적으로 이 정도 되는구나 하는 것들을 익혀두는 것이죠.\n\n=> 그리고 원래 학습을 할때에는 최대한 오버엔지니어링을 통해서 학습하는거죠. 실전을 하게 될 때에는 결국 비용이라는 측면을 먼저 고려하게 될것이기에 자연스레 과하다 싶은 부분들은 시간적이든 유지비용이든 감당하기 어려운 것들을 걷어내고 있을거에요. 실전 감각을 잃지 않기 위해 변화를 주시하고 오버엔니지어링을 해서 일단 학습한 다음 실전에서 운용을 하면서 현실적인 비용등을 알아낸다 뻔한 답이긴 하지만 이렇게 생각해주세요.\n\n정말 수고 많았습니다! 다음 과제도 화이팅입니다.\n\nBP 선정이유: 회고가 기술적 측면에서 구체성이 매우 뛰어나게 작성이 되어 있어 다른 친구들에게도 충분히 도움이 될 수 있을 내용이라 BP로 선정하였습니다.",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/26"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "윽.. 지영님 ㅠㅠ\n반복일정 추가는 잘되지만, 모달에 따른 수정 동작이 명세와 전혀 다르게 동작하는거 같네요 ㅠㅠ 수정을 하면 새로운 일정이 생기는것 같아요 ㅠㅠㅠㅠㅠ\nAI를 활용하신 부분은 굉장히 잘 해주셨는데, 가장 기본이 되는 기능구현이 누락되었네요. 어떻게 보면 AI가 테스트도 잘 작성해줬고 리팩토링도 잘 해줬지만.. AI가 한 일의 마지막은 확인이라는 현실을 보여 줬던것 같네요.\n\n우선 질문 답변드려보고 피드백으로 넘어갈게요.\n\n> 실무에 있어서 신입/혹은 팀원들에게 AI의 사용을 어디까지 사용가능한 범위라고 생각하시나요?\n\n회사 관점이라면 저희는 개발자로서 사업이 되게 만들어야 하는 역할이 있는거고 더 많은 일을 할수록 성과로 인정받는것이니 AI의 활용을 억제할 필요는 없다고 생각해요. 다만, 이번에 경험해보셨던것 처럼 AI를 잘 쓰기위해서는 여러가지를 알아야 하고 생각보다 FE 기반 지식도 많이 필요하다는걸 느끼셨을 것 같아요. 장기적으로 AI가 똑똑해진다면 저희도 이걸 더 잘 쓰기위해 더 많은 공부가 필요할거고 이 공부는 이전과 약간은 다른 공부가 되지 않을까라고 개인적으로는 생각하고 있습니다. \n\n에이전트를 구성하고 테스트를 진행하는 부분도 잘 진행해주셨고 컨텍스트도 잘 쓰이도록 해주셨어서 더 아쉽네요 ㅠㅠ \n지금의 평가를 진행하는 방법도 인상적이였고 필요한 단계지만,  제가 말씀드렸던 평가는 AI가 뱉는 응답을 내가 의도한대로 잘 했는지를 검증하는 단계를 말씀드린거긴했어요 ㅎㅎ \n결국 좋은 Input이 들어가야 좋은 Output이 나온다는 대전제는 달라지는게 없어서 에이전트를 잇는 단계에서 각 단계가 좋은 결과를 만드는지 잘 검증하는게 필요하거든요.\n과제를 너무너무 잘 해주셨고 그만큼 아쉬운데요 ㅠㅠ\n다음 과제도 잘 진행해주시고 잘 동작하는지 마지막에 꼭 체크해주시면 좋겠어요, 고생하셨습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/44"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "창수님 수고하셨습니다.\n\n말씀하신대로 페르소나를 활용해서 실무에서 좀 더 생산성을 높일 수 있으면 좋을 것 같네요 커서도 비슷하게 제공하니 다양하게 사용해보시면 좋을 것 같아요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "안녕하세요 형우님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n---\n\nQ)\n같은 것을 중복으로 만든건지 헷갈립니다.\nhistory: AI를 학습시키기 위해 내가 ai에게 물어보는 모든 것을 요약 정리해서 기록\nrequest: 내가 명령한 것을 prd에 맞춰서 작성해서 명령을 실행하기전에 나에게 검수를 받는 문서\n메모리가 저 두 폴더를 기준으로 기억을 해서 작업에 영향을 주도록 했습니다.\n이때 핵심 내용이 많이 들어 있는건 request라서 history가 필요 없지 않을까라는 생각을 했습니다.\n그러나 학습량이 많을수록 더 좋은 결과 값을 낼 것 같아서 hisory를 만들어서 사용했습니다.(중복내용은 지우고 핵심요약만 하라고 명세서에 넣어두었습니다.)\n이러한 작업이 효율적인 작업인지 아닌지 판단이 어렵습니다.\n\nA)\n중복이라고 생각한다면, 중복이라고 볼 수 있다고 생각해요 ㅎㅎ 관점의 차이랄까?\n다만, AI에게 Request가 History를 참조해서 중복되지 않는 내용만 정리해달라고 요청한다면 어느정도 중복방지를 할 수 있겠죠!? 그래서 참조를 잘 활용하는게 중요하다고 생각해요.\n\n효율적인지 아닌지 판단하는건 중복여부로 하기보단 \"응답의 퀄리티\"를 통해 분석해보면 어떨까요!?\n그래서 응답에 대한 평가 시스템도 만들어서 운영해보면 재밌을 것 같네요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "안녕하세요 희정님!\n\n2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\n심화과제의 경우 report를 남겨야 하는데... 제가 못찾는건지 report가 없네요 ㅠㅠ 아쉽지만 불합격으로 남겨놓겠습니다..!\n\n---\n\n> 에이전트 별 기능 분리가 적절하게 이루어졌는지, 혹은 역할이 모호하다거나 잘못 설계를 했는지 피드백 부탁드립니다.\n\n잘 설계되었다고 생각합니다. 다만 BMAD 기반으로 구축된거라 희정님의 의도가 많이 담겼을까? 라고 판단해보면 그건 또 에메르송 하겠네요 ㅋㅋ\n\n다르게 생각해보자면, 이런 과정이 정말 꼭 필요한걸까? 라고 질문을 해봐도 좋다고 생각해요.\nBMAD가 정답은 아니고 수단이니까요 ㅎㅎ\n\n내가 일을 할 때 이정도까지 사용할필요가 있을까? 어떤게 필요하고 어디를 더 구체화해야 좋을까? 로 질문을 한 다음에 적용해볼 수 있어야 좋다고 생각해요!\n\n\n> 반복 일정 기능을 R-001 ~ R-012로 분해한 방식이 과도한 분할인지 아니면 실무에서도 적용 가능한 수준인지 궁금합니다.\n\n이건... 스스로 판단해야 하는 문제라고 생각해요. 희정님의 실무에 적용이 가능할까요? 제가 희정님의 실무 환경을 모르니까요 ㅎㅎ\n어떤 조직에서는 필요한 과정일 수 있고, 어떤 조직에서는 \"굳이?\"라고 생각할 수 있으니까요.\n여튼 적용해보고자 한다면 당연히 적용할 수 있죠! 반대로, 적용하지 못할 이유가 있을까요?",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "안녕하세요 승현님! 과제를 수행하기에는 시간이 많이 부족했었군요 ㅎㅎ ㅠㅠ\n꼭 과제와 관련된 내용이 아니여도 궁금한게 생기면 언제든 디스코드를 통해 질문주세요! 고생하셨습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "안녕하세요 수빈님! 고민이 많은 한 주였군요 ㅎㅎ 어쩌면 이게 과제보다 더 중요할 수 있다고 생각해요.\n\n> 내가 개발을 잘 하고 싶나 부터 시작해서 내가 컴공으로 전과 했던 때는 개발을 왜 재밌어 했는지 뭔가 생각의 꼬리에 꼬리를 물고 이것저것 고민하고 아직도 뭔가 확실한 형체를 가진 결론을 내리지는 못했지만, 일단 한 가지 결정한 것은 지금 항해에서 최대한 열심히 후회가 남지 않을 만큼 해본다면 결론을 내리는 데도 도움이 되지 않을까? 하는 생각 일단 과제나 열심히 해야겠따! 라는 생각!! 아니 이젠 생각 좀 그만하고 행동을 좀 하자는 생각!!!!\n\n이렇게 항해를 신청한것만 해도 큰 도전이죠! 약간의 강제성을 부여해보자면, 팀원 한 명과 페어프로그래밍을 하는 방법도 있땁니다 ㅋㅋ 아니면 학메와 같이 한다거나!?\n\n> 학교 다니면서 했어야 할 진로 탐색을 이제서야 제대로 하고 있는 느낌이다 ㅋㅋㅋㅋㅋㅎ후ㅜㅜㅜ (웃는 게 웃는 게 아니다ㅜㅜㅜ)\n다른 사람들은 다 자기가 재밌고 잘 하는 일을 하고 있는 걸까아?\n흠 아무튼 생각이 많아지는 10월 달이다!\n\nㅋㅋ 오늘 안그래도 이런 주제로 다른 사람들과 이야기를 나눴는데요, \n재밌고 잘하고 를 둘 다 만족시키는 사람든 드물고\n\n재밌어서 하거나\n잘하고 있어서 하거나\n\n둘 중에 하나였던 것 같아요 ㅎㅎ\n\n저는 \"재밌는 축\"에 속한답니다.. 잘하지는 못한다고 생각해요.",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "소은님 고생하셨습니다!\n과제도 잘 정리해주셨고 에이전트도 잘 구성하셨어요.\n특히 프롬프트를 구조화하고 관리하는 점, Root Cause를 분석한다는 점 등에 있어서 매우 인상깊었고 제가 의도했던 부분들을 모두 회고에 작성해주셔서 너무 감사했습니다. AI를 구성하시는 이해도 대단하신것 같아요.\n\n질문해주신 부분 답변드려볼게요\n\n> XML 형식을 통해 에이전트와 커뮤니케이션 하면서 정확도가 올라갔다는 체감은 되었는데 개인적으로는 가독성 측면에서는 마크다운 형태가 더 좋았던 것 같아 trade-off가 있다고 느꼈습니다. 코치님께서는 AI / 에이전트 프롬프트나 instructions을 작성할 때 마크다운이나 XML 혹은 그 외의 형태 중 어떤 형태를 선호하시는 지, 그리고 그 이유가 있으시다면 어떤 것인지 궁금합니다!\n\n저는 마크다운을 선호하는 편인데요.\nAI로 개발하다보면 지식을 개발자가 정리하기보다 디자이너, 기획자등에게 수집을 해야 하는 경우들이 생각보다 많더라구요.\nxml로 운영을 하다보면 결국 문서를 만들고 원하는 포맷으로 옮기는 과정이 있다보니 한번에 작성할 수 있는 문서로 운영을 하려고 했고 마크다운을 많이 선택하게 되는 편인것 같아요 ㅎㅎ 이전에 공유드렸던 gpt5 프롬프트 가이드라인도 마크다운으로 되어있기도 한데, 결국 규칙이 있고 문서의 구조를 이해할 수 있는 좋은 방법을 선택하기만 하면 되는것 같아요. (html을 써도 잘 이해하는데, 토큰이 많이들고 html 구성을 제대로 못하면 효과가 크게 없더라구요 ㅎㅎ)\n\n> 테스트 코드 작성 및 로직 구현 시에 다소 복잡한 로직을 작성해야 할 때 에이전트가 고전하는 경우가 많았는데, 저의 경우 이런 상황에서 대부분 의도적으로 동작을 중지시키고 디버깅을 위한 정보를 직접 제공해주는 형태로 문제를 해결했습니다. 에이전트가 고전하는 이유를 생각해봤을 때, 코드를 넓게 보지 못 하고 단편적으로 오류가 나는 부분만 확인하다보니 실제로 문제의 원인이 아닌 부분을 문제라고 인식하고 억지로 고치려고 하는 경우가 많았던 것 같습니다. 또한 이를 통해 새로운 이슈가 발생하기도 했구요. 프롬프트를 더 잘 작성했다면 에이전트가 Root Cause를 더 잘 정의하고 이러한 현상을 방지할 수 있었을 것 같은데, 이러한 AI의 시야가 좁아지는 현상..?과 관련하여 코치님께서 경험하신 노하우나 팁이 있는 지 궁금합니다!\n\n매우 잘 해결해주셨어요. 복잡한 해결을 하려다 보면 인간의 개입이 무조건 필요하다는걸 사실 좀 말하고 싶었긴 하거든요. 종종 Agent를 통해 모든일을 할 수 있는 것들을 보여주곤 하는데, 정말 특화된 작업을 잘 되게 만드는 것은 가능하지만 우리들이 코드를 구성하고 테스트를 작성하는 범용적인 관점의 에이전트는 완벽하게 해내기가 매우 힘들거든요. 비용을 매우 많이 들이면서 문제를 찾는 방법도 있지만, 그건 좋은 방법이라고 생각하긴 힘든것 같구요.\n\n어쨋든 그럼에도 해결하기 위해 root cause를 통해 검증하거나, 체크리스트를 만든다거나, 단계를 설명해서 논리를 강제하거나 하는 방식은 좋았습니다 (그럼에도 잘못 작성하는 경우가 많아 인간이 다시 확인하는건 필연적이에요)\n\n고생하셨고 다음주도 화이팅입니다!!!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "수고 많았어요 재현! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 잘했습니다.\n\n오케스트레이션 에이전트가 잘 구현이 되지 않아 본인이 직접 업무를 부여해서 멋지게 해결했군요. 아주 좋습니다. 이 과정에서 실제 에이전트와 조금은 더 가까워지면서 오케스트레이션 에이전트가 어떻게 동작해야겠다 하는 감각이 생겼으리라 생각합니다. 사실 직접 체험을 하면 더 잘 이해하는 법이니까요. 나중에 오케스트레이션 에이전트를 만들게 되면 어떤 역할을 해야할지 잘 알게 되었으리라 생각합니다.\n\n기술적 성장 측면에서 프롬프트를 작성하는 방법이 나아진 면과 AI에게 위임하지 말자라는 성찰을 느꼈군요. AI를 활용하다보면 자연스레 느끼게 되는 부분인데 아주 좋습니다. 개발자에게는 기술적 기반으로 구체적으로 설명하는 능력와 AI의 결과를 판단하는 능력이 AI시대 참 중요한 역량이 되었습니다.\n\nQ) 에이전트 정의 문서에 명확한 워크플로우 구조를 제공했음에도 의도한대로 동작하지 않는 경우가 많았는데, 코치님이라면 각 에이전트가 md 파일로 작성되어 있을 때 오케스트레이션 에이전트를 어떻게 구성하실 것 같나요 ?? 코치님의 노하우를 얻어가고 싶습니다 :)\n\n=> Jaehyun 문서를 보니 이미 충분히 상세하게 작성했네요. 사실 저는 실무에서 오케스트레이션 에이전트를 구현하거나 활용하질 않아서 대답하기가 어렵네요. Agent를 명학하게 지정하지 않아서 일까요? @ 컨벤션등으로 한번 Agent를 명확히 지정해보는건 어떨까요? 좋은 답을 해주지 못해 미안해요 ^^; 나중에 오프 코치님에게 꼭 물어보세요!\n\nQ) 현재는 각 에이전트가 항상 동일한 결과물을 제공했으면 해서 각 에이전트마다 출력 구조를 명세하고 있습니다. 그럼에도 불구하고 가끔씩 자기 멋대로 결과물을 도출하는 경우가 있는데, 항상 동일한 구조의 결과물을 만들어 내는 것은 한계가 있는 부분일까요?\n\n=> 네, LLM은 그 원리에 따라 결과가 비결정적으로 랜덤한 확률 내에서 변경되도록 되어 있습니다. 그래서 심지어 같은 입력을 넣더라도 그 값이 조금씩 바뀌도록 설계되어 있습니다. 그래서 어떤 경우에는 원하는대로 나오지만 아닐때도 있죠. 그래서 항상 동일한 구조의 결과물을 만들어내는 것에는 한계가 있습니다. 템플릿을 명시하고 자가 체크리스트나 좋은 예 나쁜 예 처럼 참고할 것들을 많이 만들어 놓으면 좀 덜하지만 100% 보장은 할 수 없습니다. 그래서 API등을 활용할 때에는 대개 구조를 지켜서 만들었는지를 또 추가로 검사하곤 한답니다.\n\n\"AI에 대해 항상 가볍게 질문만 했었는데, 에이전트라는 개념과 실제 사용을 통해 많이 배웠습니다\"라는 회고가 과제 취지를 잘 경험하신 것 같아 좋네요. 오케스트레이션 에이전트가 완벽하게 동작하지 않았더라도, 그 과정에서 \"AI에게 명확한 입출력을 정의하고 검증하는 것\"의 중요성을 배우신 게 더 큰 수확입니다. 정말 수고 많았어요. 다음 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "[2팀 양진성] Chapter 1-2. AI와 테스트를 활용한 안정적인 기능 개발 #15\n\n수고 많았어요 진성! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 잘했습니다!\n\nAgent 구조를 3개에서 시작해서 7개까지 점진적으로 확장하면서, \"AI가 한 번에 여러 일을 할 때보다 단위별로 나눴을 때 훨씬 좋은 결과를 낸다\"는 사실을 직접 발견한 과정이 아주 좋았습니다. Context가 거대해질수록 LLM의 성능이 떨어지는 부작용이 있기에 Agent 방식에서는 이러한 Context를 최소화하기 위한 파이프라인 구성이 중요하죠. 일단 되게 해보는거 외에도 3개, 7개등 다양한 시도를 하면서 직접 나아지는 것을 확인한 점을 높게 삽니다. 프롬프트 설계에 대해 페르소나, 사전 학습, 행동 규칙, 행동 절차 등의 요소들을 정리한 것도 좋았어요\n\n심화과제도 9개 질문에 대해 모두 상세하게 작성해주셨네요. 핵심은 정보의 양이 아니라 구조화와 명확성이었습니다. 짧지만 명확한 지시가 긴 설명보다 훨씬 효과적이었습니다.\" \"결국 AI는 명확한 지시와 예시가 있으면 강력하지만, 암묵적인 지식이나 경험에서 나오는 판단은 아직 부족하다는 걸 느꼈습니다.\" 등 진성이 스스로 느낀 인사이트들이 아주 잘 느껴지는 회고였습니다. 소중한 경험이 되었으리라 생각합니다.\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/15"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "안녕하세요 새듬님!\n2주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 기본과제는 완성되지 않은 기능들이 있어서 불합격으로 남겨놓도록 하겠습니다 ㅠㅠ \n\n---\n\n> 프롬프트를 작성하는데 있어서 ai가 좀 더 쉽게 이해시키려면 예시를 드는 방법 외에 또 어떤 방법이 있나요? 참고자료를 더 추가하는 방식인가요?? 아니면 그 해당 참고자료를 요약해서 전달하는게 더 좋은가요?\n\n참고자료가 많으면 좋답니다 ㅎㅎ 다만 무조건 많은게 좋을까? 라고 생각하면 또 그렇지도 않아요. 순서도 중요하고, 핵심적인 내용이 얼마나 잘 담겨있는지도 중요하답니다.\n\ncursor editor의 경우에 docs 라는 기능이 있어서 다양한 공식문서를 읽어들인 다음에 참고할 수 있도록 만들수도 있어요.\n\nhttps://cursor.com/ko/docs/context/symbols#docs\n\n이 외에도 Context 7 같은 mcp를 사용하기도 하고, 굉장히 다양한 방법이 있어요!\n\n\n> 추가로 코치님 만의 에이전트 작성 팁을 알고 싶습니다\n\n에이전트...까진 아니고, 저는 일단 제가 원하는 목적을 AI에게 전달한 다음에 \"너라면 어떻게 프롬프트를 작성할꺼야?\" 라고 직접적으로 물어보는 편이랍니다 ㅎㅎ\n\n그리고 cursor rules 같은걸 추가해서 관리하는데, 팀 내에서 정해진 규칙을 ai가 활용할 수 있도록 옮겨놓는 편이에요.\n\n그래서 구체적인 팁이라기보단, \"현재 우리 팀에 무엇이 필요한가?\"를 기준으로 판단하고 함께 정제하는 편이라고 볼 수 있어요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/30"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "안녕하세요 태준님!\n2주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 과제를 마무리하기에는 시간이 부족했었나보군요 ㅠㅠ\n\n나중에 궁금한게 생기면 언제든 디스코드로 문의주세요!\n고생하셨습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/2"
    }
  },
  {
    "passed": false,
    "name": "윤지훈",
    "feedback": "안녕하세요 지훈님! 2주차 과제 잘 진행해주셨군요 ㅎㅎ\n다만 심화과제의 경우 report를 남겨야 하는데, 제가 못찾는건지... report가 없네요 ㅠㅠ\n\n아쉽지만 심화과제는 불합격으로 남겨놓겠습니다..!\n\n---\n\n> 이번 과제는 스스로가 좀 더 보완해야될 것 같다고 느껴지네요..! 우선 제가 먼저 보완을 해본 후 질문 사항 생기면 DM드리겠습니다!\n\n언제든 편하게 디스코드로 남겨주세요! 고생하셨습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/50"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "고생하셨습니다 예인님! \nAI에서 사용할 수 있는 내용들도 마크다운으로 잘 정리해주셨고 에이전트로 잘 구성하려고 노력도 많이 하셨던 것 같아요!\n하지만 아쉽게 테스트가 깨지기도 하고 반복일정 구현이 완벽하게 되지 않은것으로 보여서 불합격 드렸습니다 ㅠㅠ\n지금은 약간 모호해 보이는 부분도 많지만 반복적이게 사용하고 이 부분에 대해 더 많은 부분을 알아보려는 노력은 (제 개인적인 생각에서는!) 과제가 끝나서도 계속 공부해봐도 좋을 것 같아요 ㅎㅎ 지금 개발 업계 전반에서 가장 언급이 많이되고 중심이 되는 내용이니까요. 휘리릭 사라질 것 같은 부분도 아니구요.\n말씀해주신것처럼 '회사에서 AI 사용이 자유롭지는 않은데...'라고 해주셨는데 개인적으로라도 꼭! 살펴보시면 좋겠습니다 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "안녕하세요 윤지님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n---\n\nQ) 1. 에이전트 워크플로우에서 중간 파일 생성 방식의 효율성\n각 단계마다 specs, test-designs 폴더에 파일을 추가하게 해서 이 파일들을 참조하며 다음 단계를 진행하도록 설계했습니다. 이 방식이 토큰 효율성 측면에서 적절한지, 그리고 더 나은 대안이 있는지 궁금합니다.\n\nA)\n참조를 하기 때문에 토큰이 효율적인가? 라고 하면 꼭 그렇진 않다고 할 수 있어요. 참조하는 파일에 담고 있는 내용이 중요할테니까요.\n그렇다면 이건 토큰을 효율적으로 관리하는건가 라는 측면보단, 컨텍스트를 효율적으로 관리하는건가에 초점을 맞추는게 좋지 않을까요!?\n\nQ) 2. 프롬프트 최적화를 위한 체계적인 접근법\n에이전트에게 요구사항을 너무 상세히 적으면 업무 수행률이 떨어지고(제가 잘못 적은 걸수도 있겠지만요..), 간결하게 하고 진행하다보면 음.. 이 내용도 적어야하나? 근데 또 놓치면 어떡하지? 싶은 고민이 있습니다. \"답변을 여러 번 얻어보며 공통 문제를 정리해서 추가하는\" 방식으로 접근해보려고 하는데 괜찮을까요? 프롬프트 품질을 체계적으로 개선할 수 있는 방법론이나 검증 프로세스가 있을까요?\n\nA)\n프롬프트를 잘 작성했는지 AI에게 물어보는거죠 ㅎㅎ\n\n\"내가 달성하고자 하는 목적\"을 작성하고, 이 목적에 부합한지 프롬프트를 AI에게 다시 검증해달라고 요청할 수 있어요.\n\nhttps://platform.openai.com/chat/edit?optimize=true\n\n이런 플랫폼도 이용해볼 수 있답니다!\n\n다만 모델마다 효과적인 프롬프트 지침이 다르기 때문에 어느 정도는 경험을 통해 숙달해야 하는 것 같아요.\n\n\nQ) 3. TDD 사이클에서 테스트 코드 재작성의 적절성\n현재 순차적 진행 중에 코드 작성 단계에서 \"테스트 코드부터 잘못됐다\"는 상황이 자주 발생합니다. 이때 테스트 설계나 테스트 작성 단계로 다시 돌려보내는 것이 괜찮을지, 아니면 다른 방식으로 접근하는 것이 더 나은지 궁금합니다.\n\n왜 테스트 코드가 잘 못 되었는지에 집중해보면 어떨까요? 단순히 테스트를 다시 작성하는게 문제가 아니라, 왜 테스트가 잘못 작성되었는지를 분석하고, 잘못작성하게 되지 않도록 지침을 추가해서 관리해줘야 한다고 생각해요!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/23"
    }
  },
  {
    "passed": false,
    "name": "이정민",
    "feedback": "수고 많았어요 정민! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 아주 잘했습니다.\n\n\"테스트는 버그를 찾는 도구가 아니라, 개발 의도를 명문화하는 언어다\"라는 문구가 이번 과제의 핵심을 정확히 짚었네요. 오케스트레이션 에이전트를 만들지 않고, 단일 에이전트 3개(진성-테스트 설계, 희재-테스트 작성, 다솜-코드 작성)에 집중해서 TDD 사이클(RED-GREEN)을 명확하게 구현한 접근이 좋았어요. 완벽한 자동화보다 각 단계의 본질을 이해하는 게 더 중요하다는 걸 아신 것 같아요.\n\n심화 과제에 대한 질문 잘 읽어 보았습니다. 다소 피상적인 답변들로만 채워져 있어서 실제 정민이의 생각이나 맥락등이 부족하나 느껴서 잘 적어 주었는데 아쉬웠네요. 다음 번 회고는 내 경험과 생각을 조금 더 구체적으로 적어보기를 바래요.\n\n리뷰 질문 주신 부분에 답변드릴게요.\n\nQ) 에이전트 개발 자체가 처음이라 오케스트레이션 에이전트와 그 아래 모든 에이전트를 구현하려고 하지 않았습니다. 저는 단일 에이전트 하나라도 완벽하게 만들어 보는것에 집중했고 TDD 사이클을 준수하기 위해 테스트 설계 에이전트, 테스트 코드 작성 에이전트, 개발 에이전트 총 3개를 개발하였습니다. 멘토님의 강의에 따라 prd는 간결하게 적으려고 노력했고, 각 에이전트한테 최대한 역할을 주입하고, 해서는 안되는 것들을 md파일에 명시하는 방향으로 개발했습니다. 이렇게 하는 것이 맞는지 궁금합니다.\n\n=> 이렇게 하는게 맞냐 틀리냐의 대한 질문에 대한 대답은 언제나 어려운 것 같아요. 개발에 대해서는 항상 트레이드 오프라는 측면이 있고 맞다 틀리다가 아니라 당시의 맥락에 따른 최선과 그 생각에 대한 근거가 있는 것이니까요. 지금 질문에 적혀있는 맥락과 선택하게 된 근거는 타당하다 여겨집니다. 실제로 그렇게 만들어보니 결과는 어떠했나요? 잘 되었나요? 잘 되었다면 혹은 잘 안되었다면 다른 구성을 시도를 해봤나요? 차이는 어땠나요? 이런식으로 트레이드 오프에 따라 조금씩 바꿔보면서 더 나은 방향으로의 탐구를 계속 해보기를 바래요.\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "안녕하세요 현지님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> github/prd-list안에 ai로 만든 명세서가 있는데요, 제가 봤을때는 이정도면 괜찮다! 라고 생각하는데 너무 명세서를 자세히 만들어냈을까요?\n\nㅎㅎ 자세하면 좋지요!\n다만 실무적인 관점에서도 고민을 해보면 좋아요. 실제로는 어떤 명세가 필요할까, 어떤 과정이 있어야 AI가 작성한걸 사람도 이해하기가 수월할까? 를 생각해보면서 줄여갈 수 있는 부분은 줄여가고, 추가할 부분은 추가해보세요!\n\n특히 AI에게 페르소나를 입혀서\n\n\"너는 디자이너야\" 혹은 \"너는 개발자야\" 혹은 \"너는 기획자야\" 라고 명령한 다음에 \"너의 입장에서 잘 이해되지 않는 용어같은게 잇을까?\"라고 질문을 남기면서 범위를 좁혀갈 수 있답니다!\n\n> 저는 주로 책이나 인강을 통해 정보를 얻고, 예시를 봐야지 머리에 개념이 잡히고 문제를 풀어나갈수 있는데요, 항해 과제를 하면서 막상 맨 처음부터 제가 하나하나 정보를 찾고 문제 해결을 하려니까 정말 막막하고 네..그랬습니다. 혹시 코치님은 이렇게 커다란 문제가 주어질 때, 어떻게 정보를 얻고 실제에 적용하시나요? 배경지식의 차이일까요..? 다른분들이랑 너무 역량 차이가 나는것 같아서 쭈그리 되어가고있습니다ㅠ\n\n역량 차이라기보단 성향 차이라고 생각해요 ㅎㅎ 저의 경우 원래부터 비선형적인 방식으로 공부를 하다보니... 자연스럽게 그냥 구글에서 검색해서 반복적으로 나오는 키워드들을 수집하여 학습한다거나\n이제는 AI에게 학습 과정을 만들도록 한 다음에 차례차례 살펴보는 편이랍니다.\n\n커다란 문제도 작은 문제의 집합인 경우가 많아서, \"제일 먼저 무엇을 해결해야 하는가?\"에서 시작을 하게 되는 것 같아요.\n\n그리고 제일 효과적인 방법은, 이 문제에 대해 잘 아는 사람 혹은 잘 학습하고 있는 사람에게 도움을 요청하는거죠 ㅎㅎ 이게 회사에서 일을 할 때에도 제일 효과적이고 현명한 방법이랍니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/43"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "이진님 수고하셨습니다.\n\n다양한 실험들을 해보신것 같아요 :) \nLLM은 줄 번호를 인식하지 못한다는 것은 저도 처음 알았네요!\n이번 과제를 보니 다음과제도 아주 잘해내실 것 같습니다~\n수고하셨습니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "수고 많았어요 희재! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 정말 아주 아주 잘했습니다.\n\n\"그 결과, 실제 코드 개발을 담당하는 에이전트는 아직 없는데 PM, PO, UX 설계자, 아키텍트, 스크럼 마스터까지 전부 만들어버렸고, 팀원분들과 학습메이트분들에게 “왜 혼자 스타트업을 설립했냐”는 말을 듣기도 했습니다. (...) \" ㅋㅋㅋㅋ 재밌네요. 잘했습니다. 에이전트는 사람의 협업방식에 영감을 받아 만든 것이니 이런 생각을 해보는 것도 재밌네요.\n\nAgent는 파이프 라인을 만드는 것이 목적이니 과제의 취지를 이해하고 TDD 중심으로 재설계한 점이 좋았습니다. 목적에 맞게 선택하고 정리하는 것이 중요하다는 느껴보는 시간이었으리라 생각합니다.\n\nQ) 에이전트의 결과물을 어떻게 검증하는지? 잘못된 PRD를 기반으로 모든 검증을 통과하거나, 테스트 코드를 스킵하는 등 '형식적 통과' 문제가 있었는데, 이런 구조적 허점을 방지하려면?\n\n=> 아주 좋은 질문입니다. AI의 자기 검증은 근본적인 한계가 있습니다. AI가 만든게 AI로 검증이 가능했다면 처음부터 AI에게 검증을 해서 결과를 만들어 내는 방식으로 출시가 되었겠죠? 현재 LLM의 구조상 AI를 통해서 검증을 하는건 불가능해요.\n\n=> 현재 AI가 도움을 주는 건 초기비용을 줄이는 거지 최종 과정에서의 도움을 받지는 못하는 구조입니다. 그래서  인간이 최종적으로 확인을 해야 해요. 아니면 기계적으로 검증할 수 있도록 특정한 컨벤션이나 구조 여부를 테스트하는 코드를 만들어서 기계적 검증을 해야 하죠.\n\n그렇기에 Agent를 공부하더라도 TDD의 본질 자체를 공부하고 개발자가 코딩하는 경험을 쌓아야 하는 이유입니다. 앞으로의 과제를 하면서 내가 AI를 어떻게 쓰면 좋을지에 대한 생각을 잘 해보길 바래요. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "수고 많았어요 나리! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 정말 아주 아주 잘했습니다.\n\n실무에서 반복 기능을 개발한 경험이 있는데 에이전트로 빠르게 구현하면서 AI의 가능성을 직접 체감한 것 같아서 좋네요. \"agent와 일주일만에 개발을 해버려서 약간 허무하기도 했습니다\"라는 내용이 인상적이네요. 캘린더의 반복기능은 사실 정답이 있는 개발이다보니 아무래도 AI에게 시키면 잘하는 부분이라 더 그렇게 느껴졌겠네요. \n\n11개나 되는 에이전트를 나눠서 만들어 보다니 대단하네요. INPUT -> OUTPUT 관점에서 아주 세세하게 나눠서 설계하는 과정에서 테스트 파이프라인에 대한 선명한 구조가 쌓이는 경험이 되었기를 바랍니다.\n\n다음은 리뷰받고 싶은 내용에 대한 대답입니다.\n\nQ) 저는 agent 들을 역할 중심이 아니라 도구 중심으로 나누었는데, 어떤 방식으로 진행하는지가 성능에 영향을 미치는지, 아니면 역할 중심으로 하더라도 그 역할을 정확히 맡게 하면 비슷한 ouput이 나오는지, 보통 어떻게 많이 구현하는지 궁금합니다.\n\n=> 좋아요. Agent를 역할기반으로 하는 이유는 컨텍스트이 섞이거나 커지지 않도록 고립해서 일관성을 높이기 위한 방법이죠. 그래서 역할이 중심이 되건 도구의 관점으로 보던 INPUT -> OUPUT이라는 하나의 책임을 가진 파이프라인 관점으로 접근한다면 뭐든 좋습니다. 대개 역할 중심은 인간 중심의 사고에서 생각해내기 쉽고 관리하기 쉽고 설명하기 쉽다보니 주로 사용되고 있습니다. 도구적인 관점으로도 같은 맥락이라고 생각해요.\n\n정말 수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/12"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "한슬님 한 주 고생하셨습니다~ 욕을 참을 수 없으셨군요 ㅋㅋㅋㅋㅋㅋ\n작성한 내용을 살펴보면 각각 에이전트를 목적에 맞게 구현해주셨고, 특히 체크리스트 같은것들을 명확하게 해서 검증하려는 모습도 좋았어요! \n아쉽게도 반복 일정이 제대로 동작하지 않아서 불합격 처리 드렸습니다 ㅠㅠ\n에이전트를 구성하는 작업들은 잘 진행해주셨는데 너무 아쉽네요 ㅠㅠ\n\n> 각 에이전트가 오케스트레이션 에이전트에게 리뷰를 남겨서 승인하도록 했는데 그때 체크리스트로 만든 목록도 AI가 스스로 만든 것인데 과연 체크리스트를 통과했다고 좋은 테스트 코드인지 판단하기가 어렵습니다ㅠㅠ 프롬프트로 계속 체크리스트를 발전시키긴 했는데 어떤식으로 검증해야 맞는 방법인지 궁금합니다.\n\n여기서 이 질문에 답변을 해보면 좋을것 같은데, 사실 체크리스트를 만들고 AI가 하나하나 검증했다 해도! 사실 결과를 믿을 수 없는건 어쩔 수 없습니다. 시간이 지나고 LLM들의 성능이 좋아지고 에이전트의 능력이 좋아진다면 해결이 될 수 있는 문제라 생각하는데 지금 단계에서는 어쩔 수 없는 것 같아요.\n\n그래서 저는 개인적으로는 인간의 개입은 불가피하다 + AI를 통한 작업 단위를 너무 크게 잡고 길게 호흡을 가져가다보면 검증하는게 매우 힘들다라는 결론으로 작게작게 가져가는 대신 인간이 판단하고 AI에게 잘못된 지침 피드백을 빠르게 줘서 속도를 높인다는 방식으로 접근하고 있어요. 이러다가 괜찮아지면 점점 작업이 커지고 넓어지겠죠!\n\n현재 개발 시장에서 가장 주목받고 이야기가 되고 있는 주제다보니 이번 기회를 통해 관련 소식들도 따라가고 적용해보면서 생산성을 높일 수 있었으면 좋겠습니다. 너무 잘하셨어요!\n\nreport.md도 사실 제가 과제를 하면서 고민해볼법한 내용들을 정리했던건데 나중에 이 부분도 꼭 채워보세요! 고생하셨습니다~",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "안녕하세요 민수님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ\n고생하셨습니다!\n\n---\n\nQ)\n현제 제 에이전트들은\n\n1. validation : 주어진 명세를 확인하고 프로젝트 구조를 분석한 뒤, 구체적인 테스트 작성을 위한 명세 md를 작성한다.\n2. design : validation가 작성한 명세 md를 확인하고, 이를 기반으로 테스트 전략을 작성한다.\n3. red : 작성된 테스트 전략을 기반으로 테스트를 구현한다.\n4. green : 작성된 테스트 코드를 기반으로 실제 구현을 진행한다.\n5. refactor : 그린에서 작성된 구현을 리팩토링한다.\n\n이런 방식으로 동작합니다. 처음 벨리데이션에서 확인한 프로젝트 구조 이외에 나머지 에이전트들은 제 프로젝트와는 독립적으로 자신이 이전 에이전트에게서 전달받은 정보만을 활용하여 자신의 목표를 달성하도록 작성했습니다.\n이 과정에서 오케스트레이터는 각 에이전트를 실행하고, 파일을 연결하는 용도로만 사용되었고, 이를 sh 파일로 작성해, 에이전트가 아니라 사전에 정의된 명령어의 집합이 되었습니다.\n\n나름대로는 각 에이전트의 행동을 명확하게 통제하고, 코드를 직접 확인하고자 하는 의도가 있었지만, 코드를 반복적으로 생성할 때 매번 스타일이 변경되고, 단계의 후반으로 갈 수록 생성되는 코드의 품질이 떨어진다는 생각이 들었습니다. 특히 리팩터 단계의 경우 그린보다 그다지 나아지지 않는 코드를 재생산하는 등의 이슈가 있었습니다. 제 이런 전략이 에이전트가 생성하는 코드를 보수적으로 사용하고자 하는 목적이 있다면 효용성이 있는 방식인지, 에이전트를 이렇게 활용하는 것은 원래 취지에 부합하지 않는 일인지 궁금합니다.\n\nA)\n제가 느낀껀... 일단 AI가 동작하는 과정을 보면 \"로컬에 있는 파일을 참조\"하는 방식으로 동작하는 경우가 많아요. 그래서 로컬에서 작성된 코드가 이상할 경우, 그 다음 코드도 덩달아 이상해지는 연쇄효과가 있는거죠.\n그래서 초반에 코드 퀄리티를 잘 잡아줘야 한답니다! 그렇게 해야 말씀하신 것 처럼 \"보수적으로 사용하고자 하는 목적\"이 있을 때 효과적이겠죠?\n\n그리고 현재 작업중인 프로젝트에서 잘 작성된 코드의 뭉치를 던져주면 해당 코드를 참조하여 유사한 스타일로 작성하는걸 볼 수 있어요. 저는 그런 방식으로 AI가 생성하는 코드를 토대로 기능을 만들어갔었답니다!\n\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "안녕하세요 재윤님!\n2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n미흡하다기에는 꼼꼼하게 잘 해주셨다고 생각해요!\n조금 더 자신감을 가지셔도 좋을 것 같아요!\n궁금한게 생기면 언제든 디스코드를 통해 질문주세요. 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/16"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "수고 많았어요 진아! 이번 과제는 AI를 활용해 테스트 설계 → 테스트 코드 작성 → 개발 흐름을 작성해보는 것을 목표로 했습니다. 작성해준 내용을 보아하니 아주 잘 진행을 했네요.\n\n6개의 에이전트를 설계하고 orchastration 에이전트를 만들때 AI에게 워크플로우를 꼼꼼히 잘 만들었네요! 심화과정의 질문에 대한 답변 수준이 굉장히 구체적으로 자기 맥락을 담아내어 잘 설명한 점이 매우 인상 깊습니다. \n\n특히나 AI를 깊이 있게 다뤄보지 못했다가 AI를 다루게 되면서 겪는 AI가 오버엔지니어링 하는 경험이나 AI에게 AI가 만든 결과를 평가하게 만들면서 이게 맞나 싶은 부분들의 경험들을 이번 기회를 통해서 다 충분히 해본 것 같아서 AI의 활용이라는 측면에 대한 많은 생각을 해볼 수 있는 계기가 되었을거라 생각합니다.\n\n무엇보다 AI의 결과물들을 신뢰할 수 없고 신뢰한다 해도 꼭 반드시 본인이 확인해야 한다는 것을 알게된 점이 너무 소중한 내용이라고 생각합니다. \n\n다음은 질문 주신 부분 답변입니다.\n\nQ1) 오케스트레이션 에이전트가 명시한 일을 스킵하는 이유?\n\n=> 이건 현재 LLM 시스템의 한계입니다. 반복 작업이 컨텍스트가 늘어가고 점점 초기 지시사항을 잊어버리는 현상이 발생합니다. 문서 상단에 \"절대 규칙\"을 매우 강하게 명시 ex) \"반드시\", \"절대\", \"필수\" 라고 쓴다거나 제약을 강조하는 방식이 이 증상을 완화하기는 하지만 한번에 다룰 수 있는 컨텍스트의 양의 한계가 있기 때문에 이는 어쩔 수 없는 지금의 한계점이고 인지를 해야 하는 부분입니다.\n\nQ2. 저는 체크리스트 방식으로 각 단계별 검토를 하게 만들었는데, 혹시 AI 결과물에 대해 검토를 하는 더 좋은 방식이 있을까요? 검토를 위해서는 좋은 결과물에 대한 명확한 기준을 잡는게 중요한거겠죠..?\n=> 지금 하는 체크리스트 방식이 현재로서는 가장 보편적이고 좋은 방법이긴 합니다. 다만 인간의 언어는 언제나 모호하기 마련이니 체크의 기준이 모호한 경우에는 경우에 따라 같은 내용에도 체크가 다르게 될 수 있으니 언제나 이점도 감안을 해야 합니다. 사실 AI를 통해서 AI를 검토한다는 것에 대한 성능은 좋지 않습니다. 만약 그게 낫다면 AI 스스로 검토를 해서 답을 내리면 될 터인데 그러지 못하고 있으니까요.\n\nQ3. 프롬프트를 돌릴때 동일한 input에 일관된 output을 내게하기 위해서는 어떤부분을 주의해서 짜면 좋을까요? 현재는 template을 제공해도 template의 하위부분을 갑자기 다른 방식으로 작성하기도 하더라고요...\n\n=> 네, LLM은 그 원리에 따라 결과가 비결정적으로 랜덤한 확률 내에서 변경되도록 되어 있습니다. 그래서 심지어 같은 입력을 넣더라도 그 값이 조금씩 바뀌도록 설계되어 있습니다. 그래서 어떤 경우에는 원하는대로 나오지만 아닐때도 있죠. 그래서 항상 동일한 구조의 결과물을 만들어내는 것에는 한계가 있습니다. API 방식을 활용한다면 이 변화의 범위를 줄이는 tempeture값을 줄이고, JSON등으로 이후 코딩으로 검토를 할 수 있도록 추가 검증을 하는 방법등이 사용되나 LLM의 특성상 100% 일관성 아니 높은 일관성 자체가 상당히 어렵습니다.\n\n\"AI 사용에 대한 생각이 바뀌었다\", \"이점과 한계를 체감했다\"는 회고가 과제 취지를 정확히 경험하신 것 같아 좋네요. 사실 AI는 굉장히 편리한 도구이지만 그리고 때때로 제법 일을 잘하지만 절대로 맡겨둘수는 없다는 것을 느꼈을꺼라고 생가합니다. 내가 주도해서 내가 확인하고 다 검증한다는 마음으로 AI를 잘 써보기를 바래요\n\n수고 많았습니다. 다음 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/6"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "고생하셨습니다 선민님 ㅎㅎ \n시도하셨던것들 회고에 잘 남겨주셔서 감사합니다.\n작성해주셨던 cursor 관련 파일들은 따로 안보여서 스크린샷 통해서 확인했는데, 올려주시면 좋을것 같아요 ㅎㅎ\n\n질문 주신 부분 답변 드려보면\n\n> TDD 과정에서 RED → GREEN으로 넘어가기 전, 테스트 코드의 타당성은 어떻게 판단할 수 있을까요!\n기능 구현이 제대로 됐음에도 먼저 작성한 테스트 코드를 통과하지 못해서 테스트 코드를 수정해야 하는 경우가 많았는데,\n이게 TDD의 원칙에 위반되는 일이라는 생각이 들어서 혼란스러웠습니다.\n\n말씀해주신 부분은 자연스러운 현상이라고 이해해주시면 됩니다. TDD원칙에 위배되지 않아요 ㅎㅎ 계속 시도하고 익숙해지는 과정이 진행될거고 시간이 지나면 이런 부분도 자연스럽게 사라질거라고 생각이 듭니다. \n테스트의 타당성은  명확하게 요구사항을 반영했는지, 작은 단위로 테스트가 잘게 쪼개져 있는지, 독립적이게 동작하는지, 설계단계에서 구체화를 시키려고 하는지 등에 대해서 생각하면 될것 같습니다.\n\n고생하셨고 다음 주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/47"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "안녕하세요 세준님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n다만 특별한 질문은 없는 것 같군요..!\n\n> 이 아웃풋 전달과 조율의 책임을 오케스트레이터에게 위임해야 하는 게 맞을까?라는 점이었습니다. 만약 오케스트레이터가 모든 단계의 입출력을 관리한다면 구조는 깔끔해질 수 있지만, 반대로 에이전트의 자율성과 독립성이 약해질 수 있다는 우려도 있었습니다.\n\n자율성과 독립성이 필요한 상황과, 입출력을 일관성 있게 나오도록 해야하는 상황이 무척 다르다고 생각해요.\n\n자율성, 독립성이 필요한 경우는 보통 무언가를 밑바닥부터 만들어갈 때라고 생각하는데 이럴 때는 제한을 하기보단 풀어두고 어떻게 하는지 지켜보는 것도 방법이지 않을까요!?\n\n그래서 두 가지 상황을 모두 만들어낼 수 있도록 연습이 필요하다고 생각해요!",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "채은님 수고하셨습니다!\n\n회고는 잘작성해주셨지만  과제 를 온전히는 수행하지 못하신것 같아요!\n그래도 여러가지 고민들이 느껴지는 회고였습니다!\n\nQ. 에이전트가 제가 생성해둔 BAD나 DON'T (하지 말아야 할 것)과 같은 규칙을 어기거나, 아래의 사진처럼 skip하는 경우가 생기는 상황이 있었습니다.\n\nA. 지침이 조금 부족한 것 같은데요. 계층적으로 명세구조를 만들고 말씀하신 원치 않는 부분들에 대한 지침을 추가하면 어떨까요?(얘를들어 반드시 지켜야할 규칙)\n솔루션 코드를 보시면서 비교해보시면 어느정도 답을 찾으실 수 있을 것 같습니다!\n\nQ.  각 역할 별 에이전트를 생성할 떄, 페르소나 -> input -> GOOD/BAD -> 코드 검증(test, lint) -> output 과같은 흐름으로 구성을 했는데, 좋은 접근 방식이 맞았을지 궁금합니다.\n\nA. 네 저는 괜찮다고 생각합니다~ 코드 검증으로 리플렉션도 진행될테니까욥. 근데 모든 에이전트를 동일하게 맞출 필요는 없을 것 같고 필요에 따라 적용하면 좋을 것 같아요. 솔루션 코드를 보시면 아시겠지만 채은님과 비슷한 접근의 에이전트가 있고 아닌 경우도 있습니다. 에이전트의 요구에 맞게 구성하면 좋을 것 같아요~\n\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/21"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "안녕하세요 준태님! 2주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n---\n\n> 클로드에게 서브 에이전트를 생성하기 위한 디스크립션을 짜달라고 하고 해당 내용으로 클로드 코드의 서브 에이전트를 만들었는데, 내용이 너무 방대하고 많아서 에이전트가 전부 소화하지 못하는 느낌이 들었습니다.\n에이전트를 위한 지침서의 적당한 길이는 얼마인지, 또 에이전트를 잘 활용할 수 있는 '특정 워딩'들이 있는지 궁금합니다.\n\nhttps://docs.claude.com/ko/docs/build-with-claude/prompt-engineering/prompt-improver\n\n이런걸 활용해보시면 좋답니다 ㅋㅋ 클로드에서 제공하는 공식 최적화 가이드랄까..\n\n적당한 길이라면.. 사실 짧은게 제일 좋지요. 담을 수 있는 정보를 다 담으면서도 짧게 작성할 수 있도록 연습이 필요할 것 같아요.\n\n가령, 중복 표현을 별도의 문서로 분리한다거나 혹은 특정 작업을 수행할 때 별도로 참고할 수 있는 문서를 던져준다거나?\n\n서브에이전트도 오케스트레이션 레이어에서 \"특정 작업이 필요할 때 서브에이전트를 호출하여 수행\"하는 것 처럼, 서브 에이전트도 모든 작업을 다 구체화 시켜서 진행하기보단 별도의 문서나 룰로 찢어서 구체적인 가이드는 그 작업을 할 때 참조할 수 있도록 하는거죠.\n\n> 이번 과제에서는 총 6단계의 에이전트로 나뉘었지만, 실제로는 더 잘게 쪼개는게 좋을지 아니면 덜 나누는게 좋을지 궁금합니다.\n\n\"실제\"는 준태님의 현업에 대한 고려가 필요해요. 저의 현업과는 얘기가 아예 다르겠죠?\n그리고 어떤 프로젝트를 진행하는지, 나와 의사소통 하는 사람이 어떤 사람들이 있는지에 따라서도 많이 달라진답니다.\n아예 에이전트 자체가 필요하지 않을 수도 있어요 ㅎㅎ\n\n정답이 있다기보단 각각의 상황에 맞는 다양한 해결책이 있는거죠.\n",
    "assignment": {
      "name": "STEP04 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-2/pull/49"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/29"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/16"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/49"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/12"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/31"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/44"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/52"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/19"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/22"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/46"
    }
  },
  {
    "passed": false,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/3"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/33"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/47"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/51"
    }
  },
  {
    "passed": false,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/9"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/2"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/24"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/37"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/50"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/10"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/26"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/35"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/30"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/11"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/25"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/6"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/40"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP05 프론트엔드 테스트 설계와 AI 활용 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/42"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "안녕하세요 승훈님! 테스트는 잘 진행해주셨는데, 필수 스펙 구현은 진행되지 않았군요 ㅠㅠ\n\n> E2E 테스트를 작성하며 느낀점이 있습니다. 그 주제에 맞게 (가령 기본 일정 관리 전반에 대한 검증) 코드를 짜는데 그 흐름을, 무조건 통과하기 위해 테스트를 짜는 것 같은 느낌을 받았습니다.. 이렇게 무조건 통과하려고 짜는 식의 코드여도 테스트가 정말 유의미할까요? 그렇지 않다면, 어떻게 하면 유의미한 테스트 코드를 짰다고 느낄 수 있을까요?\n\n일단 무언가를 검증한다는 것 자체가 유의미하다고 생각해요 ㅎㅎ\n저는 테스트의 제일 큰 효과가 \"사이드 이펙트를 찾는 것\" 이라고 생각하는데 사이드이펙트는 \"변경\"이 일어날 때 발생해요.\n그래서 리팩토링을 하거나 기능을 추가하는 과정에서 일부 코드가 수정되고 이 과정에서 기존에 동작하던 코드에 문제가 있다면 테스트를 통해 발견할 수 있겠죠!?\n\n> 회사에서 글자 크기등을 전체적으로 변경해야하는, 디자인 전반적으로 수정되는 부분이 있는데, 이 때 시각적 회귀 테스트를 쓰면 좋지 않을까 생각이 들었습니다. 이럴 때 쓰는게 맞을까요?\n\n그럼요 ㅎㅎ 그리고 꼭 디자인 수정 뿐만아니라 다양한 사이드 이펙트를 찾아낼 때 유용하답니다! 일단 한 번 적용해보세요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/29"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "고다솜",
    "feedback": "수고했어요 다솜. 지난 테스트 코드를 통해서 빅테크에서 대형 소프트웨어의 규모가 커졌을때 장애나 무결성을 확보하기 위해서 어떤한 노력들이 필요한지를 지난 3주간에 걸쳐서 간접적으로나마 체험할 수 있는 기회였기를 바래요.\n\n이러한 테스트를 만드는데 들어가는 품이 엄청나지만 이러한 것을 감안하고도 도입하고 시도하려는 걸 보면 테스트가 없었을때의 대규모 프로젝트가 얼마나 고통스러울지를 생각해보며 언젠가 커리어상 그런 프로젝트를 하게 될때 테스트가 주는 그 생소함과 접근성등으로 인해 겁먹지 않을 수 있는 예방 주사가 되어주었기를 바랍니다.\n\n무엇보다 이제 이러한 과정들을 거쳤기 때문에 느낄 수 있는 해냈다와 나도 잘 할 수 있는 개발자구나 하는 마음이 생겨났길 바래요.\n\n이제 앞으로 새로운 챕터들을 맞이 할텐데 새로운 챕터도 지금 처럼 화이팅입니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "수고했어요 정원! 지난 3주간 테스트를 경험하면서 대규모 프로젝트에서 품질을 어떻게 지켜내는지 간접적으로나마 체험하는 시간이 되었기를 바랍니다. 테스트를 라는 새로운 세상이 생소했을 텐데 이해하고 적응하느라 고생했어요.\n\n아쉽게도 이번 주차 과제를 완료하지 못했지만, 팀원들끼리 열심히 테스트 전략을 논의하고 수락하면서 얻어간 부분이 있을거라고 생각해요. 일단 낯설지 않도록 그래서 테스트가 필요한 상황에서 부담없이 공부할 수 있게 되었다면 반절의 성공은 거뒀다고 생각합니다.\n\n이제 테스트 챕터가 끝나고 새로운 챕터는 React를 기반으로 하니 좀 더 수월할 거예요. 부족한 시간을 동료들의 코드로 메꿔가며 정원만의 시간 전략을 잘 세워나가보길 바래요! 수고했습니다.\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "안녕하세요 연욱님! 3주차 과제를 진행하기에는 시간이 많이 부족했었나보군요  ㅠㅠ\n\n4주차부터는 다른 주제로 진행되니까 잘 진행할 수 있기를 바랍니다! 화이팅입니다!!!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "권지현",
    "feedback": "수고했어요 지현! 지난 3주간 테스트 챕터를 진행하면서 드래그 앤 드롭부터 E2E, 시각적 회귀 테스트까지 정말 많은 것들을 해냈네요. 지금까지 익숙지 않고 생소한 테스트 코드에 대해 딥다이브 하느라 수고 많았습니다. 해보지 않은 것을 하는 과정에서 개념을 따라가는게 쉽지 않았을텐데 팀원들과 함께 생각들을 나누면서 나의 시야와 저변이 넓어졌을리라 기대합니다.\n\nQ) 일정 수정 혹은 생성 후 스낵바 노출에서 타이밍 잡기가 쉽지 않은데(언제는 성공하고, 언제는 실패) 이런 케이스에서는 보통 어떻게 처리하시나요 ? response 응답 기다리는 방향도 시도해봤는데 timeout으로 실패하는 케이스가 다수 발생해서 원인이 API 응답 타임아웃으로 스낵바가 미노출된 건지, 어쩌면 디버깅일 수도 있겠습니다 ㅎㅎ 이 부분 판단하기가 쉽지 않네요.\n\n=> 그렇죠. E2E 테스트에서 가장 흔하게 겪는 문제예요. 요구사항에서 명시적인 시간이 있는게 아니라면 timeout보다는 요구사항을 근거로 작성하는 것이 제일 좋습니다. 스낵바 노출한다가 요구사항이라면 waitForSelector('.snackbar', { state: 'visible' })나 혹은 성공이나 실패 문구가 노출되는지 등 요구사항을 중점으로 만들어둔다고 생각하면 좋습니다.\n\n=> 그렇게 e2e 코드는 요구사항에 맞게 고정하고 나면 이후 디버깅할 때는 --debug 모드로 실행해서 정확히 어느 시점에 성공하는지 실패하는지 확인을 하면서 조금씩 코드를 만들어가면 좋아요. e2e는 코드와 관계없이 사용자와 기획서를 중심으로 작성한다는 원칙을 기억하면 좋아요.\n\n\nQ) 브라우저별로 결과의 차이는 보통 어떻게 처리하시나요 ? 이번 과제 중에 드래그는 webkit에서 인지하지 못한다는 걸 알게되서 예외처리를 해주었는데요. 그 외에 예를 들면, 일정 겹침 모달창이 뜨는 로직이 firefox에서는 실패하고, webkit/chromium에서는 성공하는 케이스처럼 같은 상황에서 결과가 차이나는 경우는 어떻게 처리해줘야할 지 애매하더라구요. 같은 로직으로 진행되는데 아예 모달을 인지하지 못한다던가, 결과가 다른 경우의 원인도 궁금합니다 ..!\n\n=> 현실적으로 모든 브라우저를 테스트하기는 어렵습니다. 대개 주력 브라우저(Chrome/Edge)를 중심으로 코드를 작성하고 예외가 발생한다면 별도의 테스트를 만들거나 검증이 가능하다면 조건문을 추가하는 정도입니다. 사실 크롬/Edge만 만족해도 거의 괜찮거든요.\n\n=> Playwright에서는 test.skip(({ browserName }) => browserName === 'firefox')로 특정 브라우저를 스킵하거나, 조건부로 다른 방식을 사용할 수 있어요. 꼭 해야만 한다면 디버깅이 어렵지만 하나씩 찾아가봐야겠죠ㅠ\n\n3주간 고생 많았습니다. \"아직 조금 모호한 부분도 있지만 각각의 테스트들을 어느 상황에 사용하는 게 적절한 지 어느 정도 익히게 되었던 주차였다고 봅니다.\" 라는게 이 챕터의 가장 중요한 핵심이었습니다. 잘했어요. 다음 챕터에서 만나요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/49"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "단헌님 이번에는 시간이 별로 없었던 것 같습니다 .\n아쉽지만 다음에는 과제를 완수할 수 있길 기대할게요!!\n수고하셨습니다!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "대현님 수고하셨습니다.\n\nQ. 이런 상황에서 어떤 레벨의 테스트(단위/통합/E2E)를 우선적으로 도입하는 것이 효율적일까요?\n\nA. 컴포넌트 구조가 변경되면 어떤 테스트도 테스트가 변경될 가능성이 있습니다.\n중요한건 구조의 변경이 아니라 테스트 코드가 알고 있는 대상 모듈의 인터페이스에 변화가 있느냐 없느냐인 것 같아요.\n예를들어 테스트 케이스에서 어떤 데이터의 값이 변경되었는지를 확인할때 특정 테스트아이디 값으로 그 엘리먼트를 확인한다면\n컴포넌트의 구조가 아무리 바뀌어도 그 엘리먼트와 값만 변화가 없다면 테스트케이스는 바뀔이유가 없겠죠?\n인터페이스가 이렇게 중요합니다 :)\n\nQ. 컴포넌트가 어느 정도 안정화되었다고 판단할 수 있는 구체적인 기준이 있을까요?\n\nA. 질문의 의도가 더 궁금하긴 한데요~ 버그가 없어 장애가 나지 않은 컴포넌트가 안정화된 컴포넌트 혹은 지면이라고 할 수 있지 않을까요?\n\nQ. 변경에 강한 테스트를 작성하기 위한 구체적인 전략이나 패턴이 있을까요?\n\nA. 내부 구조가 아무리 변화해도 인터페이스는 변경되지 않는(인풋,아웃풋), 그리고 외부에 노출되지 않은 private한 함나 메서드를 직접 테스트 하지 않기\n테스트케이스가 대상 모듈의 오직 공개된 인터페이스만 알고, 세부구현은 모르면 모를수록 변화에 강한 테스트케이스가 됩니다. 이렇게 되려면 모듈도 꼭 필요한 것들만, 최소한의 인터페이스를 제공할 수록 좋겠죠.\n부끄럽지만 예전에 제가 작성한 포스트가 있는데요 도움이 되실지 모르겠네요.\nhttps://blog.shiren.dev/ko/post/2020-06-15",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "수고했어요 도현! 지난 3주간 테스트를 경험하면서 대규모 프로젝트에서 품질을 어떻게 지켜내는지 간접적으로나마 체험하는 시간이 되었기를 바랍니다. 도현은 E2E, 시각적 회귀 테스트, Playwright, Chromatic, Storybook 모두 처음 접했다고 했는데, 그럼에도 불구하고 일단 한번 뭐가 되든 해보고 아웃풋을 만들어냈다는 점이 정말 좋네요!\n\nAI를 많이 활용하는 과정에서 코드품질 컨트롤을 못한게 아쉽다고 했는데 다행히 테스트 쪽 코드는 있는 그대로 작성하는 편이라 AI가 만들어도 코드 품질이 그렇게 나빠지지 않으니 테스트는 AI의 도움을 받으면서 점진적으로 이해도를 높이는 방향으로 진행해보세요. \n\nQ) Storybook-Chromatic을 실무에서 어떻게 활용하는지? snapshot을 가지고 업무적으로 어떤 대화를 나누는지?\n\n=> 아쉽네요. 제가 커리어를 하면서 Storybook-Chromatic를 실무에서 써본 경험은 전무해서 제 경험을 바탕으로 설명을 드리기는 어렵네요. 함께 협업하는 팀에서 PR마다 snapshot이 올라간 것을 본 적이 있는데 든든할 것 같다는 생각이 듭니다. 종종 리팩토룅 과정에서 CSS 단순 누락으로 인해 핫픽스를 할때면 이런거 알려주면 참 좋겠다 싶었어요. 프로젝트가 너무 커서 그걸 하나하나 눈으로 다 확인하기에는 비용이 너무나 많이 들거든요. \n\n나중에 다른 분들의 경험을 알게 되면 또 공유 남겨볼게요. 수고많았습니다. 이제 새로운 챕터에서 함께 해요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/12"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "안녕하세요 민석님!\n\n3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\nQ1)\n이번에 E2E 테스트를 진행하면서, 테스트를 실행할 때 이 프로젝트에서 임시 DB로 사용하는 JSON 파일의 데이터가 실제로 변경된다는 점을 확인했습니다. 그 결과, 첫 번째 테스트에서 생성한 일정 데이터가 이후 테스트 문에도 영향을 미치는 상황이 발생했는데요.\n실무에서는 이렇게 이전 테스트에서 생성된 데이터를 기반으로 다음 테스트가 이어지는 방식으로 E2E 테스트를 진행하는지 궁금합니다.\n\nA1)\n보통 테스트 시작전에 json을 항상 초기화 해주는 방식으로 진행한답니다! 그래서 테스트 간의 사이드 이펙트를 줄이는 방식으로 관리하는 편이에요 ㅎㅎ\n아니면 의도적으로 테스트 데이터를 보존한 다음에 순차적으로 실행하는 방식도 생각해볼 수 있어요. 중요한건 \"의도\"를 했는지 안 했는지의 차이겠네요.\n\n그리고 검증하고자 하는 구간을 테스트 스펙으로 구분하기보단 아예 하나의 테스트에서 주석이나 혹은 다른 장치를 토대로 구분할 수도 있을 것 같아요!\n\n\nQ2)\n위의 방식과는 반대로, 저는 첫 번째 테스트의 결과가 두 번째 테스트에 영향을 미치게 되어, 뒤에 있는 테스트 코드들까지 연쇄적으로 실패할 가능성이 있다고 생각했습니다.\n그래서 각 테스트는 서로 독립적으로 실행되어야 한다고 판단했고, 이를 위해 e2e.json 파일과 seed 역할을 하는 e2e-template.json 파일을 별도로 만들어 관리했습니다.\nbeforeEach 문에서 테스트를 시작하기 전에 e2e-template.json의 내용을 e2e.json에 덮어씌우도록 설정하여, 모든 테스트가 항상 같은 초기 상태의 e2e.json 파일을 참조하도록 구성했습니다.\n이 방식이 제가 생각한 가장 안정적인 방법이었는데, 실무에서는 이러한 데이터 초기화를 어떤 방식으로 처리하는지 궁금합니다.\n\nA2)\njson파일을 직접적으로 가져다 사용하기보단 복사해서 사용하면 오염될 위험이 적답니다!\n원본은 보존하고 복제해서 사용하는거죠 ㅎㅎ\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/31"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "오~ 성민님 이번 주 과제 아주 훌륭하게 해주셨네요.\n스토리북 구성도 잘 해주셨고, e2e 테스트도 필요한 만큼 잘 작성해주셨습니다. 코칭 시간에 보여주셨던것처럼 최종 테스트 전략 수립도 아주 잘 해주셨어요. 당연히 DND도 잘 구현해주셨네요!\n따로 크게 말씀 드릴 부분은 없지만, 종종 테스트에 wait을 걸거나 catch를 걸게 되면 발견할 수 있는 에러를 발견할 수 없기 되거나, 시간이 매우 늘어나게 되는 상황이 만들어 질 수 있어요. 정말 필요한 케이스들도 있어서 절대 사용하지 마세요! 라고는 말씀은 못드리겠지만, 이걸 절대 남발해서는 안되거든요.\nplaywright나 cypress처럼 대부분의 e2e 테스트 도구는 비동기적 동작을 자동으로 재실행하는 동작을 쥐고 있거든요. 요런것들을 잘 활용해본다면 더 좋은 테스트가 될 것 같습니다.\n앞으로도 현업 진행하시면서 배웠던 것들 꼭 적용해보시고, 어려운 점 있으면 언제든지 편하게 말씀 주세요! \n\n따로 질문 없으셔서 여기서 마무리할게요 ㅎㅎ 고생하셨습니다~",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/44"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "안녕하세요 소리님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 이렇게 했더니 병렬 실행을 했을 때 문제가 생긴다...😃 그래서 처음엔 일단 순차적으로만 실행되게 했지만 느려서 아쉽기 때문에...\nTestInfo에서 worker index를 가져와서 커스텀 헤더에 넣었다.\n\n병렬로 실행하기 위한 시도를 많이 해주셨군요 ㅎㅎ\n일단 항상 다른 json을 사용하는 방법도 있고, 혹은 json 파일을 복사해서 메모리에 올려놓는 방식으로 진행할 수도 있을 것 같아요!\n혹은 api 자체를 목킹하는 방식으로 사용하거나?\n\n> 테스트의 안정성을 위해 addInitScript로 날짜를 11월 3일로 고정했습니다. E2E 테스트는 테스트의 신뢰도를 위해서 날짜를 조작하지 않는 게 나을까요? 그리고 실무에선 api 보안 문제가 있을 수 있을까요?\n\n날짜는 \"사이드 이펙트\" 라고 생각해요 ㅎㅎ 그래서 웬만하면 고정시켜놓는게 좋습니다.\n대신 다양한 날짜에 대한 테스트가 필요하겠죠? 윤년, 윤달 같은 엣지케이스를 만들어놓고 다양한 상황에서 정상적으로 동작하는지에 대한 테스트를 진행해보면 좋을 것 같아요!\n\n그리고 말씀해주신 것 처럼 API와 관련된 이슈도 있을 수 있어서 test api 를 사용하거나 혹은 아예 api 자체를 목킹해서 사용하는 방법도 있답니다. 아니면 테스트를 할 때는 msw를 이용한다거나?\n\n> flaky 테스트는 어떻게 처리해야 할까요. 테스트 코드 자체에서 안정성을 보강해주는 게 나을까요? 타임아웃 시간을 더 늘린다든가 하는 방식이어야 할까요 아니면 근본적인 다른 방법이 있을지.\n\n흠... flaky 테스트가 뭘까요?\n찾아보니까 \"매번 결과값이 달라질 수 있는\" 테스트를 의미하는 것 같네요 ㅎㅎ\n시간, 난수 등 고정되지 않은 값을 인자로 사용하는 경우에 대한 테스트이려나요?\n\n이런 구간에 대해서는 고정값으로 목킹을 하는게 제일 좋은 방법이라고 생각해요.\n\n> 실무에선 백엔드와 어떤 식으로 협의를 할까요? 테스트용 DB를 따로 두나요?\n\n말씀하신 것 처럼 테스트용 DB를 만들어서 사용할 수도 있고 혹은 제가 위에 언급한 것 처럼 MSW를 사용하는 방법도 있답니다 ㅎㅎ\nAPI 응답 자체를 목킹하는거죠.\n\n그리고 MSW의 응답을 테스트를 실행하는 시점에 실제 API의 Fixture로 만들어서 제공하는 방법이 있어요.\n혹는 테스트가 완료되는 시점에 계속 fixture를 교체해주거나?",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/21"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "수고했어요 우정. 지난 3주간 테스트 라는 챕터를 잘 진행해주었네요. 본인이 직접하다가 또 AI를 통해서도 해보다가 이를 직접적으로 비교해가면서 차이점을 익혀하는 과정이 너무 좋아요. AI에게 시켰을때 잘 하고 있는지 아닌지도 명확히 구분을 하듯이 구분이 되어 간다는 점에서 AI를 잘 활용하고 실력이 올라갔다 생각합니다.\n\nUI가 보여서 e2e 테스트 과정은 좋았군요. e2e와 통합테스트는 분명 비슷하지만 e2e는 로직을 생각하지 않고 그냥 사용자 봐야 하는거 -> 눌러야 하는 거 -> 변해야 하는 거를 측정하는 거라면 통합 테스트는 로직을 중심으로 체크를 한다는 면에서 관점이 다르게 적용이 되더라구요. 저도 e2e를 작성하는게 좀 더 수월하다고 생각해요. \n\n그리고 chromatic을 회사에서 도입해본다면 정말 크게 도움이 될 거에요! 실제 도입이 되든 안되든 실무에 맞게 해본다는 경험이 정말 중요하니까요. 기대가 되네요 나중에 어땠는지 들려주세요.\n\nQ) 과제에서는 테스트용 db를 따로 구축했는데, 실무에서는 어떻게 해야할지 잘 그려지지 않는 것 같습니다. 백엔드와의 소통과 협업이 필요하다고 하셨는데 구체적으로 어떤 커뮤니케이션을 하고 어떤 요청을 드려야할지 설명해주시면 감사하겠습니다!\n\n=> 일단 인프라적 측면에서 백엔드의 도움을 받고 실제로 DB의 값을 조회하고 읽고 쓰고 삭제해야 하므로 테스트용 서버가 별도로 필요하겠죠. 특히나 테스트의 일관성 측면을 위해서는 DB의 초기화도 필요하고 이메일 발송, 인증, 결제 등등은 테스트용 mocking도 필요하겠죠.\n\n=> 우선은 테스트를 한다면 스스로 테스트 환경을 다 갖춰본다면 쓰기가 필요한상황이 되었을때 먼저 설명해보세요. 백엔드 개발자분이 알아듣는다면 함께 현 상황에서 논의해볼 수 있고, 그럴 수 없는 상황이라면 읽기 전용으로만 시도하거나 아쉽지만 내부 MSW 정도만 가지고 진행한다거나 지금처럼 별도의 테스트 DB를 따로 구축하는 형태로 시도해보면 될거에요.\n\n=> 데이터를 격리할 수 있는 방법, 데이터를 되돌릴 수 이는 방법, DB가 아닌 실제 기능을 mocking하는 방법등 테스트를 했다고 기존 상태에서 달라지지 않도록 만들 수 있는 방법을 중심으로 함께 논의해보길 바래요.\n\n수고하셨습니다. 이제 테스트 챕터에서 새로운 챕터로 가네요! 다음 시간도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김준모",
    "feedback": "준모님 수고하셨습니다.\n\nQ. 기능별(도메인 단위)로 테스트를 나누는 것이 일반적인지,\n아니면 컴포넌트나 서비스 레이어 중심으로 나누는 방식이 더 실무적으로 효율적인지 알고 싶습니다.\n\nA. 사실 이것은 테스트가 먼저 라기보다는 어플리케이션 구조를 어떻게 잡았느냐가 중요한 것 같아요.\n테스트 전략에서 제일 중요한 것은 어플리케이션이 어떤 구조를 가지고 있고 어떻게 추상하된 레이어를 가지고 있는지 입니다.\n테스트 입장에서는 사실 이게 기능별인지 서비스 레이어인지 알 필요 없이 대상 컴포넌트를 테스트하게되는 것이고요\n다만 예를들어 어떤 레이어가 사이드 이펙트가 너무 많아서 테스트를 하기가 힘들다라는 결론이난다면\n해당 레이어를 사이드이펙트가 많은 부분과 테스트가 가능한 부분 두개의 레이어로 나눠서 테스트 가능한 부분만 테스트 집중하고\n사이드이펙트가 나는 부분은 최대한 얇게 유지하는 형태로 테스트를 아예 안하기로 결정할 수 있겠죠.\n이런 경우는 테스트가 구조에 영향을 준 부분이고 실제로 구조도 유연해집니다. :) \n\nQ. 크로마틱 토큰\n\nA. 크로마틱 토큰은 사실 지금 상황이 그런것이지 실무에서는 협업자들이 모두 알아야하는 키를 사용할 것이고 그리고 애초에 공개된 리포가 아닐것이기에 신경쓸게 없을 것같아요.\n지금상황에서는 제생각엔 env와 같은 특정 파일을 git에 올리지 않고 로컬에서만 들고있는 방법밖에는 없을 것 같습니다.\n사실 과제니까 이렇지 일반적인 상황은 아닌것 같아요.\n과제 평가가 끝나면 키를 무효화하거나 변경하는 작업이 필요할 것 같네요.",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "고생하셨습니다 채영님\n남겨주신 꼼꼼한 회고, 그리고 올려주신 정리한 글들 다 꼼꼼하게 읽어봤는데 제가 준비했던것보다 더 잘 수행해주셨던것 같아서 감사한 마음이드네요.\n필요한 테스트는 모두 잘 작성해주셨습니다 :+1\ndnd 같은 경우 통합 테스트로 작성해주시면서 fireEvent까지 빡세게 사용해보셨던 것 같은데요 ㅎㅎ \n나중에는 한번 지금 작성하셨던 코드와 비교되도록 playwright e2e 테스트로 작성해보시면 더 좋을것 같네요.\ne2e도 보면 반복적인 설정 코드들이 들어가는 부분이 있는데 Setup과 teardown도 활용해보면 좋지 않을까! 싶습니다.\n\n회고로 다시 돌아와서  MSW에 대해서 정리해 주신 부분은 명확하게 이해해주신것 같아서 부연설명을 남기진 않을게요. 하나의 도구로써 이해하고 정말 여러군데에서 활용할 수 있는 라이브러리니 잘 활용해보시면 좋을것 같습니다 ㅎㅎ\n\n질문 남겨주신 부분 남겨보면요!\n\n> 병렬 접근의 장단점은 무엇인가요? \n\n사실 이게 제 표현이 정확하지 않았을 수 있는데요. 제가 당시에 병렬이라고 말씀드렸던 부분은 '통합 테스트를 적용하고 e2e로 넘어가야한다' 가 아니라 '통합 테스트를 작성하면서, e2e도 함께 적용해서 테스트를 작성해도 된다' 라는 관점에서 말씀드린거긴 합니다 ㅎㅎ 그래서 질문주셨던 관점에서는 편하신대로 하시면 됩니다.(그럼에도 저는 말씀해주신 구분에서는 점진적으로 하는 편이 좋은것 같아요)\n\n> 프로젝트 성격(예: 캘린더처럼 기능 간 연결성이 강한 경우)에 따라 어떤 기준으로 접근 방식을 선택하면 좋을까요?\n\n요거는 위에걸로 오해가 풀린걸로 하고 넘어갈게요!\n\n> 같은 기능을 두 레이어(통합/E2E)에서 검증해도 괜찮을까요, 아니면 중복을 피하는 게 좋을까요?\n\n이 부분도 아마 살짝 언급을 했던 부분인데요. 같은 기능이라 할지라도 검증하는 내용은 다를거에요. e2e는 실제 브라우저 상에서의 검증이고, ui 가 나타나기까지 영향을 주는 많은 부분이 있으니 해당 부분을 모두 껴안고 테스트를 한다 라고 볼 수 있는거니까요. \n정리하면, 너무 중복되는 부분의 검증이라면 훨씬 빠르고 비용이 적은 통합 테스트 환경에서 검증하는 것이 좋지만 너무 이 범위를 나누는게 힘들고 고민이 된다면 둘 다 검증해서 나쁠것은 없으니 그대로 하셔도 된다라고 말씀을 드리긴합니다!\n명확하게 나누는게 핵심은 아니에요! 우리가 검증을 하는 시나리오가 무엇인지가 핵심입니다.\n\n> 이런 방식(filter, locator 등 의미 기반 쿼링)을 사용하는 것이 테스트의 안정성과 유지보수성 측면에서 적절한 접근일까요?\n혹은 더 권장되는 쿼링 전략(예: role, label, data-testid 기반 선택자)이 있을까요?\n\n굉장히 좋은 질문인데요! \nrtl을 설명드릴때는 제가 '이 라이브러리의 철학은..'이라고 하면서 말씀 드렸을거에요. 유저와 비슷한 시나리오로 검증하는것이 신뢰성이 높아진다는 관점에서요. 하지만, cypress나 다른 도구들의 문서를 보면 class 선택자 같은 쿼리 방식으로 접근하는게 더 구현 관점에 얽매이기 때문에 testid를 사용하는게 좋다고 권장하고 있습니다.\n\n어쨋든 정리해보면, nth, first 같은 방식으로 접근하는게 너무 구현집약적이고 수정할때마다 테스트에 수정이 발생해야 한다면 Test id를 사용하는게 더 나은 방식인것 같아요. 유지보수하기 더 좋은 방식으로 선택한다면 뭐든 상관없을것 같아요! ㅎㅎ\n\n고생하셨고 지금처럼 이라면 다음주도 잘 해주실 거라 생각합니다. 새로운 주제도 화이팅입니다!\n\n두 테스트 레이어의 목적과 범위를 구분할 때 어떤 기준이 가장 명확할까요?\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/52"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "안녕하세요 현우님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 테스트 코드를 작성하는데 방식이 처음부터 끝까지 일일히 지정해주어야 해서 명령형에 가깝다고 느껴졌는데, 선언형 스타일에 가깝게 테스트 코드를 작성할 수 있을지 궁금합니다. 이렇게 되면 테스트 코드도 더 가독성이 올라갈 수 있을 것 같다 생각했는데 이러한 관점이 테스트 코드 작성하는데 있어선 불필요한 관점일까요? 애초에 테스트 코드라는게 구체적인 환경에서 일련의 시나리오 대로 수행되어야 하는 것이기에 명령형 스타일로 작성되는 것이 일반적인 건가 싶어 질문 드립니다.\n\n오.. 이런 관점에서는 생각해본적이 없어서 갑자기 말문이 막혔어요 ㅋㅋ\n흠... 비슷한게 뭐가 있을까 생각해봤는데\n\ntest.each 같은 API를 이용하면 반복적인 테스트를 어느정도 \"선언\"하여 검증할 수 있답니다.\n\nhttps://www.daleseo.com/jest-each/\n\n요런느낌?\n\n```tsx\ndescribe(\"areAnagrams()\", () => {\n  it.each([\n    [\"cat\", \"bike\", false],\n    [\"car\", \"arc\", true],\n    [\"cat\", \"dog\", false],\n    [\"cat\", \"act\", true],\n  ])(\"areAnagrams(%s, %s) returns %s\", (first, second, expected) => {\n    expect(areAnagrams(first, second)).toBe(expected);\n  });\n});\n```\n\n결국 \"선언형\" 이라는건 무언가를 추상화해서 사용하는거라고 생각해요.\n테스트의 동작을 추상화해서 \"선언\"하기만 해도 동작하도록 만드는거죠 ㅎㅎ\n그렇다면 테스트를 위한 함수를 많이 만들어놔야 하는데, 그렇게 할 필요가... 대체로 없는 편이죠.\n\n그리고 playwirhgt e2e 테스트를 보면 스냅샷을 검증하는 과정이 있는데, 렌더링된 모습을 특정 텍스트 포맷으로 정의하여 일치하는지 확인할 수 있어서 선언형에 가깝지 않나? 라는 생각이 들어요.\n\n대략 이런 모습이랄까...\n레퍼런스: https://playwright.dev/docs/aria-snapshots\n```tsx\nawait page.goto('https://playwright.dev/');\nawait expect(page.getByRole('banner')).toMatchAriaSnapshot(`\n  - banner:\n    - heading /Playwright enables reliable end-to-end/ [level=1]\n    - link \"Get started\"\n    - link \"Star microsoft/playwright on GitHub\"\n    - link /[\\\\d]+k\\\\+ stargazers on GitHub/\n`);\n```\n\n여튼 찾아보면 다양한 방식이 있답니다!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/19"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "은주님\n이번에는 시간이 별로 없었던 것 같습니다 .\n아쉽지만 다음에는 과제를 완수할 수 있길 기대할게요!!\n수고하셨습니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/22"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "안녕하세요 희정님! 과제가 진행되지 않았군요 ㅠㅠ\n4주차는 이제 테스트가 아니라 순수하게 javascript에 대한 내용을 다루기 때문에 조금 더 수월하게 진행할 수 있으리라 생각해요!\n남은 기간도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/46"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "고생하셨습니다~ 수범님!\n꼼꼼하게 회고 작성해주신거 보니까 저도 함께 과제를 하는 느낌이네요 ㅋㅋ\n과제에 대해서도 많이 고민하셨던 것 같아서 고생 많으셨다고 말씀드리고 싶습니다 ㅎㅎ 그 외에는 잘 작성해주셨습니다! 그럼에도 굳이 말씀드려보면 구성하셨던 e2e 테스트들에 대해서도 ci 환경을 구성해보셨다면 더 좋았을 것 같은데 아쉽네요 ㅠㅠ \n지금은 스토리북이나 별도 린트에러가 발생하고 있는데 이부분 잘 수정해보시면 좋겠구요! CI 환경에서 잘 검증되도록 하는게 테스트의 중요하고 큰 부분인것 같아요.\n말씀해주신것처럼 중요하다고 생각하셨던 부분 잘 정리해서 현업에서도 잘 적용해보시길 바랍니다. 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/3"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "안녕하세요 용태님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\nQ-1) Playwright MCP에 대한 코치님 생각이 궁금합니다!\n최근에 회사에서 Playwright MCP PoC를 진행하고, 이를 활용해서 시나리오/정책 문서 -> 프롬프트를 통한 E2E 테스트 자동화를 시도해보려고 하고 있습니다. 테스트 코드가 아닌, 자연어/프롬프트 관리를 통해 E2E 테스트를 운용하려고 합니다. 이에 대해서 어떻게 생각하시나요~?\n\n제 생각엔 신뢰도에 대한 보장만 된다면, Playwright MCP는 E2E를 운용/도입하는 제품에는 상당히 효율적인 도구라고 생각합니다. 하지만 제 생각보다 주목받는 느낌은 아니라서 코치님 생각이 궁금합니당.\n\nA-1)\n저는 충분히 활용 가능하다고 생각합니다! 다만 항상 Playwirhgt MCP 를 사용하기보단,\n검증이 완료된 부분에 대해 테스트 \"코드\"로 변환하고, 테스트가 실패하면 MCP를 이용하여 다시 변경사항에 대해 보완해주는 플로우를 설계하면 어떨까 싶어요.\n\n테스트 실패 -> AI를 통해 원인 분석 -> 테스트를 자동으로 추가해주거나 혹은 원인을 슬랙을 통해 알려줌\n\n이런 과정이랄까?\n\n\nQ-2) .stories.tsx 파일의 위치는 어떻게 가져가는게 좋을까요?\nDesign System을 따로 운용한다면, 메인 앱과 분리된 경로에 컴포넌트를 운용하기 때문에 .stories. 파일을 컴포넌트와 가까운 곳에 위치시키는 것이 자연스럽다고 느꼈었는데, 이번 프로젝트에 Storybook을 도입하면서 서비스 코드와 같은 경로에 그리고 컴포넌트 바로 옆에 .stories. 파일을 위치시키는 것이 어색하다는 느낌을 받았습니다. 그렇다고 다른 경로로 .stories. 파일을 분리시켜보니 이것도 어색하고 관리가 불편하겠다는 느낌을 받았습니다. 코치님의 생각이 궁금합니다!\n\n같은 폴더에 __stories__ 라는 폴더를 만들어서 관리해주면 어떨까요!?\n저희 팀에서는 테스트를 작성할 때에도 원본 코드가 위치하는 폴더에 __tests__ 를 만들어서 관리하고 있어요. 그래서 아예 __tests__ 폴더 내에 stories도 같이 위치시키거나 혹은 __stories__ 를 만들어서 사용하면 어떨까? 라고 생각하게 되네요 ㅎㅎ\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/33"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "수고했어요 지영! 지난 3주간 테스트를 경험하면서 대규모 프로젝트에서 품질을 어떻게 지켜내는지 간접적으로나마 체험하는 시간이 되었기를 바랍니다. 레거시 코드를 개선해야 하는 상황이라는 현실적인 전제 아래 테스트 전략을 수립한 점이 정말 좋았어요.\n\n\"있으면 좋은데 내가 하기엔 너무... 반복적이고 손이 많이 가는 일이 많아 보였고\", \"급한 ASAP과 테스트 사이에서 우선순위가 밀리는게 다시한번 눈에 보였고\"라는 솔직한 고백이 인상깊었습니다. 이게 바로 실무의 현실이거든요. 그럼에도 \"조금만 수정해도 사이드 이펙트가 발생하는 상태\"에서는 통합 테스트로 안전망을 먼저 확보해야 한다는 결론에 도달한 게 매우 실무적이었어요. 그리고 Husky를 활용해서 Git Action 제약을 우회한 것도 좋았고, E2E 테스트를 basic-flow, recurring-flow, exception-flow로 명확하게 구조화한 것도 훌륭했습니다.\n\nQ1) 테스트 데이터 관리 전략 - 날짜에 따라 화면이 변경되는 경우 데이터 처리를 어떻게 해야 하는지?\n=> 어쩔수 없죠. 테스트는 고립되고 일관되도록 만듭니다. 그래서 변하는 값에 대한 테스트가 아니라 날짜도 시간도 초기 데이터도 전부 고정을 한 상태로 테스트를 합니다. 오늘, 이번 달 같은 테스트도 안되고 날짜를 지정해야만 하죠. mock, 날짜 지정, 데이터 초기화등의 데이터를 고립하는 방법을 어떻게든 갖춰야 데이터 일관성과 테스트 독립성을 유지할 수 있습니다.\n\nQ2) 각 테스트마다 다른 데이터를 사용하는 것에 관하여\n=> Q1과 맞닿아있는 이야기이죠. 의미있는 초기값을 사용해서 해당 케이스를 대표할 수 있는 INPUT와 OUTPUT을 설정하고 테스트 전과 테스트 후가 항상 고정될 수 있도록 설정하는 것이 중요합니다. 지금까지 배웠던게 그 \"어떻게\"에 해당하는 것들이므로 앞으로는 실전에서 해보기로 해요!\n\nQ3) 테스트 관리 관련 - 실무에서는 테스트 데이터를 어떻게 관리하는지?\n=> 필요하다면 테스트용 DB를 따로 운영하기도 합니다. 초기에 DB의 구조를 만들어서 생성하고 끝나면 혹은 시작할때 다시 초기화 할 수 있죠. 상수가 많아지면 테스트의 신뢰성이 떨어질것 같다고 했는데 테스트는 QA와는 조금 다른 결입니다. 내가 수정하지 않은 곳에 대한 얘기치 못한 문제들을 빠르게 감지하는데 있죠. 내가 수정한 곳은 경우 코드 1개인데 그때마다 100개, 1000개가 넘는 곳을 사람이 확인해야 한다면 힘들테니까요. \n\n=> 테스트 코드가 관리되지 못해 본래의 코드의 패키지를 업데이트 하지 못하는 경우도 있고 되려 이미 만들어진 통합테스트를 함께 리팩토링을 해야하는 부담으로 리팩토링이 힘들어지는 경우도 있습니다. 하지만 구글과 같은 곳에서는 내가 수정된 PR이 merge되기 위해서는 테스트 코드를 작성해서 반드시 내가 작성한 코드가 유효함을 증명해야 하기에 수정하기 전에는 문제가 발생하는 RED 테스트를 작성하고 이후 커밋된 코드로 통과하는 GREEN을 입증해야만 merge를 시켜준다고 하더라구요. 테스트를 작성하는 비용 보다 유지관리 비용의 임계점을 넘어가게 되면 테스트 코드 유지 자체가 업무의 일환으로 포함이 되더라구요. (물론 저는 그렇게 까지 해본적은 없습니다.)\n\nQ4) 테스트 도입 방안 - 통합 테스트 → 리팩토링 + 단위 테스트 순서가 맞는지?\n=> 네 맞습니다. 레거시에서는 통합 테스트로 안전망을 먼저 확보하고, 리팩토링하면서 단위 테스트를 추가하는 게 현실적이에요. 단위 테스트부터 쓰려면 컴포넌트가 잘 분리되어 있어야 하는데, 레거시는 그게 안 되어 있는데다가 단위 테스트로 안심하고 커버할 수 있는 영역은 상당히 한정됩니다. 그리고 단위 테스트가 가능한 코드들은 리팩토링시 큰 문제를 일으키지 않기에 리팩토링을 한다면 e2e나 통합테스트 중 만들기 쉬운 것들을 택하면 좋습니다.\n\nQ5) 시각적 회귀 테스트 커버리지 - DayCell에 8개 Story가 적절한지?\n=> 8개는 사실 많은 편이에요. 실무에서는 컴포넌트당 3~5개 정도가 적당합니다. 기본 상태, 주요 상태 변화(hover, selected 등), 엣지 케이스(텍스트 길이, 오버플로우) 정도만 커버하면 충분해요. 지영님이 \"과도한지\" 고민한 게 정확한 감각인데, 너무 많으면 오히려 유지보수 비용이 올라갑니다. 중요한 건 \"이 Story가 깨지면 문제를 빠르게 발견할 수 있는가\"예요. 비슷한 상태의 Story들은 하나로 합치고, 정말 중요한 것들만 남기세요.\n\"초반에 구조를 잘 잡아야되겠다\"고 느낀 거, 정확합니다. 테스트는 도입이 어렵지 유지는 구조만 잘 잡으면 괜찮거든요. \n\n수고많았습니다. 이제 새로운 챕터에서 함께 해요!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/47"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "안녕하세요 창수님! 3주차 과제를... 다 진행하지 못하셨군요 ㅎㅎ ㅠㅠ 아쉽습니다.\n\n4주차 과제부터는 아예 다른 주제이기 때문에 충분히 잘 해낼 수 있으리라 생각해요!! 화이팅입니다!!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "형우님 수고하셨습니다.\n\nQ. 스토리북를 셋팅하는데 많은 어려움이 있었습니다. 또 커서,클로드 등등 같은 도구 등들을\n이번 항해를 하면서 알게 되었습니다. 프론트엔드 개발자가 알고 있어야 할 배경지식(?)\n같은 것을 쉽게 얻거나 볼 수 있는 사이트? 책? 같은 것들이 있을까요?\n\nA. 배경지식이라고하면 FE는 아니지만 기본적인 지식들 말씀이실까요? 네트워크 같은 것 말씀하시는 것인지 ㅎㅎ\n근데 그런건 스토리북 세팅하고 상관없는 문제 인것 같은데욥.\n스토리북을 세팅하시는데 어려움이 있었다면 그것을 다음부터는 쉽게 하고 싶다면 사실 무엇을 봐야하는지는 저도 잘 모르겠습니다 :)\n사실 항상 어려워요. 도구들은 각각의 설치법도 있고 또 한 번 설정했다고해서 끝나는 것이 아니라 매번 업데이트해줘야하고 피곤하죠ㅜㅜ\n그런데 이게요 이런 세팅을 자주하다보면 또 노하우가 생겨서 점점 쉽게 되요 ㅎㅎ 이런 것을 정리한 책은 없는 것 같고.\n그냥 자주해보시면 될 것 같습니다 :) 너무 조급해하지 마시고요!\n\n그냥 전반적인 FE소식은 저는 뉴스레터들을 통해 얻습니다~\n요즘 잘 못보고 있지만요 ㅎㅎ\n\nQ. 인터렉션 애니메이션 같은 거에도 테스트코드를 작성할 수 있나요? 있다면 이것도 작성하는게 효율적일까요\nA. 움직임 하나하나를 확인한다기보다는 시작과 끝정도를 확인하고 실제 동작은 그냥 눈으로 확인하는 것이 좋을 것 같아요.\n더 좋은건 애니메이션은 그냥 모두 CSS에 맡기고 테스트 코드에서는 애니메이션이 동작하게 CSS가 추가되었나 안추가되었나 확인하는 정도가 좋을 것 같습니다.\n아무튼 애니메이션은 결국 눈테스트다.. 입니다. :)\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/18"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "안녕하세요 희정님! 3주차 과제를 다 진행하기에는 시간이 많이 부족했엇나보군요 ㅠㅠ\n\n개인 과제는 진행해주셨는데 팀 과제에서 막힌걸보니 팀원과의 시간을 만들어내는게 힘들었던 것 같아요.\n\n4주차 과제는 잘 진행할 수 있기를 바랍니다!! 화이팅입니다!!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/51"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "승현님 고생하셨습니다!\n아쉽게 e2e 테스트가 정상적으로 통과하지 않네요 ㅠㅠ 스토리북은 잘 작성해주셨습니다.\n질문 주신 관점에서 조금 더 덧붙여 보면 playwright도 다른 테스트와 동일하게 유저 시나리오 관점에서 구현에 따라 수정이 될 수 있는 테스트가 아닌 명세 기반으로 잘 동작하도록 선택자를 선택하는게 중요하다고 생각해요.\n그리고 css나 DOM에 직접 접근하기 위한 선택자를 사용하게 될 수도 있는데 그런 경우보다는 test id를 사용하는게 더 나은 상황이 있을 수도 있습니다.\n이 부분은 오늘 리뷰 시간 때 자세히 설명 드린것 같아서 참고해보시면 좋을것 같아요 ㅎㅎ\n그리고 선택자는 종종 테스트에 wait을 걸거나 catch를 걸게 되면 발견할 수 있는 에러를 발견할 수 없기 되거나, 시간이 매우 늘어나게 되는 상황이 만들어 질 수 있어요. 정말 필요한 케이스들도 있어서 절대 사용하지 마세요! 라고는 말씀은 못드리겠지만, 이걸 절대 남발해서는 안됩니당.\n\n고생하셨고 다음 주차도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/9"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "안녕하세요 수빈님! 3주차 과제를 다 진행하기에는 시간이 많이 부족했었나보군요 ㅠㅠ 아쉽습니다.\n\n4주차부터는 주제가 달라지니 잘 진행할 수 있기를 바랍니다! 화이팅!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "수고했어요! 지난 3주간 테스트 챕터를 진행하면서 E2E와 시각적 회귀 테스트를 직접 구축해보느라 고생 많았습니다. 특히나 이번 과제를 통해 \"들어만 봤던\" 것들을 \"실제로 해봤다\"로 전환한 점이 정말 큰 성과라고 생각해요.\n\n통합테스트와 E2E의 차이를 몸으로 체감한 부분이 인상 깊네요. \"...테스트 코드도 거의 비슷할 것이라 생각했는데 비슷한 듯 하면서 생각보다 다른 부분들이 많아서\"라고 말한것 처럼 실제로 해보기 전까지는 막연하게 생각하기 쉬운데 그런 차이를 직접 충분히 느낀것 같아서 커리큘럼과 과제의 목적을 잘 달성한것 같아요.\n\n\"시각적 회귀 테스트라는 이름이 생소한 만큼, 테스트를 구성하기 어려울 것 같다는 선입견\"을 깨고 \"투자 대비 이점이 많겠다\"고 느낀 거, 정말 중요한 깨달음이에요. 테스트가 어려운 것 그리고 React를 벗어나지 못하는건 그 생소함이 정말 크거든요. 막상하면 별거 아니지만 당장 할 필요는 없다 생각하니 하지 못하는 것들을 해보니 뭐 이런 느낌이구나 알게 되서 좋습니다.\n\n**Q1) E2E에서 헬퍼 함수를 적극적으로 만들어 사용하는 것이 더 좋을까요?**\n\n=> E2E는 시나리오가 길어질수록 가독성이 떨어지기 쉬워서 헬퍼 함수나 Page Object 패턴을 만들기도 하죠. 하지만 테스트 코드는 오히려 추상화가 독이 되는 경우가 있습니다. 최대한 테스트 코드 그대로 읽힐 수 있도록 하는 편이 작성하는 사람도 수정하는 사람도 편해져요. 헬퍼함수를 변경하게 되면 영향력이 커지게 되는데 테스트 함수는 가급적 테스트별로 고립되고 독립성을 유지할 수 있으면 좋으니까요. 그렇다고 꼭 쓰지 말라는 건 아니고 직관성에 방해되지 않는 선이라면 어느정도의 헬퍼 함수는 괜찮습니다.\n\n**Q2) waitForTimeout 말고 더 정확한 타이밍 측정 방법이 있을까요?**\n\n=> playwright에는 시간이 아닌 여러가지 조건을 바탕으로 측정도 가능합니다. 특정한 엘리먼트가 보일때 까지나 원하는 글자가 나올때 혹은 네트워크의 상태의 변경도 기다릴 수 있죠. 시간이 아니라 조건을 바탕으로 하면 그 조건이 충족될때까지 기다릴수 있게 되어 정말 의도한 바가 시간이 아니라면 상태 변경을 조건으로 기다리는 방법을 한번 찾아서 시도해보세요.\n\n**Q3) E2E 커버리지 목표와 실무 활용 방식이 궁금합니다.**\n\n=> 서비스들은 생명주기가 있습니다. 런칭하기전 초창기에는 버그보다 기능 구현이 더 중요한 가치를 가집니다. 뭔가를 새로 만들고 수정하는 게 큰 가치를 가지기에 기회비용이 테스트에 쓰이기가 어렵죠. e2e 생성과 제작 그리고 관리가 다 비용이니까요. e2e가 가치가 있으려면 테스트를 제작하는 비용보다 실제 얻는 효용이 커야할테니까요.\n\n=> 그러다보니 이게 필요해진 시점은 충분히 프로젝트가 수익성이 있고 수정시 발생하는 회귀테스트 비용이 높아지는 경우라 풀 커버리지보다는 핵심 사용자 플로우만 커버하면서 수정시 회귀 테스트를 보장하는 안전장치 용도로 쓰입니다. 최소한 이거는 안되면 장애상황이다들을 체크하는 거죠.\n\n=> 어쩌다 사석에서 구글 개발자를 만난적이 있는데 구글 검색과 같이 아주 오래된 레거시는 PR을 올릴때 테스트 코드가 없으면 아예 받아주지를 않는다고 하더라구요. 그런데는 이슈 수정보다 문제가 생기지 않는게 더 크니까 코드 수정을 1-2줄을 해도 그에 합당한 테스트 코드를 더 많이 작성한다고 하네요. 그렇다고 우리 실무에서 그럴 필요는 없겠죠? 언제나 지금의 최선에 맞게 하는 것일테니까요. \n\n=> 제가 하고 있는 지금 프로젝트는 e2e에서 동작 테스트는 없고 특정 페이지 접속시 필수적으로 렌더링되어야 하는 컨텐츠 노출 여부만 체크하고 있습니다. 수정 변경을 하는 테스트는 안하고 있어요. 그래도 페이지가 100여개라 그래도 이게 있어서 장애 감지 면에서 큰 도움이 됩니다. 서버 API 변경이나 글로벌 영향을 미치는 문제들의 안전장치가 되어 주거든요.\n\n3주간 테스트 하느라 수고 많았습니다. 이제 새로운 챕터에서 만나요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안재현",
    "feedback": "안녕하세요 재현님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 코치님은 테스트 코드를 손으로 다 작성해야 한다 vs 테스트 코드 작성은 AI에게 맡긴다 + 결과물 확인을 사람이 에 대해 어떻게 생각하시는 지 궁금합니다 !!\n\n저는 테스트를 작성하는 방법만 알고 있다면 AI에게 위임하는게 제일 효과적이라고 생각해요 ㅎㅎ 테스트가 특히 반복적인 작업이 많다보니 \"좋은 테스트\"에 집중하기가 생각보다 어려웠어요.\n\n그래서 반복적인 부분은 AI게 위임하고, 작성된 코드를 한 번 정제하는 방식으로 진행하면 어떨까 싶습니다!\n\n적절하게 역할 분리를 하는거죠 ㅋㅋ\n\n> 과제 수행을 위한 방법을 찾고 있던 저와는 달리, 과제 시작 전 프로젝트 전체 구조를 파악하고 설계해나가는 팀원분들의 모습을 보면서 많이 배울 수 있었습니다. 과제 마무리에 급급하여 코치님께서 의도한 학습 목표에 부합하지 못하는 모습을 보이는 것 같은데, 마무리 보다는 배움에 초점을 맞춰 마음의 여유를 가지고 과제를 할 수 있도록 노력해야겠습니다...\n\n사실 이건 성향에 가까운 것 같아요 ㅎㅎ\n처음부터 큰 그림을 보는게 어려울 수 있달까... 제가 그런 사람이거든요.\n무조건 다 파악하고 시작하기보단, 시작하면서 점진적으로 파악하는거죠.\n\n그래서 나에게 맞는 방법을 찾으면 된다고 생각해요!\n\n---\n\nQ1) 통합 테스트와 E2E 테스트 구분\n통합 테스트와 E2E 테스트의 목적이 큰 틀에서는 비슷하다고 생각했습니다.\n\n- 통합 테스트 : 핵심 비지니스 기능에 대한 코드 로직 검증\n- E2E 테스트 : 핵심 비지니스 기능에 대한 사용자 관점 시나리오 검증\n\n핵심 비지니스 기능에 대해서 통합 테스트와 E2E 테스트를 모두 작성한다면 중복 검증이 되어 비효율적일까요? 아니면\n\n- 통합 테스트 : 로직 검증\n- E2E : 시나리오 검증\n\n와 같이 검증 포인트를 다르게 두고 접근한다면 더 신뢰성 높은 테스트를 진행할 수 있는 것일까요?\n\nA1)\n이건 선택의 문제라고 생각해요 ㅎㅎ 뭐가 맞다라기보단...?\n통합 테스트의 경우 실행속도가 빠르기 때문에 모든 단계의 ci에서 실행해도 무방한데\ne2e 테스트의 경우 지금은 작은 프로젝트라서 실행 시간이 오래 걸리지 않지만, 실제 프로젝트에서 e2e를 실행한다고 치면 굉장히 오래걸릴 수 있답니다.\n그래서 e2e는 배포 직전 처럼 특정 시점에 실행하여 문제를 발견하도록 할 수 있어요.\n\n즉, 피드백 타이밍이 다르다는거죠.\n대신 테스트 작성 난이도는 통합 테스트가 더 높아요.\n\n시간적 여유가 있다면 e2e와 통합테스트 모두 작성하면 당연히 좋겠지만..!? 그게 어렵다면 무언가 하나는 포기해야겠죠 ㅎㅎ\n\n저는 특히 이게 프로젝트의 성격에 따라 갈라진다고 생각하는데, 가령 제가 이전 회사에서 만들었던 \"웹 포털 서비스\"의 경우 통합서비스가 큰 의미가 없어요. 대신 e2e를 통해 한 번에 검증하는게 제일 효과적이었죠. 단위테스트도 큰 의미가 없었어요.\n\n사용자의 인터랙션을 기반으로 진행되는 서비스가 아니라, 거의 단뱡항으로 데이터를 공급하여 보여주는 방식이기 때문이죠.\n\n그런데 쇼핑몰 같은 프로젝트에서는 통합테스트가 유의미할 수 있고\n지금 저희 팀에서 만들어가는 노코드 빌더의 경우 통합테스트나 e2e를 작성하는 난이도가 너무 높아서 단위 테스트를 통해 단계별 검증을 하는게 제일 효과적입니다.\n\n그래서 어떤 프로젝트의 어떤 기능을 검증하냐에 따라 다르다고 생각해요!\n\n---\n\nQ2) 스토리북에서 스토리를 나누는 기준\n저는 props 상태 or 입력 상태 등에 따른 UI가 변경 되는 경우 를 기준으로 잡고 스토리를 나누었는데, 스토리를 나눈 기준이 적합한 지 궁금합니다 :)\n\n추가로 코치님께서 스토리북을 작성하실 땐 어떤 기준을 가지고 작성하시는지 노하우를 얻고 싶습니다 !!\n\nA2)\n재현님의 기준을 토대로 진행해도 충분하다고 생각해요 ㅎㅎ\n그리고 제가 위에 답변드린 것과 동일하게, 스토리도 프로젝트 성격에 따라 달라질 수 있다고 생각합니다.\n저는 \"테스트하기 제일 적합한 스토리\"를 분리해서 진행할 것 같아요.\n가령, 저희 팀에서 진행하는 웹빌더 프로젝트의 경우\n편집 창으로 진입하기 위해선\n\n- 로그인을 해야하고\n- 사이트를 만들고 템플릿을 선택하고\n\n이런 단계가 필요합니다.\n그런데 편집 기능 자체에 대해서만 잘 동작하는지 테스트하고 싶다면, 앞의 단계가 다 필요없기 때문에 \"편집 페이지\" 에서 권한과 관련된 코드만 밖에서 주입해주도록 하고 나머지는 스토리로 작성하면 검증하기가 훨씬 쉽겠죠!?\n\n그래서 무언가 절대적인 기준을 정하기보단, 내가 프로젝트를 진행하면서 어떤 어려움을 스토리를 작성하여 해소할 수 있을지 고민하다보면 쉽게 결정할 수 있다고 생각해요 ㅎㅎ\n\n꼭 모든 스토리를 작성할 필요도 없으니까요!\n\n아 그리고 크로마틱을 이용하면 자연스럽게 시각적 회귀 테스트가 가능하기 때문에, 변경이 잦은 부분도 스토리북을 통해 보여줄 수 있으면 좋을 것 같아요.\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "수고했어요 진성. 지난 3주간 테스트 챕터를 하면서 추후 대형 소프트웨어에서 품질을 어떻게 지켜내야하는지 직간접적으로 체험하는 시간이 되었기를 바랍니다. 테스트를 만들기 위한 품이 많이 든다는 것. 그렇지만 이러한 테스트를 하지 않는데 더 큰 비용이 되는 순간이 온다는 것. 그리고 언젠가 커리상 이러한 대형 프로젝트를 맡아야 할 때 \"테스트 작성할 줄 아나요?\" 라고 했을때 생소하지 않고 할 수 있다는 자신감을 가질 수 있는 시간이 되었기를 바랍니다.\n\nQ. 현재 useDnd, WeekView, MonthView 컴포넌트는 따로 테스트 코드를 작성하지 않았습니다. useDnd에 사용하는 **~[@dnd-kit](https://github.com/dnd-kit)~**은 외부라이브러리로 테스트를 위임하였고 동작하는 기능들은 E2E로 이미 검증된다고 판단하여 테스트를 추가하지 않았습니다. WeekView와 MonthView는 Props를 받아 렌더링만 수행하는 컴포넌트로 비즈니스 로직이 거의없다고 판단하였으며 이미 medium.integration.spec.tsx 파일에서 커버된다고 생각했습니다. 혹시 위 세가지 테스트하지 않은 항목중에 테스트를 했어야 하는 항목들이 있는지 코치님의 의견이 궁금합니다.\n\n=> 좋은 판단이라고 생각합니다. WeekView와 MonthView등에서 렌더링만 수행하는거라면 각각의 세부적인 컴포넌트를 체크할 필요는 없고 e2e에서 특정 데이터가 제대로 노출되는가 정도로도 충분하겠죠. 테스트는 한번에 완성이 아니라 하면서 쌓아가지는 거니 지금 상황에서는 올바른 판단을 했다 생각합니다.\n\nQ. playwright, cypress 등 e2e를 테스트할 때 로컬에서 병렬로 테스트가 가능하지만 CI 환경에서는 병렬 테스트의 한계가 있는 걸로 알 고 있습니다. 혹시 코치님께선 CI 환경에서도 병렬 테스트를 위해 따로 설정하신 적이 있으실까요?\n=> 저는 그런 경험이 없어서 뭐라 답변 해줄 내용이 없네요 ㅠ\n\nQ. DnD와 웹 접근성에 대한 고민 드래그 앤 드롭(DnD) 기능을 구현하면서, 시각적 인터랙션 외에도 웹 접근성(Accessibility) 측면에서의 고려가 필요함을 느꼈습니다. 키보드 입력으로도 dnd를 이동해보고싶어 tab으로 cell을 선택하여 space로 dnd keyboardUp까진 진행하였는데 이동과 keyboardDown은 방법을 몰라 테스트하지 못하였습니다 혹시 코치님께선 웹 접근성관련하여 테스트하실때도 e2e툴인 playwright나 cypress를 활용하여 테스트 하시나요?\n \n=> 간단한 키보드 동작이라면 테스트하는 경우도 있지만 접근성이 이미 검증이 된 라이브러리들를 다 접근성 형태로 테스트는 하고 있지 않고 있어요. 필요하게 되면 해야겠죠? 제 경험을 물으신다면 저는 테스트를 깊게 다루지는 않아서 이 정도 까지랍니다.\n\n지난 3주간 테스트 하느라 수고많았습니다. 이제는 React네요! 다음 시간도 화이팅입니다!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/2"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "새듬님 고생하셨습니다~\n필요한 e2e 테스트는 잘 작성해주셨는데, 스토리북에 누락된 스토리나 깨지는 부분이 있는 것 같아요 ㅠㅠ 이 부분 꼭 확인해주시면 좋을것 같고 추가로 TC 작성이 없으셔서 기본 과제는 통과로 하고 심화는 불통으로 처리했습니다.\n\n> e2e 테스트가 간헐적으로 통과됏다가 timeout에러가 뜨면서 실패합니다. 한참 헤매다가 병렬로 테스트가 실행되는 것이 문제였다는 것을 깨달아서\n직렬로 테스트가 수행되게끔 수정을 했습니다. 근데 직렬로 수행하니 그만큼 시간이 엄청 소요가 되던데 만약 병렬로 테스트를 진행하기 위해 워커를 늘린다면\n몇개 까지 늘리는 게 적당한지, 그리고 병렬로 테스트를 진행하려면 작성된 e2e테스트를 어떻게 수정해야되는지(병렬일 때 발생하는 timeout에러 해결방안)궁금합니다.(테스트를 수정해야되는지 아니면 서버 설정을 수정해야되는지) 가능하시다면 예시를 들어서 설명해주셨으면 합니다...! 그리고 실무에서도 웬만해서는 병렬을 선택하나요?\n\n시간 관점에서는 가능한 병렬로 많이 테스트를 구동하는게 도움이 많이 되겠죠!? 구동되는 장비나 환경에도 영향을 받을거고, 테스트를 어떻게 구성했는지에 따라서도 영향을 받을 것 같아서 테스트를 해가면서 수행해야 할것 같아요. 예를 들어서 구동되는 환경에서 워커가 3개까지 구동이 가능한데, 상호간에 영향이 없는 TC로만 구성이 되어있다면 3개로 운영하는게 좋겠죠! 하지만, 영향이 있다면 1개로 구성하거나 병렬로 구성하는 방법에 대해서 고민을 해야할것 같아요. 이 부분은 제가 리뷰 세션에 설명 드렸으니 참고해보시면 좋을것 같아요!\n\n고생하셨고 다음 주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/24"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "태준님 아쉽게 과제 마무리 못해주셨네요 ㅠㅠ\n바쁘신일이 있으셨겠죠 ㅎㅎㅎ\n마지막 테스트 과제였는데 추후에 시간이 꼭 있으실때 해보시면 좋을것 같고 모르는거나 질문거리 생기시면 편하게 알려주세요. 그럼 다음주도 화이팅입니당",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/37"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "안녕하세요 지훈님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 일단 끝냈음에 스스로에게 너무 감사하다... AI에 지쳐 일-월을 그냥 허송세월 보내버린 탓에 화,수,목 의 시간밖에 없어 4일돈안 8시간밖에 못 잔 것 같지만.. 그래도 이렇게 결과물을 내고 피드백을 받게 되어 뿌듯하다.\n\n직장 생활이랑 학습을 병행하는게 쉬운 일은 아니죠 ㅠㅠ 너무 고생하셨어요!! 저라면 아마 못했을 것 같아요 ㅋㅋㅋ\n\n> 준일 코치님께서 \"프론트엔드가 전문적으로 필요해진 시점은 스마트폰이 공급된 시점과 유사하다.\"라는 말씀과 함께 \"다양한 화면에 대한 효율적인 개발을 위해\" 지금의 수요가 완성됐을 것이라 하셨다. 이 말을 듣기 전까진, 단위테스트로 기능을 검증하고 이를 통합한 시나리오를 통테에서 검증한다면 UI에 대한 검증을 많이 가져가도 될까?를 생각했다. 확실히, csr이든 ssr이든 프론트엔드도 개발 과정에서 데이터의 변화에 집중하며 화면 개발을 하는게 중요하다 생각했던 나에게 UI적인 검증에 필요성을 일깨워준 것 같다.\n\n오.. 저는 반대로 생각하는 편인데요,\n프론트엔드 개발자는 \"데이터\"를 \"UI\"로 변환하는 임무를 수행한다고 생각해요.\n그렇기 때문에 UI에 대한 검증보단 사용자의 인터랙션을 토대로 데이터가 어떤식으로 변화하는지 검증할 수 있다면 UI에 대한 변화도 100% 까진 아니여도 어느정도는 검증할 수 있지 않을까!? 라고 생각하는 편입니다 ㅎㅎ\n\n그래서 컴포넌트 내부의 비즈니스 로직을 전부 훅으로 분리한 다음에 훅에 대해 검증하여 데이터의 변화를 추적하면 어느정도 UI에 변화도 예측할 수 있게 되는거죠.\n\n대신 훅에서 만들어놓은 함수나 이벤트 핸들러와 UI를 적절하게 잘 매칭하는 과정이 필요하겠죠!?\n\n> ./playwright/test/notification-workflow.spec.ts 중 '알림 시간에 도래하면 알림 문구 노출' 테스트 케이스 뿐 아니라, e2e테스트와 시각적 회귀 테스트를 진행하면서, 1,2주차 통합테스트에서 검증했던 내용들과 많이 겹침을 느꼈습니다. 과제 명세가 해당 항목들에 대한 CRUD를 구현하는 것이니 테스트 내용이 겹침에도 작성은 하였지만, 과연 통테/단테에서 진행 및 검수된 내용을 또 다시 검사하는 게 과연 효율적일까? 가 궁금합니다.\n\n이건 선택의 문제라고 생각해요 ㅎㅎ 물론 중복 검사를 제거하는게 제일 중요하지만, 오히려 이걸 신경쓰다보면 테스트 작성 시간이 오래걸릴 때도 있고, 본질에서 멀어질 때가 있어서요.\n\n중복 검사를 하지 않는 방향이 이상적이긴 하지만, 결국 우리가 테스트를 통해서 검증하고자 하는 것이 무엇이냐에 따라 달라진다고 생각해요.\n\n테스트도 하나의 수단일뿐이니까요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/50"
    }
  },
  {
    "passed": true,
    "name": "이예인",
    "feedback": "아쉽네요. 이번 주차 과제를 완료하지 못했지만, 실무에서 테스트의 필요성을 절실히 느꼈던 경험들을 솔직하게 나눠준 점은 좋았어요. \"잘 작성된 테스트는 곧 명세다\"라는 깨달음이나, 중간에 합류해서 문서 없이 명세를 파악하느라 고생했던 이야기는 많은 개발자들이 공감할 수 있는 부분입니다.\n\n이번 과제의 핵심은 전략 수립뿐만 아니라 실제로 E2E와 시각적 회귀 테스트를 구현해보는 경험이었는데, 그 부분을 진행하지 못한 점이 아쉽네요. 수학문제를 학습한것과 실제 푸는게 다르듯이 테스트도 직접 작성하면서 부딪히는 문제들에서 느끼는게 있거든요. Playwright로 비동기를 다루거나, Storybook으로 다양한 상태를 만들어보는 과정에서 얻는 구체적인 감각들이 있어요.\n\n하지만 실무에서 2.0 버전 개편을 맡고 계신다니, 그때 이번에 배운 내용들을 실제로 적용해볼 수 있는 좋은 기회가 되 거라 기대합니다. 아주 좋은 기회이고 실제로 워킹 하지 않아도 좋으니 꼭 한번 찍먹이라도 실무에서 해볼 수 있게 되길 바래요!\n\n3주간 테스트 하느라 수고 많았습니다. 이제 새로운 챕터에서 만나요!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "수고하셨습니다. 윤지님!\n\nQ. Chromatic ProjectToken 보안 처리\n\nA. 사실 이번에는 리포관계상 문제가 있었던 것이고 사실은 배포환경에서 시크릿키를 사용할 수 있도록 하는 것이 옳겠죠 예를들면 리포가 공개된 프로젝트라면 말입니다.\n그런데 실무에서는 리포가 외부에 공개될 이유가 없기 때문에 키를 담는 방법을 외부에 노출될까 걱정할 필요가 없을 것 같아요.\n그냥 키를 효율 적으로 관리하는 방법만 고민하면 될 것 같습니다~ \n제가 크로마틱을 실무에 써본적이 없어서 제대로 답변이 되었는지 모르겠네요. 동문서답이면 말씀해주세요. 제가 오프코치한테 물어봐서 알려드릴게요~",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/10"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "수고했어요 정민! 지난 3주간 테스트를 경험하면서 아주 생소하지만 대규모 프로젝트의 안정성과 AI 시대의 AI를 컨트롤할 수 있는 고삐가 되어버린 테스트 코드에 대한 이해도가 높아지는 시간이 되었으리라 생각합니다.\n\n회고 과정에서 팀원의 Dnd Kit 버그를 듣고 HTML DnD API와의 상태 관리 차이까지 분석한 부분이 멋지네요. HTML DnD는 단순 DOM 이벤트 기반이라 우리가 상태를 직접 관리하며 즉각 반응하지만, Dnd Kit은 라이브러리가 요소를 관리하기에 상태 동기화 지연이 발생할 수 있다는 차이를 잘 발견해서 깊이있게 고민해본 부분 아주 좋습니다.\n\n페어 프로그래밍을 통해서 그리고 팀원들의 토론을 통해서 듣는 것만으로도 성장이 된다는 것을 경험한 부분도 아주 좋네요. 어느 순간 내가 학습하고 있는 틀에 갇혀버리게 되는데 그렇게 다른 사람의 이야기를 듣고 시야가 넓어지고 다채로운 생각을 할 수 있다는 것을 알았으니 앞으로 다른 곳에서도 크게 도움이 될 거에요\n\nQ) 실제 현업에서도 이렇게 테스트를 직렬로 처리하면서, 각 테스트 시작 전에 데이터를 초기화한 뒤 실행하는 방식을 사용하는 경우가 있는지 궁금합니다!\n\n=> 네, 물론 제가 경험하고 있는 테스트는 그렇게 크지 않아서 (거의 과제와 비슷한 수준) 일반적인 방법론에서 크게 벗어나지도 않을 뿐더러 그 이상을 경험해본 적이 없어서 사실 잘 모릅니다. 저도 학습하면서 필요하면 그때 그때 추가 하고 있네요. 자세히 알려드리지 못해 부끄럽지만 나도 알고 있으니 필요하면 할 수 있다는 생각이 들면 좋겠습니다\n\n수고많았습니다. 이제 새로운 챕터에서 함께 해요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/26"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "안녕하세요 현지님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 이제는 테스트가 예전만큼 무섭지 않아여~ 병아리에서 테린이로 진화.\n\nㅋㅋㅋ 테스트와 친해지셨군요!! 다행입니다. 실무를 진행할 때에도 두려워하지 말고 테스트를 적용해보시면 좋을 것 같아요!\n\n> 다양한 기술을 접할 수 있어서 좋았습니다 (그 덕에 새벽잠을 많이 잤긴 했어요,,ㅎㅎ)\n\n항해를 수료하면.. 폭싹 늙는 불문률이 있답니다.. 허허\n\n> 10월 1일 Week뷰로 변경했을때, holidays가 나오지 않는 버그가 있는거 같습니다!! (개천절 안나와요!!)\n\n이건 아마.. 수동으로 지정해줘야 할꺼에요 ㅋㅋ\n\n---\n\n별도의 리뷰 요청은 해주지 않으셔서 피드백은 여기서 마무리하겠습니다!! 고생하셨습니다 현지님!\n\n\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/36"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "안녕하세요 이진님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 반복되는 테스트 로직을 클래스(E2EHelpers.ts)로 묶어 재사용하는 접근 방식 자체가 괜찮은지 궁금합니다. 페이지 객체 모델(Page Object Model)과 유사하게, 공통 액션을 추상화하여 테스트 코드의 가독성과 유지보수성을 높이려고 의도했습니다. 이러한 헬퍼 클래스 설계가 일반적인 E2E 테스트 패턴에 부합하는지, 혹은 더 나은 대안이 있는지 1차적으로 검토받고 싶습니다.\n\nE2EHelpers 클래스를 사용한건 무척 좋은 시도였다고 생각해요! 오프 코치님께서 올려주신 솔루션도 헬퍼를 만들어서 사용하고 있답니다 ㅎㅎ \n\n여기서 조금 더 나아가보자면... 사실 정답은 아니고 그냥 제안이라서 참고만 해주세요.\n\n1. Page Object 패턴 완전 분리: 현재는 하나의 헬퍼 클래스에 모든 기능이 있는데, 페이지별로 분리하면 더 좋습니다\n- CalendarPage.ts\n- EventFormPage.ts  \n- SearchPage.ts\n\n2. 선택자 상수화: 선택자를 별도 상수로 관리하면 더 유지보수가 쉽습니다\n```tsx\nconst SELECTORS = {\n\tTITLE_INPUT: 'text=제목',\n\tDATE_INPUT: 'input[type=\"date\"]',\n\t// ...\n};\n```\n\n3. 커스텀 대기 로직: waitForTimeout 대신 조건 기반 대기를 더 활용하면 테스트가 안정적이고 빨라집니다.\n\n4. 에러 처리: 실패 시 더 명확한 에러 메시지를 제공하도록 개선 가능합니다.\n\n\n> 만약 이 접근 방식이 유효하다면, 현재 구조의 확장성에 대한 피드백을 받고 싶습니다. 지금은 괜찮지만, 앞으로 테스트 케이스가 늘어나면 이 단일 클래스가 너무 비대해질 것 같습니다. 기능(e.g., 인증, 이벤트 생성, 뷰 전환)에 따라 이 클래스를 어떻게 분리하고 모듈화하는 것이 장기적인 유지보수 관점에서 가장 효율적일지 리뷰받고 싶습니다.\n\n앞에서 작성한 내용과 유사하네요!\n어떻게 라기보단... 필요할 때 분리하면 되지 않을까요? 너무 어렵게 생각할 필요는 없을 것 같아요 ㅎㅎ\n필요하다 싶을 때 분리하는 정도만 해도 테스트 코드를 관리하는 수준에서는 충분히 효과적이라고 생각합니다!\n\n테스트는 최대한 AI에게 위임하고, 구조적인 부분이나 반복적으로 쓰이는 구간만 잘 검토하면 유지보수하는데 큰 어려움은 없을 것 같아요.",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/35"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "수고했어요 희재! 지난 3주간 테스트를 경험하면서 대규모 프로젝트에서 품질을 어떻게 지켜내는지 직간접적으로 체험하는 시간이 되었기를 바랍니다. 테스트를 만드는데 들어가는 품이 엄청나지만 이를 감안하고도 도입하려는 걸 보면 테스트가 없었을 때가 얼마나 고통스러울지 짐작할 수 있죠. 언젠가 커리어상 대형 프로젝트를 맡게 될 때 \"테스트 작성할 줄 아나요?\"라고 물어봤을 때 생소하지 않고 할 수 있다는 자신감을 가질 수 있는 예방 주사가 되어주었길 바래요.\n\n이번 과제에서 \"무엇을 테스트해야 하는가\"에 집중한 점이 정말 좋았어요. 테스트의 본질인 \"사용자 경험 검증\"과 \"비용 대비 효과\"를 고민하면서 e2e에서 핵심 동작을 찾아 집중해서 작성하고 세부 분기는 단위/통합 테스트로 커버한다는 전략은 아주 현실적인 접근입니다. \n\nQ) ... 일반적으로 개발자들이 협업 시 어떤 기준으로 커밋 단위를 나누는지 잘 모르겠습니다.\n협업이나 리뷰 관점에서 가독성이 높고 관리하기 좋은 커밋 단위를 어떻게 설정하는 게 좋을지, 그리고 커밋 메시지를 어떤 식으로 정리하면 명확하게 의도를 전달할 수 있을지에 대해 조언을 받고 싶습니다.\n\n=> 실제로 커밋에 대해서는 대단히 빡센 커밋 컨벤션등이 없는 경우가 더 많습니다. 대개 브랜치나 PR단위가 조금 더 중요하구요. 다만 커밋의 경우 되돌아갈 수 있다는 점에서 하나의 커밋단위가 온전한 하나의 변경단위여야 하지 섞여있지 않는 편이 좋습니다. 이렇게 생각해보면 어떨까요? 어디든 커밋을 돌려도 온전할거라는 거요. 이 커밋에서는 뭔가 하다가 만게 있다거나 여러 수정이 섞여있지 않다는 거죠.\n\n=> 지금 등록해준 커밋은 충분히 좋습니다... 라고 봤더니 클로드가 써준게 많군요. ^^; 무작정 맡겨보기 전에 한번 혹은 클로드에게 위임하기 전에 한번 물어보는 건 어떨까요? 커밋전에 먼저 커밋 메시지만 써달라고 해보세요. 그리고 파일들을 보면서 메시지들이 하나의 목적이 있는지 아니면 독립적으로 분리해도 되는 것들이 있는지 보면서 섞이지 않도록 해보세요!\n\n테스트 챕터 동안 수고 많았어요. 다음 React 챕터에서 만나요!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/30"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "수고했어요 나리! 지난 3주간 테스트 챕터를 진행하면서 \"어떤 테스트를 어디에 써야 하는가\"를 깊이 고민한 흔적이 보여요. 특히 이번 과제를 통해 E2E 테스트에 대한 인식이 완전히 바뀐 것 같아서 정말 좋네요.\n\n\"이번 과제를 통해 가장 크게 성장한 부분은 E2E 테스트 도입에 대한 자신감이었습니다.\" 이라고 느낀 변화가 큰 성과라 생각합니다. 대부분 개발자들이 E2E를 막연히 어렵다고만 생각하고 시도조차 못하고 있었죠. 이번 기회에 Playwright와 같은 도구들을 직접 써보면서 그렇게 어렵지 않구나. 실용적이구나 하고 깨달음을 얻었다는게 중요합니다.\n\n이런 경험이 있어야 나중에 실무에서 \"우리 팀에 E2E 테스트 도입해봅시다\"라고 자신있게 제안할 수 도 있고 \"e2e 할 줄 알아요?\" 라고 물어봐도 \"할 줄은 안다. 해봤다\" 라고 얘기할 수 있게 될거에요. 특히나 깊이 있게 알지 못해도 이제 막 해야 하는 상황이라면 지금 수준 이상의 것들이 아니니 충분히 자신감을 가져도 좋아요\n\nQ1) StoryBook 시각적 회귀 테스트 단위 - EventItem 내부 title이 길어졌을 경우 ellipsis 요구사항을 CalendarView, EventItem, Cell 중 어느 단위에서 테스트하는 것이 효율적인지?\n=> EventItem 단위에서 테스트하는 게 가장 효율적입니다. ellipsis는 EventItem의 책임이기 때문이죠. CalendarView는 너무 범위가 넓어서 노이즈가 많고, Cell은 EventItem을 포함하는 컨테이너라 역할이 다릅니다. 시각적 회귀 테스트는 \"변경의 영향 범위\"와 \"책임 소재\"를 기준으로 단위를 정하세요. EventItem에서 title prop에 긴 문자열을 넣은 스토리를 만들고 그 스냅샷을 관리하면, 나중에 EventItem의 스타일이 변경될 때만 해당 스냅샷이 깨지니 유지보수가 쉽습니다.\n\nQ2) 실무에서 실제 DB를 기준으로 E2E 테스트를 작성하게 되면 어떻게 관리하는지?\n=> 테스트 전용 DB 환경을 별도로 구축합니다(dev, staging, prod처럼 test 환경). 그리고 수정과 삭제시 테스트 일관성 유지를 위해 트랜잭션 롤백을 추가합니다. 시작할 때 강제로 초기화를 시킬 수 있는 방안이 있어야 동일 테스트에 동일한 결과를 줄 테니까요. 여차하면 쓰기는 포기하고 읽기전용만 e2e를 하는 경우도 있습니다. 안되면 지금처럼 mocking을 하거나 e2e.json등으로 활용하겠죠. 핵심은 어떤 방식으로는 \"테스트 실행 후 상태가 변하지 않는 환경\"을 만드는 게 핵심입니다.\n\nQ3) E2E 최소화 전략 - 핵심 케이스만 E2E로 작성하고 엣지 케이스는 통합 테스트로 보강하는 게 좋은지?\n=> 맞아요. E2E는 \"핵심 사용자 플로우\"만 검증하고, 엣지 케이스는 통합/단위 테스트로 커버하는 게 맞아요. E2E는 실행 비용이 높고 디버깅이 어려우니 이거 안되면 장애! 이런 필수 시나리오를 중심으로 검증합니다. 복잡한 로직에 대한 검증은 통합 테스트로 검증하구요.\n\nQ4) UI가 잘 변경되지 않는 제품의 경우 시각적 회귀 테스트를 만들어두면 의도하지 않은 UI 변경을 잘 발견할 수 있지 않을까?\n=> 실무의 아이러니인것 같아요 ㅠ 비용을 고려하다보니 잘 안변하는데 왜 해? 했다가 한번쯤은 그걸로 고생하고 막상 하려니 잘 안변할텐데 하면서 안하고... 그래서 그냥 그런 생각없이 하면서 함께 만들어두는게 제일 좋긴 한데 또 그렇게 하지 못하는 거죠. 잘 되어있는 곳에 가면 잘 되어 있는 걸 배우고 없다면 처음 입사했을때 의욕을 가지고 한번 도전해보는거 어때요? ㅎ\n\n그간 테스트 챕터하면서 수고 많았습니다. 다음 React 챕터에서 만나요!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/11"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "수고했어요 한슬! 지난 3주간 테스트 챕터를 진행하면서 E2E와 시각적 회귀 테스트까지 직접 구축해보느라 고생했습니다. \n\n심화과제에서 팀원들과 논의하면서 \"비슷하게 생각하는 것 같은데 막상 얘기하다 보니 조금씩 다르다\"는 걸 발견한 것 아주 좋습니다. 그렇게 차이점을 이야기를 나누다보면 각자의 인사이트가 나의 그리고 모두의 인사이트가 되니까요. 앞으로도 과제하면서 서로의 생각들을 많이 보세요!\n\nQ) E2E 테스트 케이스를 작성하다 보니 통합테스트와 코드가 비슷하다는 느낌이 들었습니다. 코치님 발제를 들었을때는 간단하게 작성이 가능한 느낌이 들었는데 제가 너무 쓸데 없는 것까지 검증하면서 테스트 코드를 짜는 것일까 라는 의문이 들면서 작성했습니다ㅠㅠ 물론 AI와 페어 코딩 하긴 했숩니다..ㅎㅎ 단위테스트, 통합테스트는 많은 엣지케이스를 작성해야 안전한 테스트라는 생각이 드는데 E2E는 사용자 관점 테스트다 보니 그런 의문이 드는 것 같습니다. 어느정도 상세한 케이스까지 작성하는게 맞을까요?!\n\n=> 맞아요. E2E와 통합테스트는 시나리오를 검증한다는 측면에서 비슷하죠. 대신 e2e는 로직과 관계없이 사용자의 관점에서 테스트하는거라면 통합테스트는 로직의 관점에서 테스트를 하게 됩니다. 그래서 둘의 성격이 달라지죠\n\n=> 예를 들어 일정 생성을 테스트한다면, E2E는 \"사용자가 폼에 입력 → 저장 버튼 클릭 → 캘린더에 일정이 보인다\"는 플로우를 확인하는 거고, 통합테스트는 \"폼 데이터가 올바르게 변환되는가\", \"API 호출이 제대로 되는가\", \"상태 업데이트가 정확한가\" 같은 내부 로직을 검증하는 거예요. 엣지 케이스 - 빈 값, 경계값, 특수 문자 등 - 를 세세하게 테스트하고 싶다면 통합테스트를 E2E는 \"정상적인 사용자라면 이렇게 쓴다\"는 대표 시나리오를 중심으로 확인하면 충분합니다.\n\n=> AI와 페어 코딩했다고 했는데, AI는 종종 너무 많은 케이스를 만들어내는 경향이 있어요. 그래서 \"이 테스트가 깨지면 사용자가 서비스를 못 쓰나?\"를 기준으로 정말 필요한 것만 남기세요. E2E는 실행 비용이 높으니 핵심만 테스트하고, 나머지는 빠르고 안정적인 통합테스트에 맡기는 게 효율적입니다.\n\n3주간 테스트하느고 고생많았습니다. 이제 테스트가 완전히 생소하지는 않죠? 언젠가 실무에서 \"E2E 테스트 해봤어요?\"라고 물어보면 자신있게 \"해봤습니다\"라고 할 수 있을 거예요. 수고많았습니다. 다음 챕터에서 만나요!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "수고하셨습니다 민수님!\n\n시각적 회귀테스트에 대한 의견은 제가 잘 전달해두도록하겠습니다.\n테스트가 돌아가는 모습을 보여주거나 깨지는 상황을 데모해주면 딱 눈에 들어올 것 같네요!\n감사합니다~\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "고생하셨습니다 재윤님 ㅎㅎ \n회고도 매우 꼼꼼하게 작성해주시고, 테스트 코드 작성하시면서도 꽤 깊게 많은 고민을 해주셨던것 같아요. 전반적으로 테스트 코드 잘 작성해주셨고 크게 군더더기 없습니다. 특히 주도적으로 전략에 관해 이야기 나눠주시고 체득하신 것 같아서 너무 좋습니다. 제 의도보다 더 과제를 잘 수행해주신 것 같습니다. 감사합니다 ㅎㅎ\n\n질문 주신 부분 답변 호다닥 드려보고 마무리 해볼게요.\n\n> 결국은 헬퍼 함수를 fixture로 만들어 주입하였는데, 오프코치님은 두 가지 방법 중 어떤걸 더 선호하실까요? 아니면 이 두 가지 방법보다 더 좋은 방법이 있을까요?\n\n저는 둘 다 상관없이 많이 쓰는것 같은데요. 전에 설명드렸던것 처럼 전체를 관통하는 픽스쳐가 있고, 각 상황에 맞게 각 TC에서 수정해서 사용하는 것을 선호하는 것 같습니다 ㅎㅎ\n\n> 그 이유는 실제 시간 경과 후 알림 배너를 표시한다. 라는게 이미 검증이 된 상태에서 close 버튼을 누르면 사라진다는 사용자 검증 시나리오 이런게 비용대비 E2E 검증할 필요성이 있을까?\n\n음.. 이 부분도 일리있는 내용인데요. 제가 작성을 말씀드렸던 내용은 최대한 많이 테스트를 작성해보도록 경험해보려고 한 목적도 있고 결국 통합테스트에서 해당 부분에 대해 검증할 때 타이머에 대한 부분을 모킹하고 진행하는 부분이 있으니 확인할 필요가 있지 않을까 싶어서였어요. 근데 결국 e2e를 운영하려면 타이머를 어느정도 모킹해야하니 기존과 크게 차이는 없을것 같네요 ㅎㅎ 좋은 지적인 것 같습니다. \n질문을 조금 다르게 해서 같은 부분에 대한 검증이라면 시간이 빠르고 비용이 적은 통합테스트로만 운영하는게 더 좋겠죠! 그러면 될 것 같습니다.\n\n> playwright.config.ts 에서 fullyParallel 를 true로 설정하고, workers를 undefined 로 설정해도, e2e.json 한개로 공유하고 있어서\n\n넵 맞습니다! 영서님이 관련해서 올려주신 질문 보고 별도로 구성해도 되고, 말씀해주신것처럼 fullyParallel를 쓰지 않고 폴더별로 별도로 설정을 구성해서 병렬로 구동하게 하는것도 방법이 있을 것 같아요. 이 부분은 리뷰세션때 말씀드린것 같아서 확인해보시면 좋을것 같습니다. ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다 재윤님!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/25"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "안녕하세요 진아님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 이번 과정을 통해서 배운 지식들로 점진적으로 하나씩 테스트를 추가해볼까 싶습니다ㅎㅎ\n\n이게 제일 큰 소득이네요! 꼭 실무에서 적용하여 사용할 수 있기를 랍니다 ㅋㅋㅋ\n\n> 실제 실무에서는 테스트 코드의 비율이 어떻게 될까요? 물론 각 프로젝트의 성격마다 다를 수 있지만 보통 통합 > 단위 > e2e(핵심 시나리오) 이방식을 많이 따르는지 궁금합니다.\n\n저는 단위 테스트를 제일 많이 작성했었어요! 다만 제가 진행하는 프로젝트가 단위 테스트에 적합했기 때문이라고 생각해요 ㅎㅎ\n단위 테스트를 작성하는 이유는, 작성하는 난이도가 낮은 편이고 통합 테스트나 e2e 테스트 처럼 정교한 사이드 이펙트를 찾아내기는 어려워도 어느정도 변경에 대한 사이드 이펙트를 찾아내기가 수월하기 때문이라고 생각해요. 즉, 가성비가 좋은거죠.\n\n> 혹시 통합 테스트와 e2e테스트를 구분하는 코치님의 기준이 있을까요? 이번에 과제를 진행하면서 두개의 구분이 모호해지는 테스트들이 있는것 같았습니다. 실제 api를 써서 테스트를 하는데 의의가 있다면 비슷한 시나리오를 테스트 하더라도 통합과 e2e 두개를 작성하는것도 나쁘지 않나요?\n\n흠.. 구분하는건 \"브라우저에서의 동작을 검증한다\" 라고 하면 e2e이고, \"로직을 검증한다\" 라고 하면 통합 테스트겠죠?\n\n시나리오가 중요하다기보단 \"실행하는 환경\"이 중요하다고 생각해요\n\n> 실무에서 e2e 테스트는 보통 어떻게 이루어지는지 궁금합니다. 이번 과제에서 테스트를 여러개의 worker에서 각자의 e2e.json을 통해 병렬로 돌아가게 하는데 실패했지만 만약 성공했다고 하더라도 이건 db가 여러개로 복제되는 상황이기에 실제 서버쪽에서 이런 방식의 테스트를 지원 해줄것 같지는 않다란 생각이 듭니다. 그렇다면 실무에서는 직열로 돌아가되 최소한의 e2e를 작성해서 시간을 줄이는 방법을 쓰는걸까요? 아니면 e2e 테스트가 많아져 테스트 검증에 시간이 거리게 되면 docker등을 띄워서 독립된 환경에서 실행을 하는 방식을 통용적으로 더 많이 사용할까요?\n\n말씀해주신 것 처럼 docker를 띄우는 것도 좋은 방법이겠네요 ㅎㅎ\n이게 꼭 DB를 사용해야 하는건 아니라서요! api 응답 자체를 목킹해서 사용할 수도 있고, 혹은 아예 TestDB를 구성해서 사용할 수도 있고, 방법은 무척 다양하답니다.\n\nhttps://www.youtube.com/watch?v=cGks5f2f0YE\n\n극단적(?)인 활용 사례이긴 한데, 이 영상을 한 번 보셔도 좋을 것 같아요!\n\nhttps://www.youtube.com/watch?v=HqlCfWT3oZU\n\n이렇게 다양한 실무 활용 사례도 있으니 같이 참고 부탁드려요!\n\n> 실무에서 보통 UI 회귀테스트는 어떨때 많이 쓰나요? 공통 컴포넌트에 많이 사용을 하는 걸까요?\n\n공통 컴포넌트에는 당연히 만들어놓으면 좋다고 생각해요. 변경이 잦은 구간 혹은 여러 곳에서 많이 쓰이는 구간에 대해 테스트를 하면 좋겠죠?\n꼭 UI 회귀 테스트 뿐만 아니라 모든 테스트가 \"변경이 잦은 구간\" 혹은 \"의존을 많이 하고 있는 구간\"에 대해 테스트 하면 좋다고 생각합니다.\n\n이전 회사에서는 아예 서비스 전체에 대해 시각적 회귀 테스트를 작성했었어요 ㅎㅎ\n\nhttps://zum.com/\n\n이 페이지를 테스트 픽스쳐를 이용하여 렌더링 한 다음에 기능이 추가될 때마다 달라지는 구간이 있는지 계속 검증했던거죠.\n그러면 사람이 하나하나 모든 UI에 대해 검증하지 않아도 되고, 신규 인원이 합류하여 코드를 변경할 때에도 훨씬 효과적이랍니다.\n\n진리의 케바케랄까.. ",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "수고했어요 선민! 지난 3주간 테스트 챕터 진행하면서 E2E와 Storybook까지 구축하느라 고생했습니다. \n\nE2E나 시각적 회귀 테스트 같은 생소한 것들을 직접 해보면서 \"할 수 있다\"는 자신감을 얻었기를 바래요. 언젠가 실무에서 \"E2E 해봤어요?\"라고 물어봤을 때 생소하지 않고 대답할 수 있다면 충분히 가치있는 시간이었을 거예요.\n\n타이밍 이슈와 데이터 격리 문제로 많이 고생한 것 같네요. 좋은 경험이었을거라 생각합니다. 꼭 실무에서 이 경험을 살려 한번 더 꼭 해보길 바랍니다.\n\nQ) e2e 테스트 데이터 안정성 확보 방법\n\t* 현재 타임아웃을 늘리고 명시적 대기를 추가하는 방식으로 테스트를 안정화하려 했지만, 근본적인 해결책이 아니라고 느껴집니다\n\t* 테스트 실행 시마다 기존 데이터와 충돌하거나, 테스트 간 데이터가 격리되지 않아 테스트 순서에 따라 결과가 달라지는 문제를 겪었습니다. **어느 부분(데이터 초기화? fixture 설정? )을 어떻게 개선해야 할지 방향을 잡지 못했습니다**\n\t* Playwright의 베스트 프랙티스나 프로젝트 구조적으로 개선해야 할 부분이 있을까요?\n\n=> 정확히 파악했어요. 타임아웃만 늘리는 건 땜질이죠. 핵심은 \"테스트 격리\"입니다. 데이터가 공유되니까 테스트 실행 순서에 따라 결과가 달라지게됩니다. 솔루션에서는 `test.beforeEach`에서 e2e.json 파일을 매번 깨끗하게 초기화하는 방식을 제안하고 있으니 한번 검토해보면 좋겠네요.\n\n3주간 수고했습니다. 다음 챕터에서 만나요!",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/6"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "수고하셨습니다. 세준님~\n\nPOM패턴은 저도 처음 들어보네요. 사실 이런 방법론들은 많이 나오고 사라지고 하기 때문에 매번 뭔거 적용하고 따라가기는 함들것 같아요.\n또 세준님이 말씀하신대로 이대로해보니 또 다른문제가 생기기도 하니까요.\n이런 방법론이 나올때 온전히 적용하기보다는 좋은 아이디어나 컨셉을 취하는 형태가 제일 좋은 것 같습니다 :)  \n그래서 저는 실무에서는 POM패턴이라는 것을 사용해본적이 없습니다 :)\n이 질문에 답을 드리려면 POM패턴을 애초에 왜, 어떤문제를 해결하려고 했는지 부터 이야기를 나눠야할 것 같아욥\n그래야 다른 접근 방식이라는것에 대해서 이야기할 수 있을 것 같습니다 :) \n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "안녕하세요 채은님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ1) 아키텍처 선택\n테스트 실행 시에 순차적인 테스트가 필요없는 경우, 무조건 병렬로 테스트를 돌리는게 좋을까요?\n혹은 병렬 실행으로 전환해야 하는 기준점이 있을까요?\n\nA1)\n저는 꼭 병렬로 진행할 필요는 없다고 생각해요 ㅎㅎ\n테스트를 빠르게 실행할 수 있으면 물론 좋지만, 테스트 자체의 정확도가 더 중요해서요!\n그래서 기준치를 정해놓고, 특정 기준치에 도달하지 못하는 경우에 어떤식으로 개선할 수 있을지 고민하는 방식으로 시도해보면 어떨까요?\n\n---\n\nQ1) 데이터 리셋 전략: /api/reset 엔드포인트를 만들어 테스트 진행 전 데이터를 초기화 시키는 방법을 사용하고 있는데 더 좋은 방법이 있을까요?\n\nA2)\nMSW 같은걸 사용해서 페이지가 로드될 때 API를 리셋하도록 만드는 방법이 있답니다 ㅎㅎ\n더 좋은 방법이라기보단, 현재 상황에 적합한 방법을 찾아내어야 한다고 생각해요.\n\n---\n\nQ3) 타이밍 이슈 (알림 설정 기능)\n토스트나 alret과 같은 UI는 타이밍에 따라서 테스트가 실패하는 케이스가 있는 것 같은데, 방지할 수 있는 좋은 방안이 잇을까요?\n대부분 실패하면 waitForTimeout 메서드를 사용해서 해결했는데.. 별로 좋지 않은 방법인 것 같습니다.\n1분후 알림 예정인 경우, 테스트 내에서 실제로 1분이라는 시간을 기다렸다 테스트를 검증해야 하는지 궁금합니다. 만약 그 방안이 아니라면 테스트 케이스 내에서 시간을 조작하는 방법이 있을 것 같은데 실제 로컬에서는 잘 통과하지만 CI에서 돌아갈 때에는 시간 이슈로 통과하지 못한 케이스들이 있었는데 이부분은 조금 더 학습해 볼 예정입니다.\n\nA3) 1분을 꼭 기다릴 필요는 없어요! 대신 setTimeout 같은걸 목킹해서 사용하는 방법을 생각해볼 수 있답니다 ㅎㅎ\n\nhttps://playwright.dev/docs/clock\n\n이런 API를 한 번 참고해보세요!\n\n---\n\nQ4) E2E와 통합 테스트의 경계\ne2e와 통합 테스트에서 겹치는 기능이 많다고 생각이 들었는데, 그 경계를 어디까지 두는 것이 적절한지 궁금합니다.\n실서버 데이터 검증 vs 목업 데이터 기반 검증의 차이가 가장 큰 차이점이라고 생각이 드는데, 고려해서 경계를 구분하면 좋은 요소가 있을까요?\n\nA4)\ne2e를 실행한다고 해도 실서버 데이터를 검증할 수 있는건 아니라고 생각해요. 물론 실서버 데이터를 검증할 수도 있지만, 그 자체가 목적은 아니라서요!\n반대로 통합 테스트를 사용할 때에 실서버 데이터를 사용할 수도 있습니다. 실서버 API를 이용하면 되니까요 ㅎㅎ\n\n그래서 저는 \"얼마나 빠르게 피드백을 받고 싶은가\"를 토대로 결정해야 한다고 생각해요.\n통합 테스트로 할 수 잇는건 e2e테스트로도 당연히 할 수 있죠.\n대신 e2e 테스트는 통합테스트보다 느린 대신 정확도가 높아요.\n\n그럼 여기서 가치 판단의 기준을 \"얼마나 빠르게 사이드 이펙트에 대해 알림을 받을 것인가\"로 정해야 한다고 생각합니다.\n\n통합 테스트는 작성 난이도가 높은 대신에 테스트 속도가 빠르고\ne2e 테스트는 작성 난이도가 낮은 대신에 테스트 속도가 느리죠\n\n이를 토대로 \"빠른 검증\"이 필요한 구간은 통합으로 만들어놓고,\n정확도가 중요한 구간으 e2e로 두는거죠\n\n혹은 테스트를 최대한 빠르게 작성해서 사이드 이펙트를 검증하고 싶다면 일단 e2e를 만드는 방법이 있답니다 ㅎㅎ\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/40"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "안녕하세요 준태님! 3주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 이번주를 끝으로 한 챕터가 마무리되었으므로 전반적인 회고를 해보자면, 3주 동안 테스트 코드 개념에 대해 많이 배우고 성장한 것 같습니다. 항상 테스트 코드의 중요성만 듣고 테스트 코드를 작성해볼까해도 우선 순위에서 밀려 제대로 작성해 볼 기회가 없었는데, 이번 3주 동안 테스트 코드도 꽤 써보고 어떻게 작성해야할지 고민도 많이 해보고, TDD 사이클을 기반으로 한 에이전트도 활용해보면서 테스트 코드를 쓰는 것에 대해 자신감이 붙었습니다.\n\n자신감이 붙었다니 다행이네요! 실무에서도 이제 뚝딱뚝딱 잘 적용할 수 있으면 좋겠어요.\n\n> 요소를 깔끔하고 유지보수에 용이하게 쿼링하는 방법, 여러 테스트 환경들에 대한 설정이나 CI/CD를 관리하는 방법, 독립적인 mock data를 운영하는 방법 등 채워야 하는 부족한 부분들이 많은데, 잘 학습하기 위해서는 좋은 테스트 코드를 찾아보고 많이 구현해보면 될까요?\n\n개인적으로 \"기존에 작성된 테스트\"를 참고하는게 제일 도움이 많이 된다고 생각해요 ㅎㅎ 그럼 어떤 코드들에 테스트가 잘 작성되어있을지 생각해보자면, 아마 오픈소스겠죠!?\n그래서 다양한 디자인 시스템(ark ui, chakra-ui, radix-ui 등)이나 react 같은 라이브러리를 보면서 어떤 식으로 테스트가 작성되어있는지 확인해보면 좋답니다.\n\n혹은 github에 올라와있는 소스들을 뒤적거려보면 테스트가 무척 많을꺼라 이런거 참고해보시면 좋아요! toss에 올라온 코드들도 보면 대체로 테스트가 잘 작성되어있으니 참고하기 좋답니다 ㅋㅋ\n\n그리고 AI를 활용할 때에는 \"사용자 시나리오 기반으로\" 라는 문장을 붙여서 요청하면 테스트를 조금 더 스펙을 서술하듯 작성해준답니다!\n\n\n> 멘토링 시간에 언급해주신 Gamification이 저랑도 굉장히 잘 맞는거 같습니다! 혹시 평소에 Gamification을 어떻게 활용하셨는지 좀 더 얘기해주실 수 있을까요?\n\n일단 환경 자체를 만들어야해요. 랭킹 시스템이 있는 플랫폼에 참여한다거나, 지금처럼 항해플러스 같은 환경을 찾아내는거죠 ㅎㅎ\n혹은 직접 만들 수도 있겠죠!?\n깃허브 잔디를 매일매일 심는다거나?\n블로그 스터디를 만들어서 운영한다거나?\n\n어쨌든 중요한건 \"내가 학습하고자 하는 목표\"가 있을 때, 이 목표를 달성하기 위한 \"환경\"은 어떤게 필요할지 고민해보고 그 환경을 직접 만들어가는거죠. 그게 제일 효과적이었던 것 같아요 ㅎㅎ\n\n그리고 목표가 너무 거창하면 안 되는 것 같아요. 1달 혹은 1주일 단위로 수행할 수 있는 목표가 좋답니다!\n",
    "assignment": {
      "name": "STEP06 프론트엔드 테스트 설계와 AI 활용 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter1-3/pull/42"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/13"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/19"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/24"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/16"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/4"
    }
  },
  {
    "passed": false,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/40"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/35"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/33"
    }
  },
  {
    "passed": true,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/55"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/53"
    }
  },
  {
    "passed": false,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/45"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/23"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/39"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/2"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/37"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/47"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/49"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/11"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/50"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/10"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/30"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/38"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/25"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP07 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/22"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "승훈님 고생하셨습니다 ㅠㅠ\n아쉽게 테스트 통과를 하지 못했고, 기능 구현이 모두 되어있지 않다고 체크해주셔서 불합격 처리 했습니다.\n시간이 많이 부족하셨었나 보네요  ㅠㅠ\n\n> 장바구니도 옵저버 패턴처럼 구독해두고 변경이 있을때마다 알림을 통해 변경을 주고 싶은데, 그런 방식으로 구현하는 것에 대한 명확한 코드 구현이 떠오르질 않습니다. 간단히 '옵저버 패턴 쓰면 됨', 이 아닌, 어떤 식으로 하면 좋을지에 대한 걸 알고 싶습니다! 나라면 옵저버 패턴보다 그건 이런식으로 구현할 것 같다~, 이러한 내용도 너무 좋을 것 같습니다. 아이디어를 듣고 그걸 추후에 활용해보고 싶습니다.\n\n결국 이 과제 자체의 맥락이 리액트와 유사한 환경을 만드는 것이라 생각하는데요. 저희들이 리액트의 상태구조가 어떻게 되어있고, 상태를 사용하고 있는 또는 전달하는 컴포넌트들이 어떻게 리렌더링이 되는지를 봐도 좋을것 같아요 ㅎㅎ 추가로 리액트의 전역 상태 라이브러리들처럼 해당 상태를 구독할 때 어떻게 렌더링을 유발할 수 있는지도 보면 좋을것 같구요. 요즘 언급이 많이되고 구현되서 사용되고 있는 signal 같은 것들도 함께 보면 좋지 않을까 싶습니다!\n\n이미 당연히 알고 계시겠지만 저희가 결국 여기서 바라는건 특정 패턴에 대한 학습 뿐만 아니라 내부 구조를 고민해보는 거라 생각하거든요 ㅎㅎ  키워드를 채워두셨다고 표현해주셨는데 포기하지 마시고 꼭 짧은 시일내에 다시 시도해보시면 좋을것 같습니다. 담주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "수고했어요 다솜! 프레임워크 없이 SPA를 직접 만들어보면서 React가 왜 그렇게 설계되었는지 간접적으로나마 체험하는 시간이 되었기를 바랍니다.\n\n프로그래밍 언어를 자연어 학습에 비유한 통찰이 정말 인상깊었어요. 지식을 이해하는 것과 그것을 깨닮음으로 내것이 되는 경험을 하는 것은 차이가 크지요. 안다는 것의 발전으로 체득한다라는게 개발을 학습할 때 정말 중요한 부분이니까요. 이번 과제에서 \"구현만 되면 된다\"에서 \"왜 이렇게 만들어졌나\"를 고민하게 되면서 더 큰 범위의 앎을 경험했을거라 기대합니다. \n\n코드를 보니 컴포넌트 생명주기를 직접 나눠보고, 이벤트 위임 패턴을 만들어보고, Store를 설계해보면서 React가 왜 그런 선택을 했는지 프레임워크에서는 당연히 되는 일들을 직접 만들어보면서 왜 이런 구조가 필요한가를 잘 체험했다 보입니다. \n\n객체의 변경을 감지 할때 JSON.stringify 말고 shallow equal 같은 방법도 한번 시도해보세요. Observer에도 구독 해제 로직 추가해보는 거 좋은 연습이 될 거예요. 필요한 핵심 기능을 아주 초창기 SPA 프레임워크처럼 잘 구성했네요. 잘했습니다. 이 중에서 현대 프레임워크는 어느 부분까지 추상화 아래로 숨길 수 있었고 그 내부 기능이 어떻게 생겼을지 추상화 아래로 감추기 위해서 어떻게 고민을 했을지도 생각해보는 시간이 되기를 바래요.\n\nQ) slot 기반 렌더링을 유지하면서도, 모달·토스트처럼 부모 렌더링에 종속되어서는 안 되는 컴포넌트를 자연스럽게 다룰 수 있는 더 나은 접근 방식이 있을까요?\n\n=> 다솜의 의도했던건 slot의 영역이 자리만 차지하는 placeholder의 역할만 하고 자식 컴포넌트와 완전히 교체를 했으면 좋겠는데 그러면 다음번 업데이트시 업데이트 위치를 알 수 없다보니 부득이하게 data-slot와 data-container를 분리해서 자리가 유지되는 data-container를 만들고 고민을 했군요. 맞아요. DOM 렌더링 방식이 아니라 교체를 하기 위해서는 반드시 그려져야할 자리가 필요하죠. 이러한 교체식을 택한 프레임워크들은 CommentNode나 빈 TextNode, 혹은 templateNode를 생성하여 placeholder의 방식을 택하는 경우가 많습니다. 눈에 보이지 않은 노드를 생성해서 자리를 잡아두면 이후에는 그 노드 이전에 데이터를 추가하거나 교체하는 방식으로 만들 수가 있죠.\n\n=> React의 경우는 교체식이 아니라 렌더링 방식을 택하게 되니 그냥 텍스트와 Node와 slot의 차이없이 일관된 방식으로 그려내는 식을 택하긴 했습니다. 이는 근본적으로 SPA의 접근 방식이 다른 부분입니다. 직접 교체를 하는 방식이 성능적으로도 구현상으로도 이득이지만 복잡해지는 게 맞고 렌더링 방식은 일관된 방식으로 그려낼 수 있지만 그에 따른 트레이드 오프가 있는 것이죠.\n\nAI 활용 방식도 좋았습니다. 논의하고 직접 만들고 리뷰받는 방식, 이게 맞는 거예요. 이런 식으로 계속 활용해보세요.\n\n앞으로도 기능을 빠르게 만드는 데에만 집중하지 말고, 기술이 만들어진 배경과 원리를 이해하는 데 시간을 들이세요. 이번처럼 직접 만들어보는 경험이 있으면 다음 React 챕터에서는 내부 동작이 훨씬 명확하게 보일 거예요. 새로운 라이브러리나 프레임워크를 배울 때도 빠르게 적응할 수 있을 겁니다. 수고많았습니다!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/13"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "안녕하세요 정원님!\n흠... 현재 결과물을 정상적으로 실행할 수 없는 상태네요 ㅠㅠ\n아무래도 과제를 진행하기에 시간이 많이 부족했었던 것 같아요.\nPR의 내용을 보니까 주로 회사일 이슈가 있었군요 ㅎㅎ\n\n가능하다면 수료 후에 한 번 더 도전해보시길 바랍니다!!\n\n---\n\n> Q . 그런데, Footer의 기본 스타일이 sticky top-0였던 것은 잘못 작성돼있던 것이 맞을까요?\n\n저도 UI는 AI가 만들어준걸 그대로 사용해서 제대로 안 본 것 같아요 ㅎㅎ\n아마 sticky로 해놨어도, footer 밑에 별도의 UI가 없어서 정상동작 하는 것 처럼 보였던 것 같네요!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "연욱님 수고하셨습니다.\n\n이번주차는 시간 부족하셨던 것 같아요. \n하지만 멘토링때 말씀드렸듯 진행해야할 것들은 따로 체크리스트를 만들어두시고 솔루션 코드를 통해\n배우시면서 다시 복습 꼭 해주시면 좋을 것 같습니다!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/19"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "수고했어요 지현! 프레임워크 없이 SPA를 직접 만들어보면서 구조 설계와 책임 분리를 고민하는 시간이 되었기를 바랍니다.\n\n코드를 보니 라우터, 뷰, 스토어의 역할을 어떻게 나눌지 계속 고민한 흔적이 보여요. 모달을 토스트처럼 분리하려고 시도한 것도 좋았고요. 완벽하게 되지는 않았지만 \"이게 맞나?\" 하고 고민하면서 여러 방식을 시도해보는 과정이 중요한 학습이 되었으리라 생각합니다. 라이브러리에 의존하지 않고 직접 만들어보니 내부 로직이 어떻게 돌아가는지, 어디까지 책임을 부여할지 고민하게 되었다는 부분이 이번 과제의 핵심이니 좋은 경험이 된 것 같아요.\n\nQ) 라우터, 뷰, 스토어의 책임과 역할을 처음 구현할 때 정하시나요? 구조를 어떻게 짜시는지 궁금합니다.\n\n=> 지금이야 라우터, 뷰, 스토어의 역할이 이미 정해져있으니 Best Practice를 따라가면 되지만 모호한 것들의 책임과 역할을 구분한다고 생각하고 답변할게요. \n\n경계를 만드는 건 \"요구사항 변화\"에 따른 \"코드 변화\"입니다. 같은 요구사항에 반응하는 것들을 함께 모아두자는 것이죠.\n\n가령 개발을 하다가 여기 /product/carts 라는 URL에서 /carts 라고 바뀐다면 분명 바뀐 것은 URL이죠. 그런데 컴포넌트의 책임이 URL와 뷰를 함께 가지고 있었다면 URL을 변경할때의 코드에 컴포넌트의 뷰가 함께 포함되고 있는 모양새가 됩니다.\n\n반대로 화면의 글자 수정을 해달하는 요청이 있는데 URL이 포함되어 있는 코드도 같이 커밋을 하고 있겠죠.\n실전에서는 단순히 URL을 변경하는 요청과 화면을 변경하는 요청은 서로에게 아무런 영향을 미치지 않는다는 것을 압니다. 그러면 경계를 그을 수 있죠. 이 둘은 연관은 되어 있지만 함께 변하는건 아니구나. 그렇다면 화면과 URL은 연관은 있지만 책임은 분리할 수 있습니다. 그렇게 Router와 View가 분리되는 것이죠.\n\n지금 지현의 코드에서 \"장바구니 저장방식을 localStorage가 아니라 서버 API로 저장해주세요\" 라는 요구사항을 받았다고 해봅시다. 지현의 코드 어디를 수정해야 하나요? 지금으로써는 src/components/modal/core.js의 파일을 수정해야 합니다. 분명 장바구니의 저장방식을 변경해달라고 했는데 변경되는 파일은 modal/core 에 있는 addToCart네요. 이런 경우 책임이 모호해진거죠. modal/core라면 modal의 핵심 동작이 변경이 되었을때에만 이 파일이 수정이 되어야 하는데 전혀 다른 요구사항에 반응하는 코드가 있다는게 역할을 잘못 정했다는 신호죠.\n\n사실 처음에는 명확한 책임과 경계를 이해하기는 어렵습니다. 그런데 수정사항이 필요할때마다 그때 코드의 어디가 수정이 되는지를 확인하면서 요구사항과 수정되는 코드와 현재 책임과 역할과 위치를 보면서 논리적으로 일치하지 못한다면 조금씩 변경하면서 책임과 역할에 맞게 제 위치를 찾아가는 것입니다. 이미 많은 사람들의 학습된 경험에 의해 잘 알려진 분리(라우터, 뷰, 스토어) 같은 것들도 있고 경험을 하면서 알게 되는 부분들도 있죠. 이 후 과제를 하는 과정에서 잘 생각해보면 좋겠습니다.\n\n\nQ) 옵저버 패턴 방향성과 여러 패턴 중 선택 기준이 궁금합니다.\n\n=> 우리가 책임과 역할을 나누더라도 분리만 해서는 서비스가 동작하지 않습니다. 반드시 연결을 해야만 데이터의 흐름이 이어지고 서비스가 되겠죠. 상태를 변경해서 이로 인해 화면이 변경되는 과정의 연결은 반드시 필요합니다. 이때 누가 누구를 알아야 하는가 혹은 이 연결의 방향을 어떻게 해야 하는가가 필요하죠.\n\n=> 변경된 값을 화면에 그리기 위해서는 값이 변경과 그려야할 대상(DOM)을 누군가는 알야야 합니다. 기존에는 컨트롤러라는 영역이 둘다 알고 값이 변경되는 핸들러에서 값도 변경하고 그에 적합한 화면도 수정하는 식으로 개발을 했었죠. \n\n// controller.js\nimport { view } from './view.js';\nimport { model } from './model.js';\n\nfunction addToCart() {\n  model.add();\n  view.update(model); \n}\n\n그렇게 이렇게 만들면서 view와 model도 양방향으로 컨트롤러에 의존성이 생깁니다. model이 변경되어도 view를 수정해야하고 view가 변경이 되어도 model의 영향을 주는 방식입니다. 이렇게 의존성이 서로를 의존하면 복잡한 구조가 되죠.\n\n옵저버 패턴은 이러한 의존성의 방향을 뒤집는 데 사용합니다. model을 옵저버로 만들면 컨트롤러는 사라지고 view는 model만 의존하고 model의 의존성은 사라집니다. \n\n이렇게 양방향 의존성이 만들어지는 경우 이를 하나의 방향으로 만들어 내거나 의존성을 만들고 싶지 않을 경우 옵저버 패턴을 사용합니다.\n\nQ) 장바구니 모달 구현 - 공통 로직 사용하면서 렌더링 비용 줄이는 방법\n\n=> 아주 훌륭한 고민입니다. 모달의 경우 분명 독립적인 영역인데 지금의 구조상 모달의 내용이 변경이 되는데 전체가 다시 그려지는 구조다 보니 이를 최적화 하고 싶다는 생각이 들었군요. 맞아요. 대부분의 최적화나 성능 개선은 이런 방향으로 고민이 됩니다. 가장 쉬운 방식으로 일단 제작해두되 굳이 다시 해야하지 않아도 될 부분은 하지 않는 방법을 고민해보는 거죠.\n\n=> 프레임워크들은 이 문제의 해법으로 2가지의 입장을 취했습니다. 지금 처럼 모달과 뷰등을 분리해서 내가 어떤 상태가 변경되면 그 상태로 인해 업데이트 해야할 부분들만 다 확인해서 격리해서 업데이트를 하자. 혹은 전체를 렌더링을 하지만 하지 않아도 될 영역은 skip하자. Vue나 Svelte 등은 전자를 택했고 React는 후자를 택했죠. \n\n=> 어떤 방식이 정답이다 하는건 없습니다. 위 2가지의 측면을 놓고서 각 프레임워크들이 어떻게 동작을 하는지 혹은 나라면 어떻게 구현할 지를 생각해보면서 내가 직접 구현하지는 않지만 내 코드가 작동하는 깊이의 이면을 이해보게 되기를 바랍니다.\n\n라이프사이클이나 구조 설계에 대한 고민을 많이 했는데, 이런 고민들이 나중에 실무에서 큰 자산이 될 거예요. 완벽하지 않아도 괜찮아요. \"이게 맞나?\" 하고 계속 질문하는 자세가 중요하니까요. 수고많았습니다!\n\nps. 과제의 합격 조건인 테스트 통과에 부합하지 못하는 건이 있어서 결과는 불합격으로 두었습니다. 추가적으로 개선을 하게 되면 다시 알려주세요. 수고하셨습니다!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/24"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김대현",
    "feedback": "앗 대현님 ㅠㅠ\n남겨주신 PR을 보니 관련해서 틀을 잡아두고 구현을 진행하려는 흔적들이 남아있는 것 같은데, 아직 완성을 못하셨네요 ㅠㅠ\n아쉽게 배포 링크가 없고 테스트가 통과하지 않아 불합격 처리 했습니다..\n이번 주차때 발제자가 의도했던 부분들은 키워드 잘 정리하시고 짧은 시일내에 코드 완성해보시면 좋겠어요!\n다음주차 과제는 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/31"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "안녕하세요 도현님! 4주차 과제 쉽지 않았틀넨데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 2. 상태 관리를 어떻게 할까 - Redux vs useReducer\n\n사실 Redux에서도 reducer를 사용하기 때문에 큰 차이가 없다고 봐도 무방하지 않을까요!?\n\n아마 말씀하시건 redux-toolkit 같기도 하네요 ㅎㅎ\n\n> 실제로 장바구니 만들 때 addToCart, removeFromCart, updateQuantity, clearCart 이렇게 4개 액션이 필요했는데, 각각 함수로 분리돼있으니까 수정할 때 편했습니다. 지금 생각해보면 actions 객체가 198줄이나 되는데, 이게 맞나 싶기도 합니다. 페이지별로 분리하는 게 나았을까요?\n\n분리할 수 있으면 분리하는게 좋겠죠!? 지금도 모습도 현재 상황에서 적절한 선택을 했다고 생각합니다 ㅎㅎ\n\nQ1) main.js의 이벤트 위임 구조 개선\n현재 main.js:77-410에서 전역 이벤트 위임을 사용하고 있습니다.\n410줄의 이벤트 핸들러가 한 파일에 모여있는데, 이를 개선하는 방법으로:\n\n- 도메인별 핸들러 분리 (cartHandlers, productHandlers 등)\n- 각 컴포넌트가 자체 이벤트를 관리하는 방식\n\n중 어떤 접근이 더 나을까요?\n또한 전역 이벤트 위임의 장점을 유지하면서도 코드 가독성과 유지보수성을 높일 수 있는 패턴이 있을까요?\n\nA1)\n개인적으로 컴포넌트별로 이벤트를 관리하는게 좋다고 생각합니다 ㅎㅎ\n이번 과제 솔루션을 참고해보시면 좋을 것 같은데요,\n과제 솔루션은 사실 한 곳에서 이벤트를 모아서 관리하고 있는데, addEvent 함수를 활용하면 컴포넌트 파일 내에서 관리할 수도 있어요!\n대신 이벤트를 등록하는 시점이 무척 중요해지겠지만요..!?\n\n\nQ2) 무한 스크롤의 IntersectionObserver 재연결 패턴\nHomePage.js:89-105에서 상품 목록이 업데이트될 때마다 observer를 재연결하고 있습니다.\nsetTimeout 100ms를 사용하는데, 이게 최선의 방법일까요?\nDOM 렌더링 완료를 감지하는 더 명확한 방법이 있는지,\n그리고 observer 재연결 패턴의 더 좋은 방식이 있다면 알고 싶습니다!\n\n렌더링 완료 시점은 queueMicrotask 혹은 requenstAnimationFrame 등으로 관리하면 어떨까 싶어요 ㅎㅎ\n혹은 직접 render를 실행하지 않도록 제어하면서\nappendChild를 하는 방식으로 다룰 수도 있을 것 같네요!\n\n```tsx\n// stop일때는 상태를 변경해도 렌더링이 안 되도록 함\nrender.stop = true\n\n// 혹은 subscribe을 잠시 중단한다거나?\nstore.stopNotify = true\n\n// 그 다음 store의 값을 변경하고 appendChild\n\n```\n\n---\n\n정답이 있는건 아니고 몇 가지 아이디어일뿐이라서, 참고 정도만 해주세요!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "민석님 과제 잘 진행해주셨네요~\n필요한 사항들은 모두 잘 구현해주셨습니다 :+1\n옵저버 패턴의 활용 방법이나 실제 구현에 대해서도 잘 봐주신 것 같아요 ㅎㅎ \n\n결국 이 과제 자체의 맥락이 리액트와 유사한 환경을 만드는 것이라 생각하는데요. 지금 패턴들을 살펴봤던 것처럼 다양한 키워드들이 있을텐데 꼼꼼하게 살펴보고, 기회가 된다면 비슷한 역할을 하는 다양한 라이브러리들도 함께 보면 좋을것 같습니다.\n\n> 라우터를 직접 구현해봤는데 pushState를 통해 url변경시에 상태값을 관리하는것과 렌더링 시키는 부분이 가장 어렵게 느껴졌습니다..\n\n저희가 리액트 구현을 공부할 때 리액트 코드에 대해 직접 참고했던것처럼 이 부분에 대해 궁금증이 있는것들은 tanstack router나 react router의 코드를 직접 참고해보면 좋은데요. \n\n만약 생명주기를 활용한다면, 각 페이지 컴포넌트에서 라우터에서 인지시켜준 진입 / 이탈 정보만을 가지고 그려주면 될 것 같구요! 생명주기를 사용하지 않는다면, 라우터 자체에 상태 머신(네비게이션 전환 상태에 대해 나타내주는)을 둬서 전환을 관리하면 될 것 같아요. 스크롤 같은 것들은 별도 브라우저 스토리지나 상태로 저장해서 잘 관리해봐야할것 같네요. \n\n지금의 구현도 나쁘지는 않지만, (이동에 대한 것과 렌더링을 구분한다는 점도 좋구요) 말씀해주신것처럼 isQueryOnly자체가 너무 모호하기 때문에 각 부분에서 어떤 변화가 일어났는지 알기 어려워서 좀 더 각 렌더러에 도움이 될 수 있는 정보 그 자체를 넘겨보는 것도 좋을것 같습니다.\n\nhttps://www.heropy.dev/p/9tesDt 요기 잘 정리 되어있어서 함께 살펴봐도  좋을것 같아요! \n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/16"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "민지님 수고하셨습니다.\n\n이번주차는 시간 부족하셨던 것 같아요. \n하지만 멘토링때 말씀드렸듯 진행해야할 것들은 따로 체크리스트를 만들어두시고 솔루션 코드를 통해\n배우시면서 다시 복습 꼭 해주시면 좋을 것 같습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김성민",
    "feedback": "안녕하세요 성민님!\n4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n리뷰 받고 싶은 부분이 따로 없어서 피드백은 바로 마무리하겠습니다.\n추후에 궁금하점 생기면 언제든 디스코드를 통해 문의주세요!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "안녕하세요 소리님! 4주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> render() 함수에서 isMounted 체크를 통해 최초 렌더링과 업데이트를 구분하는 방식이 적절할까요?\n\n잘 진행해주셨다고 생각합니다 ㅎㅎ\n지금 코드에서 다른 방법은... 딱히 생각나질 않네요 ㅋㅋ\n\n조금 다른 방법으로는, 리액트에서는 render 함수를 실행한 다음에 queueMicrotask 같은 api를 사용해서 mount 된 시점을 \"예측\" 하는 걸로 알고 있어요.\n\n다만 지금 소리님께서 만드신 방식은 어차피 innerHTML 로 dom을 직접 렌더링 하고 있기 때문에 그럴 필요가 없는 상태랍니다!\n\n> useStore 훅에서 구독만 하고 상태를 직접 읽지 않는 구조입니다. 제공하는 훅이 값까지 함께 리턴하는 형태가 좋은지, 아니면 지금처럼 구독만 하고 UI에서 getState로 직접 읽는 패턴도 괜찮은지 궁금합니다.\n\n지금과 같은 방식도 나쁘지 않다고 생각해요 ㅎㅎ\n물론 useStore에서 필요한 값을 selector를 통해 가져와서 사용하는 방식도 있을 것 같아요!\n\n> 인풋 이벤트나 체인지 이벤트가 발생할 때마다 렌더링을 시키면 인풋에서 포커스 아웃이 되기 때문에 uncontrolled 방식을 사용하였습니다. 이 경우 인풋의 값을 변경해놓고 다른 필터를 변경하여 다른 필터 값 변경 시 인풋 값이 날아가는 문제가 있는데 개선 방법이 있을까요?\n\n지금 상황에서는 어쩔 수 없다고 생각해요. 이를 개선하려면 render 시스템 자체를 재구성해야 하는데, 그러면 일이 무척 커지니까요 ㅎㅎ\n이를 해결하기 위한 과정이 5주차 과제라고 보시면 될 것 같습니다!\n\n> 컴포넌트 안에 컴포넌트가 여러 개 존재하는데 마운트/언마운트를 제어하는 방법은 무엇일까요? 전역적으로 컴포넌트를 등록하고 관리해야 할까요?\n\n마찬가지로 5주차 과제를 하면서 고민해보시면 좋을 것 같아요!\n\n--\n\n고생하셨습니다 소리님!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/4"
    }
  },
  {
    "passed": false,
    "name": "김우정",
    "feedback": "수고했어요 우정! 이번 과제는 프레임워크 없이 SPA를 직접 만들어보면서 프레임워크의 내부 구조를 한번 상상해보고 추측해보고 고민하면서 하나 하나 맞춰가면서 몸으로 체득해보는 시간이었어요!\n\n과제의 의도를 기억하고 다른 친구들을 코드를 기억했다가 나중에 여유가 생기게 된다면 한번쯤 쓱~ 해볼 수 있게 되길 바래요!\n\n다음 시간도 화이팅입니다 :)",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/40"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "준모님! 잘 구현해주셨는데 테스트가 전부 실패해서..CI 환경에서만 실패하는거면 다시 요청을 드릴까 했는데 로컬에서도 실패하네요..\n과제 통과 조건이 잘 구현이 되서 배포 환경에서 올바르게 기능이 동작하는 것도 있고, 테스트가 온전히 다 통과하는 것도 있어서 불합격을 드렸습니다.\n이미 인지하고 계셨을지 모르겠지만, 개인적으로는 많이 아숩네요 ㅠㅠ\n\n> Router 구조 내에서 Hook 기반 렌더링을 자연스럽게 결합하는 방법에 대한 조언이 궁금합니다.\n\n개인적으로는 라우터에서 어떤 컴포넌트를 루트로 마운트할지만 정하고, 실제 렌더링이나 훅 관리는 별도 렌더러 레이어에서 처리를 하는 형태로 가는게 좀 더 유연하지 않을까 싶습니다. 그래야 단일 페이지 뿐만 아니라 다양한 페이지에서 복잡한 로직들을 처리하게 하는게 가능할 것 같아요! 조금 모호할 수 있는데 실제 리액트 라우터나 탠스택 라우터 구현을 참고해보면 좋을것 같습니다!\n\n구현부를 보니 더 아쉽긴하네요 허허..\n고생하셨고 다음 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/35"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "안녕하세요 채영님! 4주차 과제 쉽지 않았틀넨데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 현재 옵저버 기반 상태 관리 로직이 React의 리액티브 구조에 비추어 충분히 추상화된 구조인지 궁금합니다.\n\n음.. 리액트에 비교하기는 성격이 많이 다르다고 생각해요. 리액트는 \"로컬 상태\"를 추상화해서 관리하고, 현재 채영님께서 구현해주신 방식은 \"store\" 라는 전역 상태를 기반으로 관리하고 있으니까요 ㅎㅎ\n\n\"충분히\"의 기준이 얼만큼인지는 모르겠으나, 일단 현재 어플리케이션 구현에는 적합한 형태라고 생각합니다!\n\n> 위에 언급했듯 URL과 Store 간의 상태 동기화가 복잡하게 되어있는 상황인데, 더 단순하게 만드는 설계 방향이 있을지 피드백 부탁드립니다.\n\nURL과 Store를 구분할 필요가 있을까요!? URL의 상태가 변경되면 render가 되도록 구현해주면 어떨까 싶습니다.\nsubscribe를 꼭 store 하나만 등록할 필요가 없으니까요!\n\nrouter 변경 -> render\nstore 변경 -> render\n\n이런식이죠 ㅎㅎ\n\n> 코치님이 동일 환경에서 과제를 진행하신다면 어떤 이유로, 어떤 순서로 진행할 계획이신지 궁금합니다.\n\n저는 아마 store, router, lifecycle 을 각각 먼저 구현한 다음에 이를 기반으로 코드를 조립해나갈 것 같아요!\n솔루션 코드를 참고해보시면 좋습니다!\n\n우선순위로 따지자면,\n\nstore > router > lifecycle 입니다. 상태가 제일 중요해요!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/12"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "안녕하세요 현우님! 4주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n다만 리뷰 받고 싶은 부분이 없어서 피드백은 바로 마무리 하겠습니다.\n\n추후에 궁금한 부분이 생기면 언제든 디스코드를 통해 문의 주세요! 고생하셨습니다~!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/33"
    }
  },
  {
    "passed": true,
    "name": "남은주",
    "feedback": "은주님 고생하셨습니다 ㅎㅎ\n테스트도 잘 통과하고 필요한 기능들도 모두 잘 정리 되어 있네요\n\n> 옵저버 패턴을 사용해 상태 관리 로직을 구현해 보려 했습니다. 제가 구현한 코드가 옵저버 패턴에 맞게 잘 구성되었는지 검토해 주시고, 보완할 부분을 제안해 주실 수 있을까요?\n\n잘 작성하셨어요! 필요한 적절한 기능들을 학습해서 채워나가는 관점에서 훌륭한 구현인데요. 구독을 해제하는 형태의 기능정도 추가되면 어떨까 싶고(지금은 필요없지만) JSON.stringify 를 활용한 비교 대신 객체를 비교한다면 더 빠르고 안정적인 방법은 없을지 고민해봐도 좋을것 같네요! 기본적인 패턴과 구현 목적은 잘 이루신 것 같습니다.\n\n> 혹 제 코드를 검토하시면서 그래도 이건 잘 구현한 것 같다라고 생각되는 부분이 있다면 하나 꼽아주실 수 있을까요?\n(코드에 자신이 없음)\n\n왜 자신이 없으신지 잘 모르겠어요 사실! 전반적으로 코드들을 역할에 맞게 잘 나눠주셨고 필요한 기능들도 활용 가능한 패턴들도 적절하게 잘 사용하신 것 같거든요 ㅎㅎ 지금은 어느정도 테스트가 구현되어있는 상태이고 방향이 잡혀있는 상태라 그걸 채워가다 보니 그렇게 생각할 수 있는데 구현의 관점에서는 크게 문제되는 부분은 없고, 조금 더 나아가서 실제 구현과 유사하게 더 가깝게 만드려면 수정이 필요한 부분들이 있는데 그런것들을 찾아 나가시면서 공부를 해본다면 더 좋을것 같습니다. \n\n(코드 관점에서는 아직 조금 더 함수를 나누고 역할대로 모듈을 분리할 수 있는 것들이 있는데 그런것들은 사실 앞으로 더 많은 고민이 있을예정이라 크게 걱정안하셔도 될 것 같습니다.)\n\n> 코드는 동작하지만 아직 완전히 이해하지 못한 부분이 전반적이라 어떤 학습이 필요할지 추천해주시면 좋겠습니다.\n\n이건 준일님에게 한 번 더 여쭤보시는게 정확할 수 있는데요. 제가 이 과제를 보고 생각했던 것들을 나열해보면.. 상태를 어떻게 관리할지, 그 상태를 통해 렌더링 파이프라인을 어떻게 만들 수 있을지, 라우팅 구조에 대해 어떻게 이해하고 접근할 지 등이 중심이 된 것 같고 거기서 파생되는 여러 구현 방식, 실제 리액트 또는 비슷한 역할을 하는 라이브러리들이 추구하는 철학등을 고민해보는게 목표이지 않았을까 싶습니다 ㅎㅎ\n\n다른 분들 코드도 많이 리뷰하고 참고해보시면서 이번 주차 과제 더 발전시켜보시면 좋을것 같습니다. 고생하셨어요!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/55"
    }
  },
  {
    "passed": false,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "희정님 과제 잘 진행해주셨네요~\n아쉽게 중간중간 누락되어있는 기능이 있고, 테스트가 실패하고 있어 불합격 처리 했습니다. \n그럼에도 과제를 진행하는데 있어서 중간중간 필요한 고민들은 잘 진행해주신것 같아요! 지금 채우지 못했던 부분들은 꼭 가까운 시일내에 진행해보시면 너무 좋을 것 같습니다.\n\n> [상태에 변화가 있을 때, 구독자에게 알림] 이와 같이 동작을 한다고 하는데 이것이 결국 observer 방식 아닌가요?\n\nsignal은 최근 여러 라이브러리에서 많이 쓰이고 있는 상태 관리 패턴인데요. 어떻게 보면 옵저버 패턴의 일환이라고 볼 수 있을것 같아요 ㅎㅎ 구독하고 있는 곳에서 해당 상태를 보고 업데이트 하는 패턴이니까요. 여러 구현방법이 있다고 봐주시면 될 것 같습니다 ㅎㅎ\n\n> 고민: 아무런 조건이 없는 상태의 모든 데이터에서 먼저 검색값으로 필터를 건 후, 필터옵션을 걸어야 하나요?\n\n실제 현업에서의 이야기라면, 이런 필터링 구현들은 FE사이드에서 하기보다는 BE 사이드의 도움이 있어야 어느정도 아름다운 처리가 가능할 것 같아요. 만약 FE 측에서 처리를 해야 한다면, 대량으로 어느정도 데이터를 로드해놓거나, 워커를 사용하거나 등등 최적화 방식들이 필요할 것 같습니다.\n\n> 고민: getProduts()에는 이미 limit=20 있는데 이것을 없애면 되나요?\n\n보통 이런 구조에서는 json에 total 값이 담겨있는데, 이 부분은 혹시 확인해보셨을까요!?\n\n> → 원하는 조건에 맞게 잘 실행이 되고 있는 것인지 어떻게 확인할 수 있나요? → 원하는 조건에 맞게 잘 실행이 되고 있는 것인지 어떻게 확인할 수 있나요?\n\n이 부분은 질문이 조금 모호한데요! 아무래도 첫번쨰 질문은 정성적인 평가일 것 같고, 테스트 조건으로 되어있으니 테스트 코드에서 해당 부분을 검증하는게 있는지 찾아보셔도 좋을것 같아요.\n\n고생하셨고 다음 주도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/53"
    }
  },
  {
    "passed": false,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "박용태",
    "feedback": "오전에는 뭔가 채우고 계신것 같아서 멈췄는데 오후에 보니 새로운 내용이 많이 생겼네요 용태님 ㅋㅋㅋㅋㅋㅋ\n고생하셨습니다. 회고를 보면 굉장히 많은 고민을 해주셨던것 같은데, 저도 보면서 많은 것들을 배우게 되는 것 같네요. 이 내용을 잘 정리해서 블로그 글로 한번 잘 만들어보고 진짜 끝까지 잘 완성시켜봐도 좋을것 같네요 ㅋㅋ\n아쉽게 합격 조건이 배포된 링크에서 모든 기능이 정상 동작하는 것 + 테스트 불합격이라 제가 불합격을 선택할 수 밖에 없는게 너무 아쉽긴하네요.\n\n> Q) 추천해주실만한 책이 있으신가요~~?\n\n아키텍처 관련해서는 개인적으로 무턱대고 책을 읽기보다는.. FSD에 대해서 이번에 공부를 하게 될거니까 그 부분에 대해서 왜 이렇게 나누지를 좀 더 깊게 고민을 많이 해보시면 좋을것 같구요. 이 고민을 그대로 갖고와서 클린아키텍처가 어떤 이야기를 하는지 보고 이걸 FE에서 어떻게 풀려고 했는지 FSD에 대해서 다시 한번 살펴보면 꽤 좋은 흐름이 될 것 같아요! 저는 클린 아키텍처에 대해 아무 배경지식 없이 보다가 관련된 고민들을 많이 하고 다시 읽으니 완전 새로운 책이더라구요. 이미 잘 알고계시다면 바로 보셔도 좋지만..!\n\n> 1) PR에 남긴 제 작업과정에서 개선할 부분이 있을까요?\n\n저는 지금의 흐름이 매우 좋다고 생각하는 편인데요. \n'물론 실제 업무와 이런 학습성 작업의 접근 방식은 다르긴 합니다만, 자꾸 이런 접근이 반복되고 사서 고생을 하는 것 같습니다.' 이렇게 남겨주셨으니까요!\n개인적으로는 지금의 주제가 많은 부분들에 대해 새로운 것들을 시도하는데 굉장히 도움이되는 주제라고 생각해요. 어떻게 보면 과제가 불합격이되고 아쉬운 부분들도 있겠지만, 결국 남는건 이런 경험이고 저는 이런 경험을 전혀 뜬금없는데서 활용하는 경우들도 많이 있었거든요. 기록으로 잘 남긴다면 나쁘지 않다고 생각합니다.\n그럼에도 고민해볼법한건 과제를 관통하는 또는 일을 관통하는 목적이나 주제를 항상 되짚어 보는건 필요한거같아요. 왜 이걸 공부하고 왜 이걸 하는지가 결국 제일 중요하다고 생각하기 때문에 이런 부분에서 질문을 자주 해보는건 좋지 않을까 싶습니다! \n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박지영",
    "feedback": "안녕하세요 지영님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\nQ1) main.js의 이벤트 핸들러 구조 개선 방안\n\nA1)\n무엇이 더 좋다/나쁘다기 보단.. 장단점이 있다고 생각해요 ㅎㅎ\n지금과 같은 규모의 프로젝트에는 이벤트를 모아서 관리해도 충분합니다.\n\n그런데 페이지가 많아지고, 관리해야 하는 이벤트가 많아질수록 흐름을 분석하기가 어려울 수 있겠죠?\n그럴 때에는 말씀해주신 것 처럼 도메인별로 관리하는 방법도 있을 것이고\n혹은 이벤트가 트리거 되어야 하는 UI의 코드와 가까이에 두는게 관리하기 편할 수 있답니다.\n\n전문 용어(?)로 응집도를 높이는거죠.\n\n---\n\nQ2) 라우터의 경로 정규화 로직\n배포 환경(GitHub Pages)에서 BASE_URL이 /front_7th_chapter2-1/처럼 서브 경로일 때를 대응하기 위한 로직인데, 더 간결하고 명확하게 작성할 수 있는 방법이 있을까요?\n\nA2)\n구현된 방식을 보니까 아예 basePath를 제거(?) 하는 방식으로 만들어주셨군요 ㅎㅎ\n이런 방법도 좋고, 혹은 push를 하는 등 모든 과정에서 basePath를 붙여서 사용하는 방법도 있습니다.\n이 부분은 솔루션 코드를 참고해주시면 좋을 것 같아요!\n\nhttps://github.com/hanghae-plus/front_7th_chapter2-1/blob/solution/src/lib/Router.js\n\n---\n\nQ3) 상태 관리가 필요한 데이터의 기준\n현재 장바구니는 전역 store + Observer 패턴 + UI 자동 업데이트로 관리하고 있습니다. 그렇다면 다른 UI 데이터들도 모두 이런 방식으로 관리해야 할까요?\n\n- 상품 데이터 (product): 현재는 API 호출 후 바로 렌더링하고, productCache에만 저장합니다. 이것도 productStore로 만들어서 상태 관리를 해야 할까요?\n- 검색/필터 조건: URL 쿼리 파라미터로 관리 중인데, 이것도 별도 store가 필요할까요?\n- 무한 스크롤 상태: infiniteScrollState 객체로 관리 중인데, 이것도 Observer 패턴이 필요할까요?\n- 모달 열림/닫힘 상태: 현재는 DOM 조작으로만 처리하는데, 상태로 관리해야 할까요?\n모든 수정 가능한 UI 데이터를 Observer 패턴으로 통일하는 것이 좋을까요?\n어떤 데이터를 상태로 관리하고, 어떤 데이터는 그냥 두어야 하는지 기준이 궁금합니다.\n\nA3)\n- 상품 데이터: store로 관리하는 방법도 있다고 생각합니다 ㅎㅎ 어쨌든 렌더링에 필요한 데이터니까요!\n- 검색 필터 조건: URL 상태 자체를 별도의 상태라고 생각해보면 어떨까요!?\n- 무한 스크롤 상태: 스크롤 상태가 렌더링과 동기화 되어야 한다면, Observer로 만들어야겠죠? 지금 당장 동기화해야할 내용이 없다면 관리하지 않아도 무방하답니다.\n- 모달: 지금은 모달 한 개만 관리해서 큰 이슈가 없을 것 같은데요, 여러 개의 모달을 관리한다거나 한 화면에 모달이 여러 개 오픈되어야 하는 등의 요구사항이 있다면 상태를 기반으로 관리하는게 수월할 수 있답니다!\n\n상태로 관리하는 기준은 \"UI에 동기화되어야 하는가\" 라고 생각해요. UI에 표현할 필요가 없거나 표현이 어렵다면 굳이 상태로 만들지 않아도 무방하죠.\n\n---\n\nQ4)상품 데이터 관리 (중복 API 호출 문제)\n\n동일한 상품 데이터인데 API 조회가 너무 많이 발생합니다.\n- 홈 페이지에서 상품 목록 조회 → API 호출\n- 상품 상세 페이지 이동 → 같은 상품인데 또 API 호출\n- 뒤로가기로 홈 페이지 복귀 → 또 API 호출\n- 관련 상품 표시 → 이미 본 상품들인데 또 API 호출\nproductStore를 만들어서 한번에 관리하는게 좋을까요??\n(스터디 환경이라 데이터가 변동이 없는거고, 실제 환경이면 데이터 변동이 있으니 매번 호출해야 할까요?)\n\nA4)\n보통 이럴 때에는 api에 캐시를 해서 사용하는 편이랍니다. 특히 tanstack-query 같은 라이브러리를 사용하면 캐싱 정책을 무척 상세하게 설정할 수 있어요.\n\n가령, 이런 느낌?\n\n```\nimport { getProducts as originGetProducts } from '../api/productApi'\n\nconst getProducts = withCache(originGetProducts)\n```\n\nwithCache를 통해 함수의 결과를 캐싱하여 재사용하는거죠. withCache 내부는 어떻게 생겨야 좋을까요!? 한 번 고민해보시면 좋겠어요.",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/45"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "안녕하세요 창수님! 과제를 다 진행하기에는 시간이 많이 부족했군요 ㅠㅠ\n5주차 과제는 잘 진행할 수 있기를 바랍니다! 고생하셨습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "형우님 고생하셨어요!\n필요한 기능도 잘 구현하셨고 테스트도 잘 통과하네요!\n실제 구현 코드에서는 잘 나누셨지만, 공통적이게 만들 수 있는 코드들은 묶어서 관리했으면 좋겠고 실제 리액트처럼 상태를 어떻게 관리하는지 라우터는 어떻게 할지 고민을 좀 더 해봤으면 좋았을 것 같아요!\n\n> 개발자적 전체적 흐름을 공부할 수 있는 책이 있다면 추천해주세요.\n\n우선 이런 전반적인 부분에 대해 공부를 하고 싶으시다면, 만들어보는게 제일 좋은데요. Node.js 또는 Nest.js를 활용해서 (또는, Next.js에 서버 관련 기능들을 가볍게 붙여보면서) 쇼핑몰에 기능을 한번 붙여보는건 어떠신가요?\n쇼핑몰 자체가 굉장히 기능이 많고 개발자들이 고민할만한 다양한 (그리고 가장 중요한) 주제들이 많이 담겨있는 주제거든요.\n흐름을 공부하고 적용을 해보기보다는 직접 부딪히면서 필요한 부분들을 찾아가시는걸 저는 개인적으로 추천드립니다. 그리고 가장 가까운, 구축하기 쉬운 도구들을 통해서 시작하시면 좋을 것 같아요. (그래도 어렵거든요)\n\n아니면, 서버 컴포넌트나 SSR을 적용한다는 관점에서 필요한 BFF, 인프라 등을 먼저 공부해보는것도 매우 효과적인 좋은 방식이라고 생각이 듭니다. 너무 한번에 멀리 나가지 말고 차근차근 익숙한 지점부터 확장해나가면 도움이 될 것이라 생각합니다.\n\n고생하셨고 다음주 과제도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://hyeongwoo94.github.io/front_7th_chapter2-1/"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "희정님 수고하셨습니다.\n\n작업해주신 내용은 있으시지만,\nCI 빌드가 모두 fail이네요 ㅜㅜ\n\n이번에 과제 양도 많고 조금 힘드셨었죵.\n멘토링때 말씀드렸듯 진행해야할 것들은 따로 체크리스트를 만들어두시고 솔루션 코드를 통해\n배우시면서 다시 복습 꼭 해주시면 좋을 것 같습니다!\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "안녕하세요 승현님! 4주차 과제 어려웠을텐데 잘 진행해주셨네요. 고생하셨습니다!\n\n특별하게 리뷰 받고 싶은 내용이 없는 것 같아서, 피드백은 바로 마무리하겠습니다.\n추후에 궁금한점이 생기면 언제든 디스코드를 통해 문의 주세요!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/28"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "수빈님 수고하셨습니다.\n\n작업해주신 내용은 있으시지만,\nCI 빌드가 모두 fail이네요 ㅜㅜ\n\n이번에 과제 양도 많고 조금 힘드셨었죵.\n멘토링때 말씀드렸듯 진행해야할 것들은 따로 체크리스트를 만들어두시고 솔루션 코드를 통해\n배우시면서 다시 복습 꼭 해주시면 좋을 것 같습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/39"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "안녕하세요 소은님! 4주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n---\n\n> JSX 작업을 시작하면서 리액트의 fiber tree에 대해 조금 찾아봤었는데 잘 이해가 되진 않아서 적용은 못 한 것 같습니다. 특히, fiber tree가 어떤 문제를 메인으로 해결하는 것인지를 잘 이해하지 못 했습니다. 혹시 알고 계신 내용이 있으신가요??\n\n저도 기억이 가물가물한데, fiber가 생기면서 달라진 점은 \"렌더링 우선순위\"를 결정할 수 있게 되었다는 점입니다.\nFiber 자료구조에 렌더링과 관련된 다양한 정보를 저장해놓고, 렌더링이 시작되는 시점에 fiber에 있는 정보를 토대로 \"어떤 구간부터 렌더링을 시작할 것인가\"와 \"어떤 것을 먼저 처리할 것인가\"를 선정하는거죠!\n\n> JSX를 개발하는 과정에서 코드의 흐름을 파악하는 게 생각보다 어렵다는 느낌을 받았습니다. JSX -> 함수로 변환해주는 과정이 추상화 되어 있어서 그런 것일까 생각도 해보았는데요, 혹시 비슷한 어려움을 느낀 적이 있으신 지, 어떤 방법으로 도움을 얻으셨는 지 궁금합니다.\n\n맞아요. 어려운게 당연하답니다 ㅎㅎ 저의 경우... 저도 쉽진 않은데, 그나마 이를 극보할 수 있는 방법은 \"여러번 보는 것\" 이라고 생각해요. 저희는 리액트 같은 UI 라이브러리를 운영하는 사람들이 아니기 때문에 이게 익숙하지 않은게 당연해요.\n다만 UI 라이브러리의 메인 개발자가 된다면 매일매일 이런 코드를 보고 분석하고 개선해야 하기 때문에, 당연히 흐름을 잘 익힐 수 밖에 없겠죠?\n\n> 렌더링 과정에서 queueMicrotask나 delay(1)과 같이 타이밍 조절을 하는 코드가 조금 남발된 것 같다는 생각이 드는데, 현재 불필요하게 사용하고 있는 부분도 분명히 있을 것이라 생각되는데, 사실 어떤 기준으로 이를 최적화 해야 할 지 조금 어려운 것 같습니다. 참고할만한 팁이 있을까요?\n\n공통 라이프 사이클을 설계하면 해결될 수 있는 문제라고 생각해요.\n이번주차 솔루션 참고해보시면, withBatch 라는 함수를 토대로 렌더링을 모아서 처리하고 있는데요\n중요한건 \"어떤 시점에 무엇을 실행할 것인가\"에 대한 공통 설계가 필요하다는 점입니다!\n\n> useRouter가 너무 이상한 방식으로 구현되어 있습니다. Router 컴포넌트가 사용하는 useInternalRouter 훅에서 window.__router라는 변수를 만들어서 useRouter() { return window.__router }와 같이 쓰고 있는데, 이걸 useGlobalState도 써보고, 이것저것 다양한 방법으로 시도해보았는데 결국 안 되어서 이렇게 사용하고 있습니다 ㅜㅜ Context API를 구축하면 될 것 같기도 한데, Context API는 어떻게 구현해야 할 지 감이 잘 오지 않습니다...(사실 이 문제와 Context API를 구축하는 문제가 동일한 문제라고 생각) 방향을 잡을 수 있는 팁이 있을까요?\n\n흠.. 꼭 useRouter 같은걸 만들어서 처리할 필요가 있을까!? 라는 생각이 들기도 하네요 ㅎㅎ\nreact에서는 useSyncExternalStore 같은 훅을 사용해서 외부 상태를 관리하는 편인데요,\nuseSyncExternalStore 내부를 들춰보면 useState에서 시작을 해요. (아마도!?)\n\nContext 구현하는 방법의 경우 과제 QnA 시간에 질문 주시면 답변 드려보도록 하겠습니다!\n고생하셨습니다 소은님!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "재현님 고생하셨어요~\n구현해야하는 많은 내용들이 있었음에도 잘 해내주셨네요 :+1\n멘토링 시간에 걱정을 많이 하셔서 궁금했는데 걱정에 비해 잘 해주셨네요 ㅎㅎ\n말씀해주신것처럼 코드들에 강하게 한 파일에 많은 책임이 모여있고, 좀 더 분리할 수 있는 내용들이 있는 것으로 보이네요! 하나의 함수로 합칠 수 있는 부분들도 보이구요. 요런 부분 잘 찾아서 해보시면 좋을것 같아요 ㅎㅎ\n\n> 이번 과제에선 어떤 React 개념에 대해 학습하기를 목표하셨는지 궁금합니다 !\n\n이건 준일님에게 한 번 더 여쭤보시는게 정확할 수 있는데요. 제가 이 과제를 보고 생각했던 것들을 나열해보면.. 상태를 어떻게 관리할지, 그 상태를 통해 렌더링 파이프라인을 어떻게 만들 수 있을지, 라우팅 구조에 대해 어떻게 이해하고 접근할 지 등이 중심이 된 것 같고 거기서 파생되는 여러 구현 방식, 실제 리액트 또는 비슷한 역할을 하는 라이브러리들이 추구하는 철학등을 고민해보는게 목표이지 않았을까 싶습니다 ㅎㅎ\n\n다른 분들 코드도 많이 리뷰하고 참고해보시면서 이번 주차 과제 더 발전시켜보시면 좋을것 같습니다. 고생하셨어요!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "수고했어요 진성! 프레임워크 없이 SPA를 직접 만들어보면서 React가 왜 그렇게 설계되었는지 깊이 체험하는 시간이 되었기를 바랍니다.\n\n코드를 보니 컴포넌트 생명주기를 체계적으로 설계하고, Pub-Sub 패턴으로 상태 관리를 구현하면서 프레임워크가 왜 그런 선택을 했는지 잘 체험했다는 게 느껴집니다. 특히 선언형 라우터 구현에서 `extractParamNames`, `buildParams`, `matchRoute`로 책임을 분리한 코드를 AI와 대화하면서 \"선언형으로 만들면 어떻게 될까?\" 물어보는 접근 아주 좋았습니다.\n\nQ) 레이아웃 컴포넌트의 아키텍처 설계\n=> 사실 지금의 방법이 굉장히 잘못된 건 아닙니다. 독립적으로 쓰이는 부분은 현재 구조가 전체 리렌더링을 하고 있기에 동일한 컴포넌트이고 변경점이 없다면 업데이트를 하지 않는 로직을 구현해야하겠지만 그런 diff를 만들기까지는 부담이 되었겠죠. 그래서 교체 방식으로 간다면 진성이 언급했던 방향으로 별개의 레이아웃을 분리하고 중복이 되지 않도록 만드는 방향이 좋다고 생각합니다.\n\n\nQ) 클래스 기반 vs 함수형 컴포넌트, 어떤 게 더 나을까요?\n\n=> 바닐라 JS로 직접 구현할 때는 클래스 기반이 더 안정적입니다. 생명주기 메서드로 상태와 이벤트를 체계적으로 관리할 수 있으니까요. 함수형은 클로저 활용이 유연하지만 생명주기 관리가 까다롭죠. React와 같이 별도의 체계와 라이브러리와 같은 프레임워크를 제공하지 않고 바닐라 JS로만 구현해야한다면 내부적인 상태를 관리하면서 재사용이 가능한 구조는 클래스가 더 안정적입니다. 무엇보다 컴포넌트는 스스로의 상태를 가져야 하는 객체지향적 개념이니까요.\n\n다만 자바스크립트가 완전한 객체지향이 아닐 뿐더러 문법적으로 클래스가 가독성이나 관리하는데 용이하지 않고  DOM을 다루는 방식이 관리를 어렵게 만들었습니다. 그래서 React도 처음에는 class방식으로 만들었다가 함수형과 훅이라는 개념을 등장하면서 훨씬 문법적으로 나아졌습니다. 나중에 이러한 DX를 만들기위해 React의 Hooks가 어떻게 이 문제를 해결했는지 비교해보면 좋을 겁니다.\n\n\"프레임워크 없이 직접 구현하면서 내부 동작 원리를 이해하게 되었다\"는 말이 이번 과제의 핵심이었죠. 이제 다음 시간에는 React는 이러한 현실에서 어떻게 함수형 컴포넌트에서 상태를 관리할 수 있는 객체지향적 개념을 섞어낼수 있었는지 `useState`가 왜 필요한지, `useEffect`가 어떻게 동작하는지 훨씬 명확하게 보일 거예요. 수고많았습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/2"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "안녕하세요 새듬님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제까지 하기에는 시간이 많이 부족했던 것 같군요 ㅠㅠ\n\n특별하게 리뷰 받고 싶은 내용이 없는 것 같아서, 피드백은 바로 마무리하겠습니다.\n추후에 궁금한점이 생기면 언제든 디스코드를 통해 문의 주세요!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/37"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "안녕하세요 태준님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제까지 하기에는 시간이 많이 부족했던 것 같군요 ㅠㅠ\n\n> URL 쿼리 파라미터로 모든 상태를 관리하는 것이 약간은 부담스럽게 느껴졌습니다. 복잡한 필터 조건이나 모달과 같은 상태도 URL에 포함시키는 것이 좋은 구조였는지, 아니면 일부는 메모리 상태로만 관리하는 것이 나은지 궁금합니다!\n\nURL에 포함시켜야 하는 조건은 \"주소와 UI가 동기화 되어야 하는가\" 라고 생각해요.\n\n즉, 현재 UI를 새로고침 했을 때에도 동일하게 보여줄 것인가? 에 대한 의사결정인거죠 ㅎㅎ\n이런 요구사항이 없다면 굳이 URL에 포함시키진 않아도 무방하답니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/51"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "지훈님 수고하셨습니다.\n\n다시 채점하고 피드백드립니다.~\n\nQ. 옵저버 + 싱글턴 (자랑하고 싶은 코드 1번)\n\nA. 구현하신 싱글턴은 클래스 기반의 언어의 싱글턴 같아요..\nJS는 ESM이라는 좋은 모듈 관리 기능이 있잖아요?\n애초에 굳이 클래스를 만들 필요가 있을까요?  ㅎㅎ\n다시 한번 생각해보시면 좋을 것 같습니다! \n힌트. 모듈 스코프에 상태를 두고 함수를 export.\n\nQ. 이벤트 리스너 타겟\n\nA. 문제 없습니다. window나 document 즉 최상위 부모에게 이벤트를 위임하는 방식 실제로 리액트가 사용하고 있는 방법이에요.\n등록되어 실행되어야할 함수의 갯수는 어차피 동일할것이기 때문에 성능상의 이슈는 전혀 없습니다.\n말씀하신 초기화 문제는 다른 이슈일 것 같습니다 :) ",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/47"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "안녕하세요 예인님! 4주차 과제 진행하느라 고생하셨습니다! 다만 과제를 다 진행하기에는 시간적 여유가 많이 없었나보군요 ㅠㅠ\n\n---\n\n> 지난 번 주제 때 이전 주차에서 배운 개념을 활용해야 하는데 학습한 내용이 없다보니 따라가기 벅찼어서.. 남은 주차 과제를 하기 위해서 어떤 개념을 학습하면 좋을지 궁금합니다\n\n아마 5주차 과제도 자바스크립트의 다양한 지식 (클로저, 실행컨텍스트, 자료구조, 알고리즘 및 기타 등등..) 이 필요할 것 같아요. ko.javascript.info 에 올라온 내용들을 차근차근 살펴보면 좋답니다!\n\n클린코드 주차의 경우 기본기보다는 \"코드 자체에 대한 이야기\"가 많기 때문에 발제에서 제시하는 내용을 차근차근 따라가도 무방하답니다 ㅎㅎ\n마지막으로 성능 최적화 주차의 경우\n\n9주차는 SSR과 SSG에 대해 다룰 예정이라서, 개념 정도는 확실하게 숙지하시면 좋고\n10주차 과제는 React 로 작성된 어프릴케이션의 성능 최적화를 하는 과제라서, 메모이제이션에 대한 개념을 잘 알고 있으면 좋답니다!\n\n고생하셨어요 예인님!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/49"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "고생하셨습니다 윤지님!\n테스트 잘 통과하셨고 필요한 기능 잘 구현하셨는데요!\n무한스크롤로 하단 상품의 상세보기를 클릭한 뒤에 다시 뒤로 돌아오면 리스트가 초기화 되는 현상이 있더라구요! \n\n* 어플리케이션 내의 모든 페이지 이동(뒤로가기/앞으로가기를 포함)은 하여 새로고침이 발생하지 않아야 한다.\n요게 제대로 구현이 안된 것 같아서 관련해서 꼭 체크해보시면 좋을것 같아요 ㅎㅎ\n\n> 1. 라이프사이클 패턴 구현의 적절성\n\n현재 구현한 방식이 크게 나쁘지는 않다고 생각하는데요. .mount()에서 데이터만 반환하고 컴포넌트가 순수하게 렌더링만 담당하는 구조는 적절하게 관심사를 분리하는 것 같아요! 라이프 사이클 같은 경우에도 더 세분화를 하기 보다는, 실제 리액트의 내부 라이프 사이클이 어떻게 되었었는지 왜 그렇게 되었었는지 고민을 더 해보면 좋을것 같습니다. \n\n> 2. Subscribe 패턴의 확장성\n\n앱의 규모가 작기 때문에 중복 구현도 괜찮을것 같아요! 라고 말씀을 드릴 수도 있는데, 학습에 목적이 있고 실제로 충분히 모듈화 해서 여러곳에서 사용할 수 있도록 모듈을 구성하는데 어려움이 없을거에요. 각 도메인별로 분리해서 상태를 관리하는 방식은 좋은 것 같고, 학습에 목적이 있으니 좀 더 범용적이게 사용할 수 있는 방식을 만들어보는 고민을 하는 것도 좋을것 같습니다. \n\n> 3. 모듈 분리 전략\n\npathMatcher.js는 저수준 매칭 로직(정규식 변환), routeMatcher.js는 라우트 배열을 순회하는 고수준 로직이니 분리를 하는게 나쁘지는 않아보여요. queryParser.js는 재사용 가능한 유틸 함수니 별도 파일로 두는 것이 좋아보임다. 파일 분리 기준은 \"단일 책임 원칙\"과 \"재사용 가능성\"으로 보면 좋을 것 같은데 이 부분은 앞으로 고민을 많이 하게 될 부분이니 더 깊게 공부해보면 좋을 것 같습니다!\n\n> 4. 이벤트 위임의 범위\n\n위임 방식은 나쁘지 않은데요. 너무 중복되는 내용이 많고 번잡스럽게 코드의 양이 늘어난다고 생각된다면 페이지별로 이벤트를 각각 분리하고 그걸 상위로 다시 전달해서 등록하는 방식으로 구현한다면 좀 더 깔끔하지 않을까 싶습니다 ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "수고했어요 정민! 프레임워크 없이 SPA를 직접 만들어보면서 상태 관리의 본질과 렌더링 전략을 깊이 체험하는 시간이 되었기를 바랍니다.\n\n회고 내용 중 상태 관리를 URL SearchParams와 CartStore로 명확히 분리한 근거를 설명하는 부분이 인상깊네요. 같은 전역 데이터가 필요한 경우더라도 \"검색 필터는 URL로, 장바구니는 Store로\"라는 설계에 대한 근거를 대는 부분이 좋았습니다. URL로 관리하면 새로고침 시 자동 복원되고 브라우저 히스토리도 자연스럽게 동작하죠. 반면 장바구니는 사용자의 앱 내부 상태이기 때문에 localStorage 기반의 지속적 저장이 필요하다는 통찰, 맞습니다. 같은 개념이더라도 상황에 따른 더 나은 방법을 선택하고 특히 그 근거를 들어 설명할 수 있다는 점이 아주 중요합니다.\n\n전체 렌더링과 부분 렌더링을 구분해서 구현한 것도 좋았습니다. 처음에는 `renderToRoot()`로 전체를 갈아엎는 방식으로 시작했다가, 검색할 때마다 화면이 깜빡이고 포커스가 사라지는 문제를 겪으면서 `renderTo()`를 추가해 특정 영역만 업데이트하도록 개선한 과정. 이게 바로 React가 왜 가상 DOM을 만들었는지, Vue가 왜 반응형 시스템을 택했는지 이해하는 출발점입니다. 프레임워크들도 결국 같은 문제를 해결하기 위해 각자의 방식을 선택했거든요.\n\n**Q) 이벤트 위임 방식보다 더 좋은 방법이 있을까요?**\n\n=> 사실 이벤트 위임 자체는 좋은 패턴입니다. 동적으로 추가되는 요소에도 이벤트가 작동하고, 메모리 효율도 좋죠. 지금 설계의 문제는 모든 이벤트를 한 곳에서 처리하려다 보니 서로 영향을 주지 않는 코드가 한 곳에 있어서 복잡하게 느껴지는 것입니다. 설계에서 중요한 것은 서로 영향이 없다면 같은 자리에 두지 않는다에요.\n\n개선 방향은 **컴포넌트 단위로 이벤트를 분리**하는 겁니다. 각 컴포넌트(ProductCard, SearchForm, CartModal)가 자기 영역의 이벤트를 직접 관리하도록 하는 거죠. 렌더링 후 해당 컴포넌트에 이벤트를 바인딩하고, 리렌더링 시 재등록하는 방식입니다.\n\n이미 React를 쓰는 동안 익숙한 방법이죠? React 도한 이벤트 위임 방식으로 구현되어 있지만 각자의 컴포넌트에서 이벤트 등록을 하고 있죠. 다음 시간에는 React는 실제로 이러한 방식을 어떻게 활용했을지 파악해볼 수 있는 시간이 되길 바래요\n\n수고많았습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/11"
    }
  },
  {
    "passed": false,
    "name": "이현지",
    "feedback": "현지님 수고하셨습니다.\n\n이번 과제는 완수율이 떨어지는데 \n그래도 현지님은 회고까지 작성해주셨네요!! 수고하셨습니다.\n자만 ci가 fail이라 불합을 드릴수밖에.....ㅜㅜ\n\nCI에서 빌드가 깨지는건 보통 어이없는 이유인 경우가 많아요.\n경로문제(절대경로나 상대경로), 아니면 파일명의 대소문자 구분등등 다양한 원인이 있을 수 있는데욥.\n이런건 한땀한땀 디버깅을 해봐야하기때문에 나중에 솔루션 코드하고 비교해보시면 좋을 것 같아욥.\n\n넵 솔루션 코드를 보시면서 부분부분 분석해보세요. 그래서 일관성을 찾아보세요. 그리고 그 일관성이 어플리케이션에서 어떤 의미를 가지고 있는지 생각해보세욥\n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/50"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전이진",
    "feedback": "안녕하세요 이진님! 4주차 과제 쉽지 않았틀넨데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 아 따봉리액트야 고맙다\n\nㅋㅋㅋㅋㅋ 저도 따봉 하나 추가합니다\n\n> 리팩토링할 때마다 테스트 코드 있어서 정말 다행이다 라는 생각이 듭니다. 처음에는 하나하나 통과시키기에 여념이 없었는데 이후에 구조를 바꾸고 개선도 하는데에 있어 테스트 코드가 안전망 역할을 해주었습니다 ㅠ.ㅠ 종종 테스트 깨짐에 대한 디버깅을 하긴 해야하지만 그런 불편함을 충분히 감수할 수 있는 것 같아요.\n\nㅋㅋ 테스트의 중요성을 잘 체감해주셨군요! 특히 리팩토링할 때 테스트의 효용성을 잘 느낄 수 있는 것 같아요.\n\n> 현재 상태 비교를 JSON.stringify로 처리하고 있는데, 구조적으로 더 안정적인 방법을 고민 중입니다. diff 기반 비교나 재귀적 비교로 개선하는 방안을 떠올리고 있는데, 실제로 이런 로직을 설계할 때 어떤 접근 순서로 생각을 전개하면 좋을지 궁금합니다.\n\nJSON.stringify의 경우, Set, Map 같은 자료 구조를 사용하게 되면 무조건 빈 객체로 반환하기 때문에 문제가 될 수 있답니다 ㅎㅎ\n상태 비교는 deepEqaul이나 shallowEqual 같은 함수를 직접 구현해서 사용하면 편리해요!\n아마 이에 대한 과정을 5주차 과제에서 체험해볼 수 있을 것 같습니다.\n\n고생하셨습니다 이진님~!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "[2팀 전희재] Chapter2-1. 프레임워크 없이 SPA 만들기 #7\n\n수고했어요 희재! 프레임워크 없이 SPA를 직접 만들어보면서 React가 왜 그렇게 설계되었는지 깊이 체험하는 시간이 되었기를 바랍니다.\n\n코드를 보니 함수형 컴포넌트 패턴을 클로저로 구현하면서 생명주기를 체계적으로 설계하려는 시도가 인상깊었어요. 아마 왜 초창기 프레임워크들이 모두 접근방식을 함수형이 아니라 클래스로 했을지 이해가 되지 않았을까 생각해요. 분명 함수형으로 작성을 하면 훨씬 가독성 측면에서는 뛰어나지만 내부 상태관리나 UI만 관리를 한다는게 참 쉽지 않거든요. 이로써 React는 이러한 과정을 어떻게 해결했을까? 하는 고민을 이번 과제때 제대로 느껴볼 수 있겠네요.\n\n희재의 자기반성과 성찰이 가득한 회고가 너무 좋았어요. 과제를 잘하고 못하고 보다고 과정안에서 내가 어떤 과정을 거쳤고 어떤 시도와 문제 그리고 고민이 있었는지를 잘 볼 수 있어서 아주 좋았습니다. 자신의 맥락을 구체적으로 전달한다는 것은 개발자에게 정말 중요한 스킬이니 지금의 회고는 너무 잘 작성했어요!\n\nQ) 부모-자식 컴포넌트 렌더링 구조 개선안\n\n희재가 겪은 문제의 핵심은 \"자식 컴포넌트가 부모 render()에 종속되면서 라이프사이클 독립성을 잃었다\"는 거죠. 맞아요. 각자 컴포넌트 렌더링은 스스로에게 있는데 부모 렌더링에 자식을 렌더링 기능을 기술해야 하다보니 문제가 생긴것이죠.\n\n사실상의 정답으로써 React의 방식은 컴포넌트를 함수화 하고 결과값을 렌더링이 아닌 값으로 만들게 해서 부모가 렌더링시 자연스레 자식의 함수호출을 통해 최종적인 값을 생성해서 부모가 렌더링이 되면 자식도 함께 props와 함께 렌더링이 되고 자식이 업데이트가 필요할땐 스스로 업데이트를 하도록 구분한거죠.\n\n희재의 구조에서 만들고 싶었다면 렌더링을 하는 과정을 내부로 추상화해서 숨기고 자식 컴포넌트를 template에서 약속된 방식으로 렌더링을 하거나 교체할 수 있는 방법을 만들어야 합니다. 다만 이 경우 템플릿은 문자열이고 컴포넌트는 객체인데 렌더링을 섞어 넣으려고 하면 지금의 문자열 구조를 DOM으로 바로 그리려고 하면 매우 복잡해 진다는 거에요.\n\n다음 시간에 React가 해결한 부분인 DOM과 문자열로 직접 사용하는 것이 아닌 별개의 데이터 구조를 만들고 DOM 렌더링과 DOM의 구조의 변경이라는 부분을 값으로 분리해서 처리한 방법이 어떤 것인지 잘 이해할 수 있을거에요. 현대의 대부분의 에디터, figjam, notion등의 복잡한 구조들은 DOM을 직접 수정하는것이 아니라 별도의 데이터 구조를 만들어두고 렌더링 엔진을 만드는 방식으로 구성이 된답니다.\n\n\nQ) 프레젠테이션과 상태 관리 계층 분리 단순한 UI 조각은 문자열 렌더러로, 상태가 필요한 부분만 컴포넌트로 나누는 방식이 맞는지 확인하고 싶습니다. 이렇게 하면 어떤 이점이 생기고, 실제로 어디까지를 프레젠테이션으로 분류해야 할까요?\n\n=> 초기 프레임워크들은 지금의 구조처럼 문자열을 바탕으로 일부를 수정하거나 혹은 DOM의 구조를 그대로 이용한채로 상태의 변경에 따라 DOM을 변경하는 방식으로 구현했습니다. 이렇게 하면 매우 가벼우면서도 효율적인 구조를 가질 수 있으나 DOM구조와 실제 컴포넌트 구조가 달라지는 Portal 기능이나 서버사이드 렌더링과 같이 문자열로 렌더링을 하는 등 DOM 구조에 의존하지 못하는 경우가 생겨나죠. 그래서 그냥 DOM 전체의 구조를 하나의 객체로 관리하는 방식으로 다루는게 훨씬 낫다는 것을 알게 됩니다. 그래서 여러가지로 고민하지 말고 그냥 일관된 형태 그리고 단순한 Node의 결합으로써 데이터를 표현하죠. 희재의 방식은 템플릿이 정해져있고 변화가 많지 않다면 훨씬 가벼운 방식으로 처리할 수 있는데 여러가지 유연성을 담보하기가 어렵습니다. React가 결국은 라이브러리의 비용이 비싸고 더 느림에도 쓰는건 일관성있는 구조로 인해 같은 방식으로 여러 환경에서 상용할 수 있다는 점이죠.\n\n수고 많았습니다. 다음 과제를 하면서 궁금했던 내용들의 호기심들을 가득 채워갈 수 있는 시간이 되길 바래요. 화이팅입니다\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/7"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정나리",
    "feedback": "수고했어요 나리! 프레임워크 없이 SPA를 직접 만들어보면서 아키텍처 설계의 본질을 깊이 체험하는 시간이 되었기를 바랍니다.\n\n회고를 보니 이번 과제를 정말 구조 설계 중심으로 접근했다는 게 느껴집니다. \"어떤 구조로 설계하면 좋을까?\"를 최대한 고민했다는 시작점부터 인상깊었어요. 특히 \"라우터의 역할은 특정 path에 따른 UI 보여주기\"처럼 각 모듈의 책임을 명확히 정의하고, react-router-dom을 참고해 인터페이스를 먼저 설계한 접근이 훌륭했습니다.\n\n특히나 피상적인 소프트웨어 공학의 개념적인 부분 - 디자인 패턴, 옵저버 패턴, 클로저, 상태관리 - 등등을 구현을 통해 실체화 하는 과정에서 막연한 이론적 기반들을 몸으로 체득하는 경험이 중요한 데 좋은 시간이 되어준 것 같아요.\n\n**Q) 혹시 코치님이라면 해당 과제를 어떤 방식으로 진행하셨을지 궁금합니다.**\n\n=> 정답은 없겠지만 제가 예전에 프레임워크를 만들어봐야겠다 생각했던 것들은 실제 현업에서 쓰이고 있는 여러가지 라이브러리들을 참고해 우선 이렇게 만들어서 워킹하면 좋겠다하는 최소한의 코드 구조를 만들고, \n\n```\n<div @click=\"handleInc()\">\n\n<script>\nconst scope = {count: 0}\n\nfunction handleInc() {\n  scope.count += 1\n}\n\ncreateApp(\"#root\", scope)\n</script>\n```\n\n그런 다음 위와 같이 동작하기 위한 가장 단순한 코드를 만들어가면서 조금씩 조금씩 확장해다가 새로운 기능이 필요해지는 순간 다른 라이브러리의 여러가지 Usage를 보면서 이런 인터페이스면 DX가 좋겠다 생각하며 구조를 만들고 그걸 구현이 되도록 하면서 만들어갔습니다. 나리가 react-router-dom의 인터페이스를 참고한 것처럼요. \n\n설계를 분명 먼저하겠지만 전체를 설계하는게 아니라 우선 지금보다는 좀 더 나은 코드의 모양을 먼저 만들어보고 이런 모양이면 정말 좋겠다를 최소한으로 확장하면 구현해서 검증을 해보고 불가능한 인터페이스라면 최소한의 수정들을 통해서 검증가능한 최소한의 설계구현이라는 과정을 점진적으로 반복했어요. 저는 실전이라면 이 방법을 추천합니다.\n\n그렇지만 이 과제는 최종 완성이라는 목표가 있기에 점전적으로 한다고 해도 완성을 해야 통과이기에 이미 나와있는 답안지(?)를 바탕으로 일단 완성해두고 내 입맛에 맛게 조금씩 리팩토링으로 개선하는 방향으로 했겠다 싶네요.\n\n\n**Q) 컴포넌트 마운트/언마운트를 상단에서 관리하는데 이벤트 핸들러도 그 생명주기로 관리하지 않는 이유가 잘 이해가 되지 않습니다**\n\n=> 좋은 질문입니다. React의 Synthetic Event System은 사실 성능 최적화보다는 **일관성**이 더 큰 이유예요. React는 아주 오래전 유물이고, 과거 브라우저들은 각각의 표준 객체들의 스펙들이 미묘하게 달랐습니다. 특히나 이벤트가 그랬죠. React는 이걸 통일된 인터페이스로 제공하려고 최상단에서 관리했습니다.\n\n또한 이를 컴포넌트 생명주기에 넣으면 각 컴포넌트가 마운트/언마운트될 때마다 이벤트를 등록/해제해야 하는데, Synthetic Event는 한 번만 등록하고 내부적으로 라우팅만 바꾸는 방식이라 효율적입니다. 근데 메모리를 쓰는 방식이고 래핑을 해야 하는 방식이니 Preact라는 신규 프레임워크에서는 직접 핸들러를 쓰는 방식으로 변경해서 속도를 높인 사례도 있죠. 컴포넌트 마운트 언마운트가 많아질 경우 대비 메모리를 관리측면에서 React가 더 효율적이랍니다. 사실 React는 속도를 다소 희생하고 DX와 안정성과 일관성을 챙긴다는 원칙으로 설계되었어요.\n\n다음 과제에서는 React가 실제로 어떻게 구현을 했을지를 가늠해볼 수 있는 재미난 과제가 될거에요! 많은 의문들이 해소가 되면서 깊이 있는 지식들을 익혀가기를 바랍니다! 수고 많았습니다 :)\n\nBP(Best Practice) 선정 이유:\n\nRouter, Component, Event, Store등을 구현한 코드가 복잡함 없이 간결하면서도 핵심적인 core 로직들로 잘 구성해서 만들었다는 점에서 BP로 선정하였습니다.",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/10"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "안녕하세요 한슬님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 시간이 조금 모자랐나보군요 ㅠㅠ\n\n---\n\n지금은 필요한 데이터를 수동으로 하나하나 구독하고 있는데,\n이걸 자동으로 어떻게 구독할 수 있을지도 고민해보시며 좋답니다!\n\n참고 자료: https://junilhwang.github.io/TIL/Javascript/Design/Vanilla-JS-Store/\n\n고생하셨어요 한슬님!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/30"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "민수님 고생하셨습니다~\n필요한 기능도 잘 구현하셨고 테스트 코드도 잘 동작하네요.\n심히 괴로운(?) 상태로 인지하고 계신 main.js에서는 사실 좀 더 추상화해 함께 할 수 있는 코드들을 분리하고 관리할 수 있을 것처럼 보여요.\n너무 많은 일을 한 곳에서 많이 해주고 있는 것처럼 보입니다!\n추후에 여유가 있다면 꼭 이 부분에 대해서 개선을 해보시면 좋을것 같아요. \n\n> 현재 클릭 이벤트 등 ui에 부착되는 이벤트들을 main.js 안에 모두 모아 둔 상황입니다. 굳이 이걸 분리시키지 않은 이유는 첫째로 모두 root에 접근해서 이벤트를 붙이기 때문에, 각 컴포넌트 내부로 가져가는 것 보다 한자리에 모아두는 것이 이벤트의 중복이나 잘못된 부착 등을 막는데 더 효과적이지 않을까? 싶은 생각이 들었기 때문이었습니다. 그러나 코드의 상태가 심히 보기 괴롭습니다. 지금처럼 이벤트를 $root.addEventListener 로 붙이는 상황에서는 이런 방식이 어느정도 강제되는 것인지, 아니라면 어떤것을 기준으로 이벤트를 나누어 관리할 수 있을지 궁금합니다.\n\nㅋㅋㅋ심히 괴롭다는 표현이 왤케 웃긴지 모르겠네요. 실제 리액트도 이벤트를 각 컴포넌트에서 선언하지만, 이벤트를 위임해서 처리를 하는것처럼 위임 패턴 자체가 잘못된건 아닌것 같아요. 고민이 된다면, 도메인별 핸들러를 분리하는 과정을 거치고 루트에 위임을 시켜서 관리하는 형태로 진행하면 문제가 없지 않을까 싶습니다!\n\n고생하셨고 다음 주 과제도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/48"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "안녕하세요 재윤님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n특히 회고에 남겨주신 재윤님의 깨달음이 인상적이네요.\nuseState, useEffect 등을 어떤식으로 구현할 수 있는지 살펴보는 과정도 좋았어요!\n\n다만 리뷰 받고 싶은 부분이 없는 것 같아서 아쉽네요 ㅎㅎ 피드백은 여기서 마무리하도록 하겠습니다! 고생하셨습니다!\n\n궁금한점 생기면 어제든 디스코드를 통해 문의주세요~\n5주차 과제는 재윤님께 흥미로운 과제가 될 것 같네요 ㅋㅋ",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/38"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "진아님 고생하셨어요!\n구현 필요한 부분 잘 구현해주셨고, 테스트도 잘 통과하네요!\n회고도 너무 꼼꼼하게 작성해주셔서 과정에서 어떤것들을 학습할 수 있는지 볼 수 있어서 좋았습니다. \n전반적으로 잘 구현해주셨지만, 이름을 모듈로 짓기보다는 명확한 목적에 맞게 분리하고 코드들을 좀 더 공통화 할 수 있는 부분은 추상화 해서 관리했다면 좀 더 좋았을 것 같긴 합니다!\n\n> 제가 HomePage, ProductPage 내부에서도 event가 발생시 pageRender 함수로 화면에 렌더링할수 있게 만들고, 해당 페이지의 return 값으로 받은 pageRender를 main에서도 사용할 수 있게 만들었는데 이게 맞는 방식인지가 궁금합니다. 처음엔 eventListener를 해당 페이지에 사용하는 동작들임을 알수있게 각 페이지에서 동작되는 것들을 페이지 별로 적었습니다. 그러다보니 render를 시킬수 있는함수를 페이지 내부와 외부 두 부분에서 사용하게 되었는데 여러개의 렌더함수가 중복으로 호출된다던가 하는 문제가 발생할수도 있지 않을까 싶습니다. 그럼 이걸 하나에서 관리할수 있는게 좋을것 같기도 합니다.\n\n넵 맞습니다! 이런 함수들은 항상 add하는 곳과 remove하는 곳을 명확하게 쌍으로 관리하는게 필요한데요. 지금은 상위로 하나로 위임해 관리하고 있으니, 해당 부분에서 페이지를 이동할 때 중복되는 이벤트가 호출되지 않도록 클린업 과정을 해주는게 필요할 것 같습니다. 렌더러 함수를 분리해서 관리하는 것은 개인적으로는 좋다고 생각하는 편인데요. 말씀해주신대로 하나의 집중된 렌더러모듈에서 잘 조율을 할 수 있다면, 제어에 조금 더 쉽지 않을까 싶네요!\n\n고생하셨고 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/25"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "안녕하세요 선민님! 4주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 현재 테스트 코드를 통과하고 있지 못하고.. (ci에서 오류나서 로컬에서 돌려봤는데 그래도 실패하고 있네요 ㅠㅠ)\n\n배포도 제대로 안 된상태 같아요 🥲\n아쉽지만 불합격으로 남겨놓겠습니다..!\n\n--\n\nQ1) CartModal.js의 이벤트 리스너 관리\n\nA1)\n말씀해주신 방식으로 해도 무방하답니다 ㅎㅎ\n이벤트 위임을 통해서 관리해도 좋지만, 이벤트 위임 방식도 정교하게 관리하려고 하면 무척 골치가 아파요 ㅋㅋ\n현재 이벤트가 등록이 필요한 컴포넌트가 있을 때 이벤트를 등록해주고, 컴포넌트가 사라지면 해제하는 과정이 필요하니까요.\n\n---\n\nQ2) 이벤트 리스너 cleanup 로직\n애플리케이션이 SPA이고 페이지를 벗어나지 않는 구조라면 cleanup이 필수인지, 그리고 cleanup이 필요한 경우 어떤 패턴으로 구현하는 것이 좋은지 조언해 주실 수 있을까요?\n\nA2)\n페이지를 벗어나지 않는 구조라면 굳이 필요한가? 싶기도 해요 ㅎㅎ\n다만, 한 페이지 내에서도 이벤트가 많이 발생할 수 있어요. 가령 피그마 같은걸 생각해보시면 좋답니다.\n혹은 저희 팀에서 만들고 있는 웹빌더의 경우도 마찬가지입니다.\n\n페이지가 중요한게 아니라 얼마나 많은 컴포넌트에 얼마나 많은 이벤트가 등록되어있는지가 중요한거죠.\n\ncleanup의 경우, 컴포넌트 라이프 사이클을 설계해야 하는데요, 컴포넌트가 unmount 되는 시점에 컴포넌트에 등록된 이벤트를 다 제거하는 방식으로 관리하면 좋답니다!\n\n이벤트 위임 방식이 아니라면, 컴포넌트에 해당하는 태그가 사라지면 자연스럽게 없어지겠지만요 ㅎㅎ\n\n---\n\nQ3) 디렉토리 구조와 모듈 분리\n\nA3)\n뭔가 정답이 있다기보단, 프로젝트 규모에 따라 다르다고생각해요.\n소규모의 프로젝트에서는 기능별로 파일이 묶여있는게 좋겠지만,\n프로젝트 규모가 커지고 관리해야 하는 코드가 많아진다면 목적별로(관심사별로) 코드가 묶여있는게 좋습니다.\n\n이럴 때 판단해볼 수 있는게, \"요구사항을 추가해보는 것\" 이라고 생각해요. 임의의 요구사항을 만든 다음에 어떤식으로 해당 요구사항을 처리할지 \"시뮬레이션\"을 머릿속으로 돌려보면서 어떤 파일, 어떤 폴더를 찾아다니고 있는 살펴보는거죠.\n\n혹은 \"특정 기능에 해당하는 내용을 제거하는 방식\" 으로도 시뮬레이션을 돌려볼 수 있습니다.\n\n기능을 삭제할 때, 건드리는 폴더와 파일이 많다면 응집도가 안 좋은것이겠죠 ㅎㅎ?\n\n관리하기 좋은 코드는 응집도가 높고\n응집도가 높은 코드는 \"함께\" 움직입니다.\n\n관련 링크: https://velog.io/@koreanthuglife/%EA%B0%80%EC%9E%A5-%EC%A7%81%EA%B4%80%EC%A0%81%EC%9D%B8-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EA%B0%80%EC%9D%B4%EB%93%9C\n\n---\n\nQ4) 네이밍 컨벤션\n\n- setup*, handle*, update* 같은 prefix를 사용하는 것이 일반적인지, 그리고 일관성 있게 사용하고 있는지 확인하고 싶습니다.\n- ensureRendered() 같은 함수명이 직관적인지, 아니면 renderCartModal() 같은 이름이 더 나은지 궁금합니다.\n- 파일명에서 homepageEvents.js처럼 복수형을 사용하는 것이 적절한지, homepageEvent.js나 homepageEventHandler.js 같은 이름이 더 나은지 조언해 주실 수 있을까요?\n- 컴포넌트 파일명을 CartModal.js처럼 PascalCase로 하는 것이 일반적인지, 아니면 cartModal.js처럼 camelCase가 나은지도 궁금합니다.\n\nA4)\n- prefix에 대한 내용의 경우 클린코드 챕터에 들어가면 더 상세하게 가이드 될 예정입니다 ㅎㅎ. 어떤 prefix를 사용하는지보다 \"일관성\"이 더 중요하다고 생각해요. 전체적으로 비슷한 맥락에서 쓰인다면 프로젝트의 코드를 쭉 훑어보는 사람도 \"이런 맥락에서 쓰이는구나~\" 라고 인지할 수 있으니까요. 여튼, 지금 일관성있게 잘 쓰이고 있어요!\n- 개인적으로 renderCartModal 처럼 쓰이는걸 선호합니다! 다만 이건 개인적인 시선이라서, 함께 코드를 작성하는 사람들이 있을 때 합의가 필요해요.\n- 파일명은 그 파일 내부에 어떤 코드가 있냐에 따라 다르다고 생각해요. 여러 개의 이벤트를 만들어서 관리하고 있다면 복수형 표현이 좋을 것이고, 하나의 함수만 다루고 있다면 함수 명과 파일 명을 일치시켜야 나중에 파일을 탐색할 때 좋답니다! 그리고 저는 개인적으로 지금과 같은 상황에서는, `homePageHandlers` 처럼 네이밍할 것 같아요!\n- 컴포넌트 파일명도 위에서 언급한것과 동일합니다. 파일명과 함수명은 일치시켜야 나중에 탐색하기가 편해요!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "오호 고생하셨습니다. 역시 잘 해주셨네요.\n구조도 잘 잡아주셨고, 필요한 기능들에 대해서도 테스트에 맞춰서 잘 구현해주셨습니다. 실제 리액트 구조처럼 만들기 위해서 많은 부분을 고민하고 적용하셨던 것 같아 보이네요 :+1  \n특별하게 더 피드백을 제가 드릴만한 부분은 없는 것 같습니다. 굉장히 인상깊은 과제였어요! 다음 주도 화이팅입니다~",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "안녕하세요 챙은님! 4주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n다만 리뷰 받고 싶은 부분이 없어서 피드백은 바로 마무리 하겠습니다.\n\n추후에 궁금한 부분이 생기면 언제든 디스코드를 통해 문의 주세요! 고생하셨습니다~!",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "준태님 수고하셨습니다.\n\n피드백 업데이트 했어요~\n\nQ. 위와 같은 상황에서 각각의 자식 컴포넌트를 리렌더링 시키는 방법이 있을까요..? DocumentFragment로 가짜 태그를 만들고 해당 태그에 렌더링하거나 해야하나요?\n\nA. 사실 해당내용은 프레임웍 래밸의 구조에서 해결해야하는 수준인 것 같아욥..  DocumentFragment사용해도 되고 자식을 append하는 방법을 다른 형태로도 구현할 수 있을 것 같고욥.  우리가 만든 프레임웍 래밸에서의 컴포넌트를 자식으로 가질 수 있는 부분에 대한 구조적인 코드가 있어야 할 것 같아요. 그러려면 지금과 같은 innerHTML은 힘들 것 같고욥.\n준태님이 커스텀하게 정의한 컴포넌트의 조합을 어떻게 구현할 것인지 알 수 있는 코드가 있었다면 제가 의견을 좀 드려볼 수 있을 것 같아요 지금은 그부분을 못찾았어욥!\nBase.js에서 뭔가 그런 구현이 들아가면 좋을 것 같네욥. \n\nQ. 앵귤러, 리액트 등이 등장하기 전 바닐라 자바스크립트로 웹 사이트를 개발할 때, 이번 과제와 같이 template literal을 주로 사용하는 방식과 createElement, appendChild 등으로 DOM을 세부적으로 컨트롤하는 방식 중에 어떤 방식이 더 많이 쓰였는지 궁금합니다!\n\nA. 구조적으로 자식 컴포넌트를 조합할 수 있는 구조를 만들려면 appendChild와 같이 선언적인 코드가 아닌 명령형 코드를 자주 사용했어요.. 어찌보면 v-dom은 정말 큰 혁명이긴하죵..\n사실 앵귤러나 리액트가 등장하기 전에는 백본이라는 프레임웍이 유행이었는데요. \n프레임웍은 컴포넌트의 render()함수에서 표현하고자하는 UI를 dom형태로 만들었어 dom 리턴하게 되는데요..\n부모에서 자식 컴포넌트를 조합할때는 요 render()함수에서 자식 컴포넌트의 render()를 실행해서 리턴된 자식 컴포넌트의 dom노드를 append하는 형태로 구현했습니다.\n그런데 그시기에도 프레임웍이 워낙많아서, 그리고 오히려 v-dom이란 개념이 없었기에 더 많은 방식들이 있었던 시기였던 것 같아요. ㅎㅎ\n그냥 프레임웍을 안썼던 경우도 많구요 ㅎㅎ\n\n-----\n\n와 준태님 7팀에서 유일하게 이번 과제 패스하셨네요.\n아무래도 시간이 부족해서 회고는 작성하시기 힘드셨겠지만 정말 이많은 과제 잘 해내신 것 같습니다. \n근데 준태님 준태님이 미리 잡힌 휴가가 있어서 과제 할 시간 부족하다고 하신분이었지 않아요?\n아닌가요.. 지훈님인가..\n아무튼 맞다면 정말 더더욱 훌륭하네요 :) \n",
    "assignment": {
      "name": "STEP08 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/29"
    }
  },
  {
    "passed": true,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/60"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/61"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/64"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/23"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/54"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/30"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/8"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/22"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/47"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/53"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/34"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/6"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/62"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/63"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/57"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/5"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/40"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/56"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/49"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP09 React 아키텍처 해부하기 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/59"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "안녕하세요 승훈님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n과제를 풀어나가는 방식을 PR에 잘 서술해주셔서 흥미로웠어요!\n단계별로 잘 풀었군요!!\n\n이런 흐름으로 hard 모드도 도전해보시면 좋을 것 같습니다 ㅎㅎ\n고생하셨어요 승훈님!\n특별한 질문은 없어서 피드백은 바로 마무리하겠습니다.\n궁금한점 생기면 언제든 디스코드에 문의 남겨주세요~!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/12"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "고다솜",
    "feedback": "안녕하세요 다솜님! 정성스러운 회고 너무 잘 봤어요!! 다솜님의 고뇌가 절절하게 느껴지네요 ㅎㅎ\n\n> reconcileChildren에서 DOM을 역순으로 재배치하는 이유\n\n말씀해주신 것 처럼, anchor와 관련하여 순서가 꼬이거나 의도치않은 동작을 하거나 엉뚱한 node를 수정하는 등의 문제가 발생할 수 있답니다!\n\nreact에서는 어떻게 하고 있는지... 한 번 살펴봐야할 것 같네요 ㅋㅋ\n\n근데 아마 순서로 인한 성능은 큰 차이 없을 것 같아요. 배치 순서가 중요한게 아니라 어디서 렌더링을 트리거할 것인지가 중요한거라서요.\n\n이걸 리액트는 Scheduler를 별도로 만들어서 관리하는걸로 알고있습니다.\n\n안정성에 대한 장단점은, 제대로만 구현하면 아마 큰 차이는 없겠죠?\n다만 역순으로 해야 아마 관리하기가 조금 더 수월하지 않을까? 라는 추측을 하곤 있습니다 ㅎㅎ\n역순이 아니면 고려해야할게 더 많아져서요. (미리 문제되는 것들을 찾아서 반영한다거나..?)\n\n> useEffect의 cleanup과 effect 실행 시점\n\n저도 실제로 react 자체를 들춰보진 않았답니다 ㅎㅎ 다만 \"이렇게 동작하겠거니~\" 라고 상상하는거죠.\n\n일단 크게 문제될 부분은 없을 것 같아요. flushEffect가 queueMicrotask 에서 실행되고 있고, 이 때는 이미 렌더링이 끝난 후일테니까요! 브라우저 paint 차단 가능성이 있는 무거운 effect의 경우 성능 차이가 있겠지만, 그렇게까지 문제되진 않을 것 같습니다.\n\n그리고 \"commit 후 단계\"가 결국 렌더링이 끝난 후일 꺼라서요.\nuseEffect 내부에서 querySelector등을 통해 방금 막 렌더링 된 dom에 접근할 수 있는 사실 자체가, \"렌더링 종료 직후\"라는 증거라, 단계를 분리한다고 해도 제일 중요한건 \"렌더링 이후\" 라는 점일꺼라 마찬가지로 그렇게까지 큰 차이는 없을 것 같습니다.\n\n리액틍틔 Cleanup과 Effect 순서는 이렇게 동작할 것 같아요!\n- 의존성 변경 시: 이전 cleanup → 새 effect\n- 언마운트 시: cleanup만 실행\n\n이는 현재 구현과 동일하다고 생각합니다 ㅎㅎ\n\n\n\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "고생하셨습니다 정원님 ㅎㅎ\n이번주도 PR 1등이시군요. 과제도 예상보다 빨리 끝내셨던거 같아요.\n필요로 하는 코드 구현도 잘 해주셨고 앱도 잘 동작하는 것 확인했습니다.\nPR에 있어서 뭔가 더 적어주실것 같아서 저녁까지 기다렸는데 일단은 따로 수정된 부분은 없는 것 같아서 일단은 채점 진행했습니다.\n혹시 추가로 회고 남기시거나 리뷰 받고 싶은 내용있는데 제가 놓친다면 알려주세요!\n\n고생하셨고 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/29"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "수고했어요 연욱! Easy 기본 과제 완료한 거 잘했습니다.\n\neventManager에서 change 이벤트가 빠져있던 경험이 좋은 교훈이 됐을 거예요. \"AI를 철석같이 믿었는데 황당했다\"는 표현이 인상깊네요. 맞아요. AI가 준 코드도 검증이 꼭 필요하지요. \n\n재귀 함수에서 버퍼링 걸렸다고 했는데, 이건 정상이에요. 자식 노드 처리 로직을 머릿속으로 시뮬레이션하는 건 누구나 헷갈려요. 팁을 드리자면, console.log로 depth를 찍어보면서 실제 호출 순서를 눈으로 확인해보세요. 머릿속으로만 따라가는 것보다 훨씬 이해가 빨라요.\n\nQ) PR을 잘 작성하는 팁을 질문드리고 싶습니다!\n=> 하하 여기의 PR은 과제의 PR일까요? 아니면 실제 회사의 PR일까요? 세부사항은 다르겠지만 PR을 작성하는 가장 큰 이유는 내가 작성한 코드만으로 나의 의도나 실제 수정된 내용이 어떤 것들이 있는지 다른 사람이 따라가기 어렵기 때문인거죠. 코드의 diff만으로 따라가지 못하는 혹은 코드를 보지 않더라도 어떤 것들을 했을지를 인간의 언어로 따라갈 수 있도록 하기 위한거에요\n\n=> 결국 핵심은 \"리뷰어가 맥락 파악에 드는 시간을 줄여주는 것\"이에요. 실제 PR에서는 왜 이 변경이 필요한지(배경), 뭘 바꿨는지(변경 사항), 어떻게 확인 할 수 있는지(검증 방법) 등을 명확하면 됩니다. 코드 diff만 보고 의도를 파악하게 하지 마세요.\n\n=> 과제의 PR은 경우에는 최대한 생생하고 구체적으로 적어보는 것입니다. 사실 코치분들이 코드만으로 실력이나 잘했다 못했다를 판단하는건 너무 어렵습니다. 코드는 결과이지 맥락이나 과정이 녹\b아있지 않으니까요. 그렇기에 어떤 상황을 맞이 했었고 어떤 시행착오가 있었고 어떤 고민과 시도가 있었고 그 뒤에 알게 된 것들은 무엇이고 특히 과제를 실습함으로서 이론적 지식 습득이 아닌 체험적 깨달음이 뭔지를 알아갔구나 하는 것들을 판단하고자 하는 점입니다. 깨달음이 생기면 뭔가 더 글에서 그 생생함 자체가 느껴지니까요. BP 친구들의 PR을 한번 읽어 보면 생생하다는게 무슨 말인지 잘 이해가 될거에요\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 심화 과제랑 Hard도 시간 될 때 도전해보세요. 직접 만들어볼수록 \"아, 이래서 이렇게 동작하는구나\"가 쌓여요.\n\n다음 챕터는 설계입니다. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/60"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "안녕하세요 지현님! 5주차 과제를 다 진행하기에는 시간이 많이 부족했었던 것 같군요 ㅠㅠ\n\n6주차는 이제 클린코트 파트라서 이전 주차의 내용과는 무관하니 더 힘내봅시다!! 화이팅!!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/61"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "안녕하세요 대현님~ 5주차 과제 잘 진행해주셨네요 ㅎㅎ\n특별하게 리뷰 받고 싶은 부분은 없는 것 같아서 바로 마무리하겠습니다.\n 고생하셨습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/43"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김도현",
    "feedback": "고생하셨습니다 도현님! 필요한 기능 모두 잘 구현해주셨네요!\n회고 남겨주신거 보니 리액트를 공부할 때 왜 이런부분들을 강조했는지 실제 구현관점에서 많은 것들을 알게 되신거 같아 좋네요!ㅎㅎ\n\n> Phase 5에서 막혔을 때, 어떻게 접근하는 게 좋았을까요?\n\n제가 본 과제의 관점에서는 4까지는 필요한 기능들을 구현하는 정도였다면 5부터 본격적으로 구조를 파악하는 과제로 접어들었던 것 같아요. 그만큼 어려웠고 본격적이게 구현을 해야한다면 매우 복잡한 개념이였던것 같은데요. 없는 개념을 억지로 되게 만들기 보다는 기존 구현 방식에 대해 깊게 살펴보고 그걸 가볍게 녹여보는 접근으로도 꽤 괜찮지 않았을까 싶네요! 학습이란걸 하는 관점에서 무엇을 배워야 하고 이 코드 작성은 어떤걸 의도하는지 매번 짚어가면서 보는게 중요하다고 생각하거든요. 그 관점에서 너무 과제를 통과하기위해 나아가기 보다는 중간중간 계속 질문을 해보고 그 관점에서 학습을 잘 해내는 방법이 뭔지 고민해보는게 제일 좋지 않을까 싶습니다. 이 과제가 리액트의 실제 구현을 학습하고 이해해보고 재현해보는거니 그런 관점에서 말해봤어요  ㅎㅎ\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/48"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "안녕하세요 민석님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다.\nAI를 적극적으로 사용해주신 것 같군요!?\n추후에 시간 되면 한 번 더 도전해보시면 좋을 것 같아요!\n궁금한점 생기면 디스코드에 언제든 편하게 문의해주세요~ 감사합니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/58"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "수고했어요 민지! Easy 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\n\"API 응답 순서대로 상품 카드가 나오지 않는 문제\"를 해결한 과정이 좋았어요. 원인이 될 부분을 가설로 세우고 하나씩 검증해나간 방식, 1번 API 호출 확인 → 2번 children 정리 로직 → 3번 렌더링 기준, 이게 디버깅의 정석이에요. AI가 만든 코드에서 문제가 생겼을 때 이렇게 체계적으로 접근할 수 있다는 건 이미 기본기가 있다는 뜻이에요.\n\n\"AI에게 많이 의존해서 과제를 하는게 의미가 있을까\" 고민했다고 했는데, 그 고민 자체가 좋은 거예요. 그리고 결론도 좋았어요. \"AI가 문제를 일으킬 때 해결하는 과정에서도 이해도가 늘어날 수 있다\"는 깨달음, 맞아요. AI를 쓰든 안 쓰든 결국 문제를 해결하는 건 본인이에요. AI가 준 코드를 검증하고 문제를 찾아내는 능력이 더 중요해지는 시대거든요.\n\n\"과제 후 팀원들 코드 보면서 AI 없이 다시 구현해보겠다\"는 계획도 좋습니다. 꼭 해보세요. 한 번 이해한 상태에서 다시 구현하면 훨씬 수월하고, 그 과정에서 진짜 내 것이 돼요.\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 돼요. Hard의 훅 구현도 관심 있다고 했으니 시간 될 때 도전해보세요.\n\n다음 챕터는 설계에요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/64"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "수고했어요 성민. \n\n이번 챕터의 취지는 내가 어떤 계층을 만들고 있느냐에 따라 필요한 지식의 깊이가 달라진다는 것을 느끼고 깊이를 내려가고 싶다면 그 영역을 한번 스스로 구현을 해보고자 하면 되는구나 라는 것이었어요.\n\n그래서 React'로' 개발하는게 아닌 React'를' 개발하게 되면 어떤 것들을 익힐 수 있는지를 알게 되었기를 바래요. 상태관리, CSS Framework, SSR, 번들러등 전부 구현하지 않아도 되니 핵심 컨셉만 한번 구현해보고자 한다면 더 깊이를 쉽게 이해하게 되는 방법도 알게 되었기를 바랍니다.\n\n완성하지 못한 부분은 나중에라도 꼭 한번 시도해보세요!\n\n다음 챕터는 설계네요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 합시다. 수고했습니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/55"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김소리",
    "feedback": "소리님 고생하셨습니다! 회고 과정 잘 정리해주셔서 어떤 맥락에서 과제를 진행해주셨는지 잘 이해할 수 있었습니다. 필요한 구현 모두 잘 해주셨고, 잘 동작하네요. 배포도 잘 해주셨구요! 말씀대로 깊게 하려면 한도끝도 없이 할 수 있는 주제같아요.\n\n> 현재 구현에서는 각 DOM 요소에 직접 이벤트 리스너를 추가하고 있습니다. React처럼 이벤트 위임을 사용하려면 어떻게 구현해야 할까요? 트 컨테이너에 이벤트 리스너를 등록하는 시점과 방법은 무엇일까요?\n\n저번 주 저희가 했던 과제를 생각해보면 명확해질수 있는데요. \n루트 엘리먼트에 위임을 시켜서 핸들러 함수들을 효율적이게 관리하는 방식을  사용하면 됩니다! 이렇게 하면 메모리 사용량을 줄일 수 있고, 최적화가 필요한 곳에 대해 효율적인 관리가 가능해집니다.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/24"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "안녕하세요 우정님! 5주차 과제 진행하느라 고생하셨습니다 ㅎㅎ\n\n> 시간이 없어서 AI로만 코드 작성했습니다ㅜㅜ 여유가 생길때 과제 스스로 해보겠습니다..!\n\n좋습니다~ easy부터 차근차근 해보신걸 추천드려요! 고생하셨어요!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/23"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김준모",
    "feedback": "안녕하세요 준모님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ)\n무한 스크롤 구현 시 이벤트가 중간에 사라지거나 중복 등록되는 이슈가 있었습니다. 문제의 원인은 useEffect cleanup이 의존성 변경 없이도 실행되는 것이었고, 이를 해결하기 위해 cleanup은 shouldRunEffect가 true일 때만 실행되도록 수정했습니다.\n\n또한 updateDomProps에서 이벤트 핸들러를 등록하기 전에 Object.is(prevValue, nextValue) 체크를 먼저 수행하여 함수 참조가 같으면 이벤트 핸들러 등록 로직을 건너뛰는 문제를 발견했습니다. 이벤트 핸들러 처리 로직을 Object.is 체크 이전으로 이동하여 항상 재등록하도록 수정했습니다.\n\n현재 window.__REACT_DEBUG_EVENTS__ 플래그를 활용해 로그를 찍어보고 있는데, 실제 프레임워크 레벨에서 이벤트를 디버깅하거나 관리할 때 주로 사용하는 패턴이나 팁이 있을까요? 특히 이벤트 위임 환경에서 이벤트 핸들러가 제대로 등록/해제되는지 확인하는 방법에 대해 조언을 받고 싶습니다.\n\nA)\n음 직접 도구를 만들어서 사용하는 방법이 많은 것 같아요 ㅎㅎ 저희 옆팀에서도 텍스트 에디터 프레임워크를 만들고 있는데, 이 때 디버깅을 위한 개발자도구를 만들어서 사용하고 있고, 저희 팀에서도 디버깅이나 데이터 트래킹을 위한 크롬 확장프로그램을 만들어서 사용하는 편입니다.\n\n아마 console.log 같은걸로만 하기에는 무조건... 힘들답니다 ㅠㅠ",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/54"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "수고했어요 채영! 건강 이슈가 있었다고 했는데 그 와중에 기본 과제랑 심화 과제까지 다 해낸 거 대단합니다.\n\n\"테스트코드를 통한 코드 역추론 경험\"이라는 부분이 인상깊었어요. createElement의 기대 결과값을 보고 구현 방향을 잡아나간 과정, 이게 실무에서도 정말 자주 쓰이는 방식이거든요. 이번 과제에서 이 감각을 익힌 건 좋은 수확이에요.\n\n리뷰 요청한 부분들 간단히 답변드리면, Reconciler 분기 구조는 현재 규모에서는 괜찮습니다. Map 기반 path 관리도 적절한 선택이고, memo/deepMemo HOC도 React의 memo와 거의 동일한 정석적인 구현이에요. 잘했습니다.\n\n\"단순한 정의만으로 알고 있던 개념들을 체화할 수 있었다\"고 하셨는데, 이게 이번 과제의 핵심 목표였어요. 내가 어떤 계층을 만들고 있느냐에 따라 필요한 지식의 깊이가 달라진다는 것을 느끼고 깊이를 내려가고 싶다면 그 영역을 한번 스스로 구현을 해보고자 하면 되는구나 알게 되었기를 바래요. 상태관리, CSS Framework, SSR, 번들러등 전부 구현하지 않아도 되니 핵심 컨셉만 한번 구현해보고자 한다면 더 깊이를 쉽게 이해하게 되는 방법을 배웠기를 바래요\n\n다음 챕터는 설계네요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 합시다. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/30"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김현우",
    "feedback": "현우님 고생하셨습니다!\n필요한 기능 모두 잘 구현해주셨네요.\n배포해주신 사이트도 잘 동작하는것 확인했습니다.\n다만, 따로 회고나 PR 템플릿을 채워주신게 없어서 너무 아쉬운데요 ㅠㅠ\n혹시 금요일 오후에 올려주실까 싶어서 저녁까지 기다려봤는데, 따로 뭔가 올려주신건 없어서 피드백을 남기지는 않았습니다.\n혹시 추가로 피드백이 필요한 부분 있으면 꼭 알려주세요~~\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "남은주",
    "feedback": "안녕하세요 은주님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ\n특별한 질문은 없는 것 같아서 바로 마무리하겠습니다.\n궁금한점 생기면 언제든 디스코드를 통해 문의주세요! 고생하셨습니다~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/33"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "노유리",
    "feedback": "고생하셨습니다 유리님!\n필요한 구현 모두 잘 해주셨고, 잘 동작하네요. 배포도 잘 해주셨구요!\n과제를 통해서 실제 리액트 동작에 대해 큰 관점의 이해를 하는데 도움이 되었으면 좋겠네요.\n\n> 1. Hook 상태 관리\n\n좋은 방식입니다! 결국 가비지컬렉션 관점에서 효율적이게 관리하는 방식에 대해 궁금하셨다! 라는 질문으로 이해했는데요. weakmap의 경우 키가 객체만 가능하기 때문에, 지금의 방식이 아닌 참조 자체를 키로 하도록 해서 사용한다면 유의미하게 사용할 수 있을것이라 보입니다 ㅎㅎ 실제 리액트 구현은 저도 잘 기억이 안나서 찾아봤는데, 각 컴포넌트에 대응되는 Fiber 노드 객체 내부에 훅을 저장한다고 하네요. 그리고 이 훅들은 배열이 아니라 링크드리스트 형태로 관리가 되는데 이걸로 호출 순서를 보장하고, 컴포넌트가 파괴될 때 훅 상태도 자연스럽게 GC되기 위한 구조로 만들기 위해 그렇게 구현했다고 하네요!\n\n> 2. Reconciliation 최적화\n\n지금의 방식도 시간 복잡도 측면에서 크게 문제가 있는 부분은 아닌데요!\n성능 문제가 생긴다면, 매칭 때문은 아니고 재귀적으로 깊게 호출되는 구조 때문이 되지 않을까 싶긴하네요! 지금의 스택 구조에서는 작업이 되는 도중에 렌더링 외 다른 작업을 수행할 수 없으니, fiber 처럼 작업 단위를 호출해두고 작업을 수행하는 형태로 구현이 된다면! 더 성능상 문제가 사라지지 않을까 싶습니다.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/4"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "안녕하세요 희정님~ 5주차 과제를 다 진행하기에는 시간이 많이 부족했군요..!\n시간 될 때 꼭 도전해보시면 좋겠어요.\n고생하셨습니다!!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/8"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박수범",
    "feedback": "수고했어요! 수범 기본 과제랑 심화 과제 모두 잘 해냈네요.\n\n회고에서 \"HTML Attribute와 DOM Property의 결정적 차이\"를 깨달은 부분이 인상깊었어요. setAttribute('selected', 'true')가 왜 안 먹히는지 직접 디버깅하면서 깨달은 부분이죠. 이런 삽질(?)에서 얻는 지식이 진짜 몸에 새겨진다 생각해요. 리액트가 어떻게 value, checked 같은 속성을 특별 취급하는지 알게 되는 거니까요! 아주 잘햇씁니다\n\nuseState와 useRef의 차이를 \"enqueueRender를 호출하느냐 마느냐\"로 정리한 것도 좋았고, useCallback + memo가 왜 함께 써야 하는지를 Reconciler 관점에서 이해한 것도 잘했습니다.\n\n리뷰 요청한 부분에 답변드리면, isProperty 화이트리스트 방식은 현재로서는 적절한 선택이에요. Web Components나 video/audio 태그 지원할 때도 리스트 추가하는 정도로 충분합니다. 다만 그때 고민해볼 건 \"이 속성이 Property인지 Attribute인지\"를 매번 하드코딩할 게 아니라, 해당 DOM 요소에 실제로 그 프로퍼티가 존재하는지(key in element)를 런타임에 체크하는 방식도 있어요. 둘 다 장단점이 있으니 상황에 맞게 선택하면 됩니다.\n\n\"리액트의 API를 단순히 '사용'하는 것을 넘어 '동작 원리'를 바닥부터 구현하며 이해했다\"고 하셨는데, 이게 이번 과제의 핵심 목표였어요. 내가 어떤 계층을 만들고 있느냐에 따라 필요한 지식의 깊이가 달라진다는 걸 느꼈기를 바래요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 돼요. 상태관리, CSS Framework, SSR, 번들러 등 전부 구현할 필요 없이 핵심만 만들어보면 훨씬 쉽게 이해할 수 있다는 방법을 이번에 배웠기를 바랍니다.\n\n다음 챕터는 설계에요. React의 원리를 넘어 React 프로젝트를 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 화이팅입니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/22"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "안녕하세요 용태님!\n이렇게 디테일한 학습 기록이라니..!! 너무 놀랍네요.\n무엇보다 1주일동안 용태님께서 학습한 내용의 깊이가 인상적이에요\n\n>  특히 심화 과제의 훅들을 만들고 테스트하는 과정에서 그전의 과정과 달리 빠른 시간안에 문제를 해결하고 테스트가 통과되는 경험을 했고, 이 경험이 \"내가 잘 만들어 냈구나!\" 라는 효능감이 폭발했던 시점이었습니다.\n\n테스트 때 부터 쌓아온 경험이 여기서 잘 발휘되었던 것 같군요! 다행입니다 ㅎㅎ\n\n> \"React도, Component도, Virtual DOM도, Hook들도 결국에는 Magic이 아닌 문제해결의 결과물이구나\" 라는 생각이었습니다. 오랫동안 React나 Vue같은 도구 위에서 작업하다보니 굳어진 사고의 울타리가 깨지는 좋은 경험이었습니다.\n\n맞아요. 그리고 이런 과정이 또 어떻게 보면 \"프론트엔드 개발자\"의 영역을 넓혀주는 과정이라는 생각을 많이 하는 편입니다. 문제해결의 대상이 UI에 대한 것이긴 하지만, 알고리즘이나 자료구조도 꽤 많이 알아야하고, 설계에 대한 고민도 굉장히 많이 필요해요.\n\n이렇게 \"코어\"를 만드는 경험이 우리가 할 수 있는 일의 범위를 넓혀준다고 생각해요 ㅎㅎ\n\n1주간 쉽지 않았을텐데 너무 고생 많았어요 용태님!! ",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/9"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박지영",
    "feedback": "고생하셨습니다 지영님! \n굉장히 꼼꼼하게 회고 작성해주셔서 어떤 과정으로 과제 진행해주셨는지 잘 이해할 수 있었습니다. 필요로 하는 기능은 모두 잘 구현해주셨고, 배포된 페이지도 잘 동작합니다 :+1\n과제를 통해 리액트의 실제 구현들을 잘 이해하게 되는 계기가 되신 것 같아 좋네요 ㅎㅎ\n\n> 1. DOM Property 처리 범위\n\nboolean이라든지, 스타일이라든지 등등 다양한 값들이 있지 않을까요!?\n굉장히 많을 것 같아서 천천히 찾아봐도 될 것 같습니다.\n\n> 2. reconcile 함수 리팩토링\n\n역할별로 분리하는 건 필요할 것 같아요! 진입점 분리를 잘 분리하면 역할별로 로직도 잘 관리되고 책임도 잘 나뉠것 같습니다. 이미 알고 있겠지만, 단계별로도 잘 나눠서 비교 후 바로 처리하는 것이 아니라 phase에 맞춰서 실행되도록 하는것도 좋아요!\n\n> 3. createChildPath의 inferredIndex 계산 로직\n\n과제를 위한 보조적인 장치인 것 같은데요. 부모경로/컴포넌트타입/인덱스 요걸 키로 활용하기 때문에요.  시간복잡도 관점에서는 전체를 비교하는게 좋지만, 형제 요소, 부모요소가 수정될 때 상태가 유지가 되냐 아니냐에 대한 부분도 있어서 지금의 구조가 실제 리액트와 더 유사하다고 볼 수 있는 것 같아요. \n\n\n> 4. Fragment의 DOM 처리 방식\n\n실제 리액트에서는 Fragment라는 타입의 노드를 별도로 관리하는 것으로 알고 있는데요. 렌더링할때만 별도로 처리하지, 실제로는 Fiber를 가지고 동일하게 처리를 하는걸로 알고 있어요!\n\n> 5. useEffect cleanup 실행 타이밍\n\n구현상 이펙트 큐 내부에서 '이전 클린업 실행 후 새 이펙트 실행' 순서로 동기적으로 처리되도록 되어있는데요. 새 이펙트가 시작되기 전에 이전 상태를 정리하는 React의 의도와 부합한다고 볼 수 있을 것 같아요!\n\n> 6. 전역 context vs 인스턴스 context\n\n지금의 고민도 너무 좋은데요. 실제 리액트 구조에서는 루트마다 FiberRoot 인스턴스를 만들고 데이터를 각 컴포넌트 fiber안에 직접 저장하는걸로 알고 있어요. 만약 조금 더 나아간다면 context 객체 방식을 createRoot를 하는 시점에 상태 저장소를 생성하고 주입하는 형태로 간다면 조금 더 적절하지 않을까 싶습니다.\n\n고생하셨고 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/50"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "창수님 고생하셨습니다 ㅎㅎ\n굉장히 필요한 부분만 딱딱 잘 구현해주신것 같네요.\n뭔가 PR 템플릿이 AI가 작성한 느낌이 약간(?) 나지만 그만큼 잘 작성해주셨단 거겠죠? ㅎㅎㅎㅎ\n따로 리뷰를 요청해주신 부분은 없어서 요기서 마무리 하겠습니다.\n실제로 하기 나름인 과제이고 얼마나 깊게 가냐에 따라 어려워 질 수 있는 주제인데 깊게 더 발전시켜보셔도 좋을것 같습니다.\n\n고생하셨습니다!~~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/47"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박형우",
    "feedback": "안녕하세요 형우님! 5주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!\n\n반복학습 일정도 만들어주셨군요 ㅋㅋ \n항해 수료 후 다시 꼭 만들어보시는걸 추천드립니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://hyeongwoo94.github.io/front_7th_chapter2-2"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "수고했어요 희정! Easy 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\n\"Virtual DOM은 그냥 JavaScript 객체다!\"라는 깨달음이 이번 과제의 핵심이에요. 뭔가 특별한 기술인 줄 알았는데 알고 보니 단순한 객체였다는 경험, 이게 직접 구현해봐야만 얻을 수 있는 거거든요.\n\nProperty vs Attribute 차이를 체크박스 이슈로 배운 것도 좋았어요. `setAttribute(\"checked\", \"true\")`가 왜 안 되는지, 이건 실제로 삽질해봐야 알 수 있는 부분이에요. Boolean 속성은 반드시 property로 설정해야 한다는 걸 몸으로 익힌 거죠.\n\nQ) AI의 도움으로 먼저 코드를 구현한 뒤, 코드 분석과 이해, 그리고 혼자 첨부터 다시 구현을 하는 방법으로 순서로 진행했습니다. 이렇게 AI에 많이 의존하는 학습 방식이 과연 괜찮은지 혹은 스스로 먼저 더 많이 고민을 해보고 구현하는 것이 더 효과적일지 고민이 됩니다. 앞으로 더 깊이 있게 성장하려면 어떤 접근이 좋을지 그리고 AI 의존도가 높아질 때 주의해야 할 점이 있다면 어떤것이 있을지 멘토님의 의견을 듣고 싶습니다.\n\n=> AI를 의존하건 이용하는건 나쁘지 않다고 생각합니다. 구글과 스택오버플로우 시절에도 그걸 잘 사용하는 사람이 더 나은 개발자였으니까요. 지금처럼 AI의 도움을 통해 레퍼런스를 발견하고 이해하고 다시 해보면서 내것으로 만드는 사이클은 아주 좋은 습관이라고 생각합니다.\n\n=> 우리는 보통 AI에게 \"어떻게\"하는 건지를 물어보고 그 답을 시도해보고 이게 성공한다면 여기서 멈추곤 합니다. 그렇지만 학습을 하려면 그 이면에 \"왜 이렇게 하는거지?\" 라는 질문에 내가 답할 수 있어야 하고 그렇지 못한다면 AI에게 다시 물어 볼 수 있습니다.\n\n=> 오 이런게 있네 -> OK 알겠다 -> 와... 완전히 이해했다. -> 아..! 그게 이래서 그런거였구나 -> 아 그건 말이지... 이런거야 등 내가 어떤 개념을 이해한다는 것에는 다양한 스펙트럼이 있어요. 우리의 뇌는 효율을 추구해서 적당히만 알아도 안다고 치고 넘어갑니다. 그렇지만 정보접근 -> 지식습득 -> 이해 -> 깨달음 -> 설명가능 -> 나아가 모르는 사람에게 정보전달 가능 -> 모르는 사람에게 지식습득 가능 -> 이해 -> 깨달음 까지 가능한 수준까지 학습과 이해에는 너무 다양한 수준이 있습니다.\n\n=> 또한 왜 그런지 1차적으로 알고 있거나 혹은 그 원리나 이면까지 혹은 그 역사적 배경이나 다른 관점의 융합 혹은 유사한 개념 다른 개념들까지 더 깊게 혹은 연관되어 넓게 연결해서 이해하는 것들도 있죠. 이렇게 이해의 스펙트럼에 대한 부분이 선명해지면 내가 AI를 쓰더라도 얼마든지 \"왜 이렇게 되는거야?\" \"다른 방법은 없어?\" \"언제부터 이 방법을 썼어?\" \"그전에는 어떻게 했는데?\" \"이게 베스트 프랙티스야?\" \"트레이드 오프는?\" 등등 다양하게 물어가면서 선명도를 높일 수 있습니다. AI를 더 잘 쓸 수 있는 좋은 방법들을 많이 찾아보길 바래요!\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. Hard도 관심 있다고 했으니 시간 될 때 도전해보세요. Hooks 구현까지 해보면 \"useState는 어떻게 구현되어 있을까?\"라는 질문에 답할 수 있게 돼요.\n\n다음 챕터는 설계입니다. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/53"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "수고했어요 승현! 기본 과제랑 심화 과제 모두 잘 해냈네요.\n\n데일리 회고를 보니까 매일 학습 과정을 기록하면서 진행했군요. \"createVNode의 역할을 모르겠다\"에서 시작해서 \"Diff는 DOM이 아니라 이전 vNode에 의존한다\"까지 도달한 과정이 잘 보여요. 특히 정렬 이후 화면이 리셋되던 문제를 디버깅하면서 이 핵심을 깨달은 게 좋았습니다. 이런 삽질이 진짜 학습이에요.\n\n\"일단 작성해보자는 마음에 테스트 코드를 무시했다가 타입별 처리가 누락됐다\"는 회고도 좋았어요. 테스트 코드는 \"검증 도구\"이기도 하지만 \"명세서\"이기도 하거든요. 다음부터는 테스트부터 읽고 시작하는 습관을 들이면 훨씬 수월할 거예요.\n\n리뷰 요청한 이벤트 위임 구조에 대해 답변드리면, 현재 방식은 대규모 UI에서도 충분히 동작합니다. 다만 주의할 점은 removeEvent 호출이 누락되면 핸들러 맵에 참조가 남아서 메모리 누수가 생길 수 있어요. 컴포넌트 언마운트 시 정리가 확실히 되는지만 신경 쓰면 됩니다.\n\n이번 과제의 핵심은 내가 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 돼요. 상태관리, CSS Framework, SSR, 번들러 등 전부 구현할 필요 없이 핵심만 만들어보면 훨씬 쉽게 이해할 수 있다는 방법을 이번에 배웠기를 바랍니다.\n\n다음 챕터는 설계에요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/37"
    }
  },
  {
    "passed": true,
    "name": "신수빈",
    "feedback": "수고했어요! Easy 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\n\"checked나 selected는 property로만, disabled는 attribute까지 관리해야 한다\"는 걸 삽질하면서 알아낸 거 좋았어요. 그리고 \"자식 요소 역순으로 제거해야 인덱스 안 꼬인다\"는 깨달음도 직접 구현해봐야만 알 수 있는 부분이에요. 이런 경험들이 쌓이는 거죠! 잘하셨습니다.\n\nQ) 1. Boolean 속성 처리 로직 개선 방안 현재 createElement.js와 updateElement.js에서 Boolean 속성을 처리할 때 disabled만 특별 처리하고 있는데, 이 부분이 하드코딩된 느낌입니다. 확장 가능하고 유지보수하기 좋은 방식으로 개선할 수 있는 방법이 있을까요?\n\n=> Boolean 속성 하드코딩 문제는, 화이트리스트 객체로 분리하면 돼요. `const BOOLEAN_PROPS = { checked: true, selected: true, disabled: true, ... }` 이런 식으로요. 코어 레벨에서는 if 를 써도 크게 상관없습니다. 유연함을 위한 구조인데 사실 코어레벨의 코드들은 잘 바뀌지 않거든요.\n\nQ) 현재 normalizeVNode나 createElement 함수에서 예상치 못한 입력에 대한 에러 처리가 부족한 것 같습니다. 프로덕션 환경에서 안정성을 높이기 위해 어떤 부분에 방어 코드를 추가하면 좋을지 조언해주실 수 있나요?\n=> 코어한 함수에서는 런타임 방어 로직을 넣으면 성능 이슈가 있기 때문에, TypeScript로 컴파일 타임에 타입 검증을 강화해서 애초에 잘못된 값이 들어오지 않도록 만드는 게 좋아요. React도 개발 모드에서만 검증 로직이 동작하고 프로덕션에서는 제거합니다.\n\nQ) MVC 패턴을 따르려고 했는데, 제가 구현한 구조가 MVC 원칙에 맞게 잘 구성되었는지 검토해주시고, 보완할 부분을 제안해주실 수 있을까요? 컴포넌트 간의 의존성이 높아져서 테스트하기 어려운 상황입니다. 의존성을 낮추고 테스트 가능성을 높이는 구조 개선 방안이 있을까요?\n=> MVC 패턴 질문은, 이 과제의 목적은 패턴 적용이 아니라 Virtual DOM 동작 원리 이해예요. 패턴에 맞추려고 하기보다 \"왜 이렇게 동작하는가\"에 집중하는 게 더 중요합니다. 의존성이나 테스트 관련 고민은 다음 챕터에서 본격적으로 다뤄요.\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. \"Virtual DOM이 필요한 부분만 업데이트한다는 것의 진짜 의미를 알게 됐다\"고 했는데, 이게 핵심 배움이에요.\n\n다음 챕터는 설계입니다. 지금 고민하신 의존성, 테스트 가능성, 구조 개선 같은 주제들을 본격적으로 다루게 돼요. 기대하셔도 좋아요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/32"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "안소은",
    "feedback": "소은님 과제 잘 해주셨네요!\n필요로 하는 스펙들 누락없이 잘 구현해주셨고 배포도 잘 진행해주셨습니다.\n\n> 1. Context 중앙화의 trade-off\n\n지금의 고민도 너무 좋은데요. 실제 리액트 구조에서는 루트마다 FiberRoot 인스턴스를 만들고 데이터를 각 컴포넌트 fiber안에 직접 저장하는걸로 알고 있어요. 만약 조금 더 나아간다면 context 객체 방식을 createRoot를 하는 시점에 상태 저장소를 생성하고 주입하는 형태로 간다면 조금 더 적절하지 않을까 싶습니다.\n\n고생하셨고 다음 주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "안녕하세요 재현님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 리뷰 받고 싶은 내용이라기 보단, 이번 easy, hard 과제에서 코치님이 의도하신 학습 포인트는 무엇이었는지 궁금합니다 ! 학습 포인트가 무엇이고 공부하면 좋을 키워드들이 어떤 것인지 여쭤보고 싶습니다 :)\n\neasy는\n1. 가상돔을 어떻게 만들어갈 수 있는지\n2. 어떻게 react가 변경사항에 대한 렌더링을 관리하는지\n\n이렇게 두 가지를 알아가는게 핵심이라면,\nhard는\n1. react의 훅이 어떻게 이전의 상태를 관리하고 유지할 수 있는지\n2. 1과 연계하여 컴포넌트의 라이프 사이클을 어떻게 관리할 수 있는지.\n\n이렇게 두 가지를 더 알아가는 것이 목표입니다.\n\n그래서 hard를 조금 더 학습하고 싶다면 리액트의 렌더링 시스템의 context가 어떤 방식으로 왜 관리되는지를 중점적으로 생각해보시면 좋답니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/34"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "양진성",
    "feedback": "안녕하세요 진성님! 5주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 이번과제는 다시 구현할때도 결국 AI를 사용하지 않으면 막히는 부분이 많아 리뷰는 개인적으로 신청할 것 같습니다\n\n그럼에도 불구하고 잘 학습해주신 것 같아요! 물론 직접 한땀한땀 만들어볼 수 있으면 좋겠지만, 꼭 그렇게 한다고 해서 질좋은 학습이 되는건 아니니까요 ㅎㅎ\n\n고생하셨습니다!!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/6"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "수고했어요 새듬! 과제를 진행하느라 수고 많았습니다!\n\n회고에서 \"Virtual DOM이 단순히 성능 최적화 도구가 아니라 DOM 형태를 본뜬 객체 덩어리\"라는 걸 체감했다는 부분이 좋았어요. 이론으로 아는 것과 직접 만들어보면서 아는 건 다르거든요. JSX에서 null, undefined, false 같은 값들이 children에 그대로 포함된다는 것도 직접 구현해봐야 알 수 있는 부분이에요.\n\n자료구조를 배열에서 Map으로 바꾼 결정도 좋았습니다. 이전 회사에서의 HashMap 경험이 도움이 됐다고 했는데, 이렇게 과거 경험이 새로운 문제 해결에 연결되는 게 성장이에요.\n\nQ) \nupdateElement.js 파일의 updateElement 함수의 조건문들이 너무 남발되어서 가독성이 떨어지는데 다른 조건문을 써도 같은 결과가 나올 것 같은데 어떠한 코드 구조로 작성해야 더 가독성이 좋은 코드가 되는지 궁금합니다.\n\n=> 여기는 코어 라이브러리 계층이라 우리가 서비스를 다루는 곳과는 달리 직관적이고 되려 과한 추상화를 하지 않는 편이 좋습니다. 지금의 코드양이 길지도 않고 가독성이 불편한 수준도 아니며 되려 적절한 if문이 직관적인 코드가 되어준다고 생각합니다.\n\n=> if문을 적게 쓰라고 하는 이유는 해당 코드의 \"변경\"이 생길것을 우려해서 유연하게 만들고자 함입니다. 그런데 코어 라이브러리들은 \"변경\"이 되어야 하는 이유가 굉장히 드물어요. 그래서 이런 경우들은 괜찮습니다.\n\nQ) 과제 체크포인트\n배포 링크\nhttps://toeam.github.io/front_7th_chapter2-2/\n\n기본과제\n가상돔을 기반으로 렌더링하기\n createVNode 함수를 이용하여 vNode를 만든다.\n normalizeVNode 함수를 이용하여 vNode를 정규화한다.\n createElement 함수를 이용하여 vNode를 실제 DOM으로 만든다.\n 결과적으로, JSX를 실제 DOM으로 변환할 수 있도록 만들었다.\n이벤트 위임\n 노드를 생성할 때 이벤트를 직접 등록하는게 아니라 이벤트 위임 방식으로 등록해야 한다\n 동적으로 추가된 요소에도 이벤트가 정상적으로 작동해야 한다\n 이벤트 핸들러가 제거되면 더 이상 호출되지 않아야 한다\n심화 과제\nDiff 알고리즘 구현\n 초기 렌더링이 올바르게 수행되어야 한다\n diff 알고리즘을 통해 변경된 부분만 업데이트해야 한다\n 새로운 요소를 추가하고 불필요한 요소를 제거해야 한다\n 요소의 속성만 변경되었을 때 요소를 재사용해야 한다\n 요소의 타입이 변경되었을 때 새로운 요소를 생성해야 한다\n과제 셀프회고\n아하! 모먼트 (A-ha! Moment)\nVirtual DOM의 본질 이해\nVirtual DOM이 단순히 \"성능 최적화 도구\"라고만 생각했는데, 실제로 구현해보니 \"DOM 형태를 본뜬 객체 덩어리\"라는 것을 체감했습니다. Real DOM의 구조를 JavaScript 객체로 표현하고, 변경사항을 메모리에서 먼저 계산한 뒤 최종 결과만 실제 DOM에 반영한다는 개념이 명확해졌습니다. 브라우저의 렌더링 과정은 HTML을 파싱하여 DOM Tree를 생성하고, CSS를 파싱하여 CSSOM을 만든 후, 이 둘을 결합하여 Render Tree를 구성합니다. 그 후 Layout 단계에서 각 요소의 정확한 위치와 크기를 계산하고, 마지막으로 Painting 단계에서 픽셀을 화면에 그립니다. Virtual DOM은 이 과정에서 변경사항을 일괄 처리하여 불필요한 reflow와 repaint를 최소화합니다.\n\nJSX 변환 과정에서의 발견\nJSX에서 {null}, {undefined}, {false}, {true} 같은 표현식들이 Babel 변환 시 그대로 children 배열에 포함된다는 것을 알게 되었습니다. React에서 false, null, undefined, true는 유효한 children이지만 실제로 렌더링되지 않습니다. 이로 인해 normalizeVNode에서 이런 값들을 적절히 필터링하지 않으면 예상치 못한 동작이 발생할 수 있다는 점을 배웠습니다.\n\n기술적 성장\n기존의 알고 있던 개념 되짚어보기\n브라우저의 workflow\n- 기존의 알고 있었던 원리였지만 이번 과제를 통해서 더 자세히 개념을 정립할 수 있는 기회가 되었습니다\n- Dom Tree 생성 -> Render Tree 생성 -> Layout -> Painting\n- Dom에 변화가 생기면 렌더트리를 재생성하고 (모든 요소들의 스타일 재계산) 레이아웃을 만들고 페인팅 하는 과정의 반복\n참고 : https://velopert.com/3236\nVirtual Dom\n리액트의 기존 원리가 되는 가상돔에 대해 개념을 한번 더 짚고 나가는 기회가 되었습니다.\n뷰에 변화가 있을 시 실제 DOM에 적용되기 전에 가상의 DOM에 먼저 적용시키고 최종적인 결과 값만 실제 DOM에 전달 => 브라우저 내에서 발생하는 연산의 양을 줄이면서 성능 개선 효과를 보임\n새로 학습한 개념\njs로 dom을 생성 시 babel의 역할\nJSX의 문법을 일반 js 함수 호출로 변환 => 코드를 텍스트로 변환하는 컴파일러!\n\t\t\n\t\t// 변환 전 (JSX)\n\t\t<div className=\"box\">Hello</div>\n\n\t\t// 변환 후 (JavaScript)\n\t\tcreateElement('div', { className: 'box' }, 'Hello')\n\t\t\n배열의 평탄화 arr.flat(depth)\ndepth: 중첩 배열 구조를 평탄화 할 때 사용할 깊이 값이자 생략 시 기본값 1\n   \t  const arr = [1, 2, [3, 4, [5, 6]]]; \n   \t  arr.flat(); // [1, 2, 3, 4, [5, 6]] \n   \t  arr.flat(2); // [1, 2, 3, 4, 5, 6] \n   \t  const arr2 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];\n   \t  arr2.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndocumentFragment\n여러 DOM 요소들을 메모리에 일시적으로 저장할 수 있는 객체\n여러 개의 요소들을 모아두었다가 DOcumentFragment요소를 한번에 HTML DOM 에 추가\n=> createElement와의 차이점이 몰까 생각해봤다.\n=> 단일 요소를 생성할 때는 createElement, 여러 요소를 한번에 추가할 때는 documentFlagment를 사용해야 불필요한 reflow 과정을 없앨 수 있다.\n\n기존 지식의 재발견/심화\n자료구조 선택의 중요성: 이벤트 핸들러 저장을 위해 처음엔 배열을 고려했지만, 중복된 이벤트 타입 처리가 필요해 Map으로 변경했습니다. 이전 회사에서 사용했던 HashMap 경험이 도움이 되었습니다.\n\n구현 과정에서의 기술적 도전과 해결\nupdateElement의 children 타입 불일치 문제\n문제: children의 타입이 다를 경우 교체 로직 누락, DOM 인덱스가 어긋나면서 잘못된 위치에 요소 추가\n원인: normalizeVNode에서 빈 문자열이 children 배열에 포함되어 메인 화면에 빈 상품카드가 생성됨\n해결: updateElement의 타입 비교 로직을 정규화하고, 동적 인덱스를 추적하는 방식으로 개선\n\n이벤트 리스너 중복 등록 문제\n문제: 기존 이벤트 리스너를 제거하지 않아 중복 등록 발생\n해결: rootEventHandlers.clear()를 사용하여 기존 핸들러 제거 (효율성에 대한 의문은 남음)\n\n코드 품질\n리팩토링이 필요한 부분\nupdateElement.js , createElement.js 부분이 조건문 사용이 많아 깔끔해 보이지가 않아서 어떻게 리팩토링을 할 지 고민중입니다.\n학습 효과 분석\n가장 큰 배움이 있었던 부분\nVirtual DOM의 동작 원리를 이론이 아닌 실제 구현을 통해 체득했습니다. Virtual DOM은 성능 향상을 위해 변경사항을 JavaScript 엔진의 메모리에서 먼저 계산하고, 최소한의 DOM 조작만 수행하여 비용이 큰 reflow와 repaint를 줄입니다. Stack OverflowTalent500\n\n추가 학습이 필요한 영역\nDiffing 알고리즘의 최적화: 현재 구현은 기본적인 비교만 수행하는데, React의 Fiber 아키텍처처럼 더 효율적인 업데이트 방식에 대해 학습이 필요합니다.\n이벤트 핸들러 관리: 현재 방식보다 메모리 효율적이고 성능이 좋은 패턴을 연구하고 싶습니다.\n\n과제 피드백\n리뷰 받고 싶은 내용\nupdateElement.js 파일의 updateElement 함수의 조건문들이 너무 남발되어서 가독성이 떨어지는데 다른 조건문을 써도 같은 결과가 나올 것 같은데 어떠한 코드 구조로 작성해야 더 가독성이 좋은 코드가 되는지 궁금합니다.\n\neventManaget.jsdml setupEventListeners작성 중 기존에 있던 이벤트 리스너를 제거를 안해서 중복 등록하는 경우가 발생하여 rootEventHandlers.clear()를 통해 제거를 하였는데 변경된 내용만 선택적으로 업데이트 하는 방식이 괜찮은 것 같은데 또 이러면 코드 내용이 길어지니 과연 효율적인 방식인가?? 하는 의문이 생겼습니다.\n\n=> rootEventHandlers.clear() vs 선택적 업데이트 질문은, 현재 규모에서는 clear()가 더 단순하고 안전해요. 선택적 업데이트는 코드 복잡도 대비 성능 이득이 크지 않습니다. 이벤트 핸들러가 수천 개 수준이 아니라면 걱정 안 해도 돼요.\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 돼요. 이번에 그 방법을 배웠기를 바랍니다.\n\n다음 챕터는 설계에요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/46"
    }
  },
  {
    "passed": true,
    "name": "오태준",
    "feedback": "수고했어요 태준! 기본 과제랑 심화 과제 모두 잘 해냈네요. 회고가 정말 상세하네요. 잘 봤습니다! 멋지네요\n\nQ) 현재 reconcile 함수가 1000줄이 넘어 가독성이 떨어집니다. mountHost, updateHost, mountComponent, updateComponent 등을 별도 파일로 분리하는 것이 좋을까요? 아니면 현재처럼 하나의 파일에 유지하는 것이 더 나을까요?\n=> reconcile 함수 1000줄 문제는, 분리하는 게 맞아요. mountHost, updateHost, mountComponent, updateComponent를 별도 함수로 빼면 각각의 책임이 명확해지고 테스트도 쉬워집니다. 한 파일에 둘지 여러 파일로 나눌지는 취향인데, 저는 한 파일에 여러 함수로 분리하는 걸 선호해요. 애초에 태준도 1000줄이 넘어 가독성이 떨어지고 있다고 인지했으니 분리를 하는 편이 좋겠죠? import/export 오버헤드 없이 흐름을 따라가기 쉽거든요.\n\nQ) 현재 컴포넌트 경로를 문자열(\"0.c0.i1.c2\")로 표현하고 있는데, 경로 변경 시 상태 마이그레이션이 필요합니다. 더 효율적인 경로 관리 방식이 있을까요?\n=> 전체적으로 어떻게 하는게 이해가 되었다면 React는 실제로 어떻게 하고 있을까? 하면 살펴보시면 좋겠습니다. 우리에겐 정답지가 있으니까요. React Fiber는 경로 문자열이 아니라 **Fiber 노드 자체에 상태를 저장**해요. 각 컴포넌트 인스턴스가 Fiber 노드로 표현되고, 그 노드의 memoizedState 필드에 훅 상태가 linked list로 들어있습니다. \"React Fiber memoizedState\"로 한번 찾아보면서 왜 이렇게 설계를 했을지 이해해보길 바래요.\n\nQ) 현재 any 타입을 일부 사용하고 있는데, 더 엄격한 타입 정의로 개선할 수 있을까요?\n=> 네 있습니다. any 타입 개선은 점진적으로 하면 돼요. 급하게 다 바꾸려 하지 말고, 버그가 발생하거나 리팩토링할 때 해당 부분만 타입을 강화하는 방식이 실무적입니다.\n\nQ) 문제가 계속 해결되지 않을 때, console.log를 추가해 디버깅하는 방식 외에 더 효과적인 방법이 있을까요?\n=> 설명해주고 싶지만 효과는 설명한다고 해서 되는 부분이 아닌 것 같아요. 작성해준 degguer나 브레이크 포인트, 시각화나 devtools 모두 각자의 이유가 있으니까요. 이건 문제마다 다른거라서 그냥 몸소 겪으면서 노하우를 찾는 수 밖에 없어요. 제가 말로 알려주는건 한계가 있고 AI에게 물어봐도 경험하지 않으면 텍스트만으로 알 수 있는 건 한계가 있으니까요. console.log 외의 방법이 있다는건 태준이 알고 있으니 다양하게 시도를 해보면서 적절한 도구의 쓰임새를 꺠쳐보길 바래요.\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 태준이는 그 과정을 정말 깊이 있게 경험했네요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 된다는 걸 이번에 배웠기를 바랍니다.\n\n다음 챕터는 설계입니다! 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "수고했어요 지훈! Easy 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\n\"e2e 테스트를 강제로 통과시키려 했는데, 멘토링에서 내 코드가 잘못됐음을 인정하고 재작업했다\"는 부분이 인상깊었어요. 테스트가 틀렸다고 생각하기 쉬운데, 본인 코드를 의심하고 재작업한 건 좋은 태도입니다. 실무에서도 \"내 코드는 맞고 환경이 이상하다\"고 생각하면 디버깅이 오래 걸리거든요.\n\nJSX Pragma 발견도 좋았어요. `/** @jsx createVNode */`가 트랜스파일러에게 \"이 함수로 변환해라\"라고 알려주는 지시어라는 걸 알게 된 거잖아요. 이런 식으로 \"어? 이건 어떻게 동작하는 거지?\"라는 호기심에서 출발해서 원리를 파악하는 습관이 중요합니다.\n\nupdateElement 리팩토링도 좋은 방향이에요. index로 childNodes를 찾는 방식은 중간에 노드가 추가/삭제되면 인덱스가 꼬일 수 있거든요. targetNode를 직접 받는 방식이 더 안정적입니다.\n\n\"단순히 가볍게 알던 지식이 명확한 지식으로 발전됐다\"고 했는데, 이게 이번 과제의 핵심 목표예요. 직접 구현해보면서 \"아, 이래서 이렇게 동작하는구나\"를 체감하는 거죠. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 된다는 걸 이번에 배웠기를 바랍니다.\n\n다음 챕터는 설계입니다. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/62"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "헉 예인님 너무 바쁘셨나보군요..\nPR이 너무 깨끗해요!!!!!!!!!!!\n꽤나 깊게 고민할 수 있는 좋은 과제라고 생각하는데, 꼭 여유 있으실 때 해보고 팀원분들과 의견 나눠 보시면 좋을것 같습니다 ㅠㅠ\n담주는 화이팅입니다~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/63"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "안녕하세요 윤지님! 5주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n\n> 과제 패스가 중요하지 않다는 걸 알고 있으면서도 계속 패스에 집착하게 되었습니다... 그러다보니 항상 원리를 이해하고 시작하기보다 언제나 그랬듯 돌아가게만 만들었던 것 같아요. 그래서 이번에는 Easy를 하더라도 제대로 이해하면서 해보자고 마음먹었습니다.\n\n오오 너무 좋은 마음가짐입니다!!\n\n> Uncaught TypeError: Failed to execute 'removeChild' 에러가 났어요. children을 삭제할 때 정순으로 하면 index가 틀어지고, 역순으로 업데이트하면 렌더링 순서가 뒤집혔습니다. 해결책은 작업을 3단계로 분리하는 거였어요!\n\n이 부분도 무척 좋네요 ㅎㅎ 작은 단위로 문제를 쪼개는 방식으로 해주셨군요!! 좋습니다\n\n> 코치님께서 추천해주신 대로 \"AI와 함께 코드를 작성 → 전부 지우기 → 다시 처음부터 작성\"하는 방법으로 과제를 진행해봤습니다. 진행하면서 한 줄 한 줄 \"왜 이렇게 작성해야 하는가?\", \"다른 방법은 없을까?\"를 계속 질문하며 이해하려고 노력했는데요, 조금은 이해한 것 같지만 계속 AI가 작성해준 코드의 구조와 패턴만 머릿속에 남아서 완전히 새로운 관점이나 다른 접근 방식으로 문제를 바라보기가 어렵더라고요. AI의 도움을 받으면서도 더 주체적으로 학습하고, AI가 제시한 방식에 갇히지 않고 다양한 시야를 가질 수 있는 학습 전략이 있을까요? 어떤 방식으로 AI를 활용하는 게 학습에 더 효과적일까요?\n\n제일 좋은 방법은 다른 사람들과 대화를 나눠보는거라고 생각해요 ㅎㅎ\n제가 설계에 대한 시야가 넓어지던 순간은 대체로 팀원들과 얘기할 때였습니다.\n그래서 이런 \"창의적 사고\"에 대한 부분은 집단지성이 많이 필요해요.\n\n혹은 AI에게 여러개의 페르소나를 입혀보는거죠.\n\n1년차 개발자\n3년차 개발자\n5년차 개발자\n7년차 개발자\n\n혹은 원래 백엔드 개발자였던 사람, 알고리즘을 전문적으로 하는 사람, 함수형 프로그래밍을 즐겨하는 사람 등\n여러 개의 페르소나를 토대로 테스트 해보면 꽤 재미있는 결과를 얻을 수 있답니다 ㅋㅋ\n\n고생하셨어요 윤지님!!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/44"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "안녕하세요 정민님! 5주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n---\n\n> 타입스크립트 사전 스터디를 진행하면서 다양한 데이터 유형의 타입 지정 방법을 배우긴 했지만, 실무 코드에서 자주 보이는 RefObject나 AxiosInstance 같은 세부적인 타입들은 충분히 다루지 못했던 것 같습니다. 스터디에서는 주로 원시값, 객체, 함수, 그리고 함수 반환 타입 정도만 다뤘기 때문에, 이런 더 복잡한 타입들을 어떻게 공부하면 좋을지 궁금합니다!\n\n흠.. 저는 각잡고 타입스크립트를 공부해본적은 없어서요 ㅎㅎ 대략적인 개념만 이해한 다음에 실무적으로 접근하는게 제일 좋은 방법이라고 생각해요.\n\n타입에 대한 이해를 점진적으로 높여가는거죠.\n특히 제가 막 타입스크립트에 익숙해질 시점에 ChatGPT가 나와서 GPT에게 타입만 주구장창 물어봤던 것 같네요 ㅋㅋ\n\n그럼에도 불구하고 공부를 해보고 싶다면\n\nhttps://github.com/type-challenges/type-challenges\n\n이런 저장소가 있어요.\n알고리즘 문제를 풀이하듯이, 타입에 대한 input/output을 설계해보는거죠.\n\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/57"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "수고했어요 현지! Hard 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\nAI와 Q&A 형식으로 학습한 내용이 좋았어요. \"removeInstance에서 왜 재귀로 가져오는가?\"라는 질문, 좋은 질문이에요. Fragment와 Component는 실제 DOM이 아니니까 그 안에 있는 실제 DOM을 찾아서 삭제해야 한다는 걸 이해한 거죠. 이렇게 \"왜?\"라고 질문하면서 AI 답변을 받는 방식이 단순히 코드만 받는 것보다 훨씬 효과적입니다.\n\n\"테스트 코드가 있으니까 AI가 더 잘 작성하는 것 같다\"는 인사이트도 좋았어요. 맞아요. 테스트는 명세서 역할을 하거든요. AI든 사람이든 \"뭘 만들어야 하는지\" 명확하면 더 잘 만들 수 있습니다. 이건 실무에서도 마찬가지예요.\n\n\"코드 품질 - AI가 작성해서 없습니다\"라고 솔직하게 적은 것도 좋아요. 다음 단계는 AI가 작성한 코드를 본인이 리팩토링해보는 거예요. \"이 부분은 왜 이렇게 했지? 더 나은 방법은 없을까?\" 하면서요.\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. \"오픈소스를 공부해보는 기분\"이라고 했는데, 정확해요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 됩니다. 이번에 그 방법을 배웠기를 바라요.\n\n다음 챕터는 설계입니다. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 해요. 수고했습니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/45"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전이진",
    "feedback": "이진님 고생하셨습니다!\n구현해야 하는 기능 모두 깔끔하게 잘 구현하셨네요 :+1\n회고도 잘 정리해주셨구요. 내부적으로 사용하는 재조정이라거나 큐로 처리하는 방식같은것들도 잘 검토해주신 것 같습니다 ㅎㅎ\n\n> 제가 구현한 버전에서는 queueMicrotask + 플래그를 통해 batching을 구현했고, React도 내부적으로는 한 이벤트 루프 안에서 여러 setState를 하나의 렌더링으로 묶는 방식을 사용하는 것 같습니다.\n\n아무래도 가볍게 구현한 컨셉이기 때문에 실제 구현과는 약간 차이가 있지만!\n질문 주신비동기적으로 배칭처리를 하기 위해 동기적으로 렌더링을 하지 않는다라는 관점은 정확합니다! \n리액트 18이후  동시성을 구현하기 위해 queueMicrotask뿐만 아니라 다양한 최적화 방식을 적용했다고 알고 있는데요. 여유가 있다면 이 부분도 함께 챙겨보셔도 좋을것 같습니다.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/17"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "전희재",
    "feedback": "안녕하세요 희재님! 5주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 지금 구현한 접근 방향이 맞는지, 리액트의 철학에 따르는지가 궁금합니다.\n\n정상적으로 동작하면 접근 방향은 동일한거겠죠 ㅎㅎ?\n마찬가지로 리액트의 척할에 따른 인터페이스이기 때문에 마찬가지로 철학에도 적합하다고 생각해요.\n\n다만 조금 더 고민해보면 좋을 점은, react는 모노레포로 패키지를 관리하고, 각각의 패키지를 조합해서 구현하고 있어요. DOM을 다루는 부분을 아예 별도로 관리하는 방식이랄까.\n\n이런 관점에서 생각했을 때, 어떻게 코드를 분리하면 좋을지 고민해보시면 좋답니다!\n\n> 역순으로 anchor를 정하는 방법 외에도 많은 방법이 있을 것 같습니다. 현재는 코드를 구현하다보니 로직이 너무 복잡해진 것 같은데, 이게 리팩토링이 안되어서 그렇게 보이는건지, 아니면 더 나은 방안이 있을지 궁금합니다.\n\n복잡할 수 밖에 없는 로직이라고 생각해요 ㅎㅎ 실제 리액트는 훨씬 더 복잡한데, 그 중의 핵심 개념을 최대한 압축한거니까요. 희재님이 상상하는 \"복잡하지 않은 모습\"은 어떤 모습일까요?\n\n현재 코드를 리팩토링하고 구조화를 잘 한다고 해도 최소한의 복잡도는 있을 수 밖에 없는.. 그런 내용들이라고 생각합니다 ㅠㅠ\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/3"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "정나리",
    "feedback": "안녕하세요 나리님! 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 과제를 진행하면서 먼저 이론을 학습하고 -> 그에 대한 구현을 다시 해보려고 했습니다. 그래서 AI로 구현하고 -> 그 코드를 기반으로 이해를 더하고 -> 다음에 구현 계획이었는데, 혹시 먼저 구현을 어떻게 할지를 먼저 고민했다면 더 학습에 좋았을까요? 다른 주차에 반영해보면 좋을 것 같아서 질문드립니다!\n\n사람마다 스타일이 다르다고 생각해요 ㅎㅎ 나리님의 성향상 \"why?\"를 먼저 고민하고 싶다면 그렇게 해도 무방하답니다!\n저는 순서가 중요하진 않다고 생각해요. 결국 \"결과물\"과 \"나의 이해도\"가 어느 수준까지 올라갈 수 있느냐가 중요한거라 과정은 내가 원하는대로, 비순차적으로 수행해도 무방하답니다!\n\n> 세부적인 구현들 - 어떤 타입을 어떻게 처리하고 왜 처리하고, 중첩 구조는 어떻게 처리하고... 이 코드를 보고 이해하는 것도 다소 어려웠습니다. 구체적으로는 아래 enqueue와 withEnqueue 부분이었는데요, 이런 부분을 좀 더 잘 이해하고 파악하려면 어떤 연습을 하면 좋을까요?\n\ndebugger 같은걸 사용하면서, 현재 함수가 실행될 때 어떤 변수에 어떤 값이 할당되어있는지를 토대로 파악해보면 훨씬 쉽답니다!\n\n고생하셨습니다~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/5"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "안녕하세요 민수님! 5주차 과제 쉽지 않았을텐데 잘 진행해주셨네요 ㅎㅎ\n\n> 코드를 뜯어보며 동작 원리를 확인하던 중, createVNode가 어떻게 명시적으로 사용되지 않으면서 jsx를 노드로 변환시킬까? 하는 궁금증에 동작 원리를 찾아보았다. 그러면서 문득 이전 리액트 16 이전에서 jsx 파일에서는 꼭 react를 Import 해야 했던 것이 떠올랐다. 혹시 createVNode가 사용되는 방식처럼 리액트 내부에서 jsx를 node로 변환하기 위해 리액트가 import 되어야 했던 걸까? 하는 생각에 관련된 내용을 찾아보니 React.createElement를 사용해서 jsx를 변환하기 위해서라는것을 알 수 있었다. 그 외에도 dom 조작을 줄이기 위한 여러 방법들에 대해 막연하게만 그렇게 진행되지 않을까? 했던 부분들, createDocumentFragment의 활용이나 diff의 과정, 어째서 false는 html에 남지 않는지 등등에 대한 궁금증을 해소할 수 있었다.\n\n지금도 항상 import를 해야되긴 합니다 ㅋㅋ 그걸 babel이 자동으로 해주고 있죠. 트랜스파일된 결과물을 확인해보면 알 수 있어요!\n\n> 아마 요즘 리액트를 많이 뜯어본 것이 바로 문제의 원인을 추측하는데 도움이 되지 않았을까? 생각한다.\n\n실무적으로 도움이 되었다니 정말 다행이네요!! \n\n--\n\n고생하셨습니다 민수님!!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/52"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "수고했어요 재윤! Easy 기본 과제랑 심화 과제 모두 통과한 거 축하해요.\n\n회고를 보니까 처음에 AI로 Hard를 통과시키고 이해하려 했다가 막혀서, 결국 Easy부터 다시 시작한 과정이 보이네요. 이게 오히려 좋은 판단이었어요. \"모르는 걸 알게 됐다\"는 표현이 정확합니다. 뭘 모르는지 아는 게 학습의 첫 단계거든요.\n\n멘토링에서 배운 \"구조화 학습\" 이야기가 인상깊었어요. useState의 정의 → 등장 배경 → 이전보다 뭐가 나아졌는지 → Hook이란 뭔가 → ... 이렇게 마인드맵처럼 펼쳐나가는 방식, 정말 좋은 학습법입니다. 파편화된 지식을 외우는 것과 흐름을 이해하는 건 완전히 다르거든요. 특히나 코드가 아니라 데이터의 흐름으로 시각화해서 이해하려고 하는건 정말 중요한 방법이니 아주 잘했습니다!\n\nQ) 평탄화에 관한 코드중 flat(Infinity) vs for 문 + 재귀 형식의 방식 어떤게 더 효율적일지 궁금합니다.\n=> flat(Infinity) vs 재귀는, 현재 규모에서는 둘 다 괜찮아요. 예전 자바스크립트 버전에서는 for문이 더 성능적으로 좋았지만 flat이 native 스크립트이기에 점점 성능이 비슷해지고 있어요. 그렇다면 flat이 더 깔끔합니다. createElement에서 평탄화 과정에 추가될 만한 로직은 거의 없어요. 단순 평탄화니까 flat으로 충분합니다.\n\nQ) Fiber에서 누락된 핵심 개념들이 좀 보이는거 같습니다, 현재는 Instance 하나만 관리하는데 Fiber는 2개의 트리를 번갈아 사용 부분이나, 작업을 중단하고 재개하는 부분, 우선순위 스케줄링 등 이 빠진거같은데, 코치님은 이런거까지 모두 다 구현해보신 경험이있으신가요?\n=> 하하! 저는 fiber 이전에 공부할때 구현했어서 diff와 key 수준에서만 구현해봤어요. 이후에 fiber 엔진 교체할 때에는 그렇구나... 하고 그냥 이해만 하고 넘어갔답니다. ^^;;;; 재윤은 꼭 해보세요 ㅎㅎ\n\nQ) WeakMap 사용을 고려해야 하는 시점은 언제인가요? 현재는 Map으로만 구성되어있는데, 제가 알기로는 강한 참조 약한참조의 차이도 있지만, 메모리 누수가 발생할 가능성 때문에 WeakMap 을 사용한다고 알고있는데, 이런 부분에 대해서 체감되는게 없는거같아요,\n=> WeakMap은 객체를 키로 쓰면서, 그 객체가 다른 곳에서 더 이상 참조되지 않으면 자동으로 GC되길 원할 때 사용해요. Map은 키에 대해 강한 참조를 유지하기 때문에, Map에 키로 들어간 객체는 Map이 존재하는 한 GC되지 않거든요. DOM 노드를 키로 쓸 때 특히 유용한데, DOM이 문서에서 제거되어도 Map이 참조를 유지하면 메모리에 계속 남아있기 때문이에요. DOM이 키가 되는 경우 WeakMap을 쓰는 것을 고려해보세요.\n\nQ) 요즘 구현하면서 막히는 부분을 AI에게 자주 물어보게 되는데, 그러다 보니 내가 직접 깊게 생각해보는 시간이 줄어드는 것 같고, AI 없이 하면 너무 오래 걸리거나 아예 못할 것 같은 불안감도 생깁니다. AI 도움을 받으면 편한데, 그만큼 제 사고가 AI가 알려주는 수준에서 멈추는 건 아닐까 걱정이 됩니다. 이런 상황에서 스스로 고민하는 시간과 AI 도움을 받는 시간을 어떻게 균형 잡는 게 좋다고 생각하시는지, 어떤 방식으로 학습하는 게 장기적으로 더 성장할 수 있는지 조언을 듣고 싶습니다.\n\n=> AI 의존도 질문이 제일 중요한 것 같아요. 좋은 고민입니다. AI를 \"답을 얻는 도구\"로 쓰면 사고가 멈추고, \"질문하고 검증하는 도구\"로 쓰면 오히려 깊어져요. \"이거 어떻게 해?\" 대신 \"내가 이렇게 이해했는데 맞아?\"로 질문하는 습관을 들여보세요. 그리고 왜 그런거야? 뭘 해보면 좋을까? 어떻게 생각해? 내가 왜 이렇게 만들었을것 같아? 등등 HOW가 아닌 것들을 물어보려고 해보세요. 오히려 AI가 있는 지금이 훨씬 더 공부를 하기에 더 좋은 환경이라고 생각합니다!\n\n마지막에 죄송하다고 했는데, 전혀 그럴 필요 없어요. Easy부터 다시 시작하고 개념 학습에 시간을 투자한 게 오히려 올바른 방향입니다. Hard 재작업도 천천히 해보세요. 수고했습니다!",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/40"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "천진아",
    "feedback": "안녕하세요 진아님~ 5주차 과제 쉽지 않았을텐데 무척 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 코치님은 보통 학습을 할때 어떤 과정을 거치시나요? (00을 공부해봐야지 -> 일단 개념을 공부해본다/일단 써본다 등) '00을 공부해봐야지' 라는 생각을 어떤때에 하시게 되나요?\n\n흠.. 저년차일때는 재미로 했던 것 같아요. 관심있는 기술이 있을 때 딥다이브를 해보는거죠 ㅎㅎ\n그런데 지금은 \"필요할 때\" 하는 것 같아요. 제가 지금 해결해야 하는 문제가 있고, 그 문제와 관련된 기술이 있을 때 조금 더 파고들어가보는거죠.\n\n근데 옛날처럼 딥다이브를 해본적이 최근에는 거의 없는 것 같네요 ㅋㅋ;\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/7"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "고생하셨습니다 선민님!\n전체적으로 잘 구현해주셨고, 테스트도 모두 통과했지만 앱을 동작시키는데 있어 장바구니 수량을 늘린다거나, 하나 추가시 새로운게 추가되지 않는 올바르지 않은 기능들이 있어 심화 과제는 불합격 처리 했습니다 ㅠㅠ\n\n> Fiber / 스케줄링 / 우선순위 설계에 대한 힌트\n\n좋은 고민인데요! 말 그대로 Fiber의 구현을 따라해보고 싶다 인 것 같은데요. 중단, 재개를 하기 위해서는 스케줄링 로직은 renderElement 바깥쪽 별도 레이어에 두는 것이 맞는 것 같습니다. 재조정 함수가 항상 작업 단위인 Fiber를 호출하고 종료되게 하고, 바깥쪽 루프에서 작업을 판단하고 중단된 작업들에 있어 이어갈 수 있는 구조를 만들어야 합니다. 리액트에서는 이걸 링크드리스트를 활용해 구현한것 같아요. \n\n> 렌더/커밋 단계 분리와 Effect 처리에 대한 방향성\n\n음..개인적으로는 renderElement 내부가 아니라 재조정이 완료된 후 반환된 변경점들을 처리하는 별도의 커밋 함수를 만들어 처리하는게 자연스러울 것 같습니다! \n\n> createVNode 와 normalizeVNode 책임 경계에 대한 검토\n\nnormalizeVNode에 있어서는 reconciler가 소비하기 위한 데이터를 정제하는 단계로 두고 말그대로 표준화를 하는 역할로만 두고 VNode를 만드는 함수는 개발자가 사용하는 API관점에서 접근을 하는게 좋지 않을까 싶습니다!\n\n> Node.TEXT_NODE 같은 DOM 상수를 굳이 써야 하는 이유가 있는지\n\n사실 상수화, 타입화를 해서 사용한다는 관점에서 실수가 없도록 구현하기 위함이라고 보는데요. 크게 성능적 관점에서 접근하기 보다는 전체를 관통하는 타입이기에 실수 없이 다룰 수 있는 방법에 대해 고민하는거다라고 봐도 무방하지 않을까 싶어요! \n\n> preview 에서는 정상, 배포 후에는 깨졌던 CartModal 수량 버튼 이슈와 CartItem 리팩터링\n\n앗 저는 여전히 배포된 환경에서 문제가 발생하고 있는데요..!\n어쨋든, 결국 문제를 파악하고 개선하기 위해서는 동일한 환경을 만들고 테스트를 하는것이 필요한데요.\n결국 프로덕션 레벨, 빌드를 한 결과를 사용할 때 발생할 수 있는 문제에서 찾아야 하는데, 코드 레벨에서 빌드된 결과를 실행해보면서 접근을 해봐도 되고 소스맵을 활용해서 각 코드 지점들을 디버깅해봐도 좋을것 같아요.\n찰스 같은 프록시 도구를 활용해보면 각 파일들을 조작해서 실서비스에서 디버깅하는것처럼 조작할 수 있는데 이런 방식도 많이 사용하는것 같습니다.\n\n질문들이 모두 꽤 어려워서 깜짝 놀랐는데 그만큼 깊게 고민을 많이 하셨다는 뜻이겠죠! 고생하셨고 다음주 과제도 파이팅입니다~~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/56"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "한세준",
    "feedback": "안녕하세요 세준님~ 5주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n특별한 질문은 없는 것 같아서 피드백은 바로 마무리하겠습니다. \n궁금한점이 생기면 디스코드로 언제든 문의주세요! 감사합니다~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "채은님 고생하셨습니다 ㅠㅠ\n조건에 맞게 vnode에 대한 동작들을 정의하려는 부분들은 코드를 작성하려고 하셨던 것 같은데, 과제를 완성시키시지는 못했네요.\n제가 조금 이르게 봤을 수 있는데, 꼭 여유 있으실 때 과제 완성시키시고 팀원분들과 피드백 나눠 보시면 좋을것 같아요!\n\n다음주도 화이팅입니다~",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/49"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "[7팀 황준태] Chapter2-2. 나만의 React 만들기 #59\n\n수고했어요! Easy 기본 과제랑 심화 과제 모두 완료한 거 잘했습니다.\n\n\"AI로 먼저 구현 후 코드 지우고 다시 작성하는 방식\"으로 진행했다고 했는데, 이건 좋은 학습 사이클이에요. 핵심은 \"다시 작성\"하는 단계거든요. 그 과정에서 진짜 내 것이 됩니다.\n\nbabeljs.io에서 직접 JSX 변환을 실습해본 것도 좋았어요. 스크린샷까지 첨부했네요. 이렇게 \"직접 눈으로 확인\"하는 습관이 중요합니다. useState가 fiber의 memoizedState에 저장되고 연결 리스트로 상태를 찾아간다는 것까지 파악한 건 꽤 깊이 들어간 거예요.\n\n학습 방법 질문에 답변드릴게요. 노트에 그림 그려가면서 공부한 건 좋은 방법이에요. 저도 비슷하게 하는데, 핵심은 \"내가 이해한 걸 남에게 설명할 수 있는가\"예요. 글을 읽기만 하면 이해한 것 같지만, 막상 설명하려면 막히거든요. 그래서 그림을 그리거나, 짧게라도 글로 정리하거나, 누군가에게 설명해보는 게 효과적입니다. 이번에 회고에 적은 것처럼 \"memoizedState에 저장되고 연결 리스트로 찾아간다\"라고 본인 언어로 정리한 게 바로 그 방법이에요.\n\n중요한건 아는 사람에게 설명하는 수준이 아니라 \"모르는 사람을 이해시킬 수 있을 정도의 설명\"이라는 거에요. 정말 모르는 주변사람에게 설명하거나 알려주는 기회를 가져보려고 하거나 혹은 AI에게 설명하면서 제대로 설명하고 있는지등을 계속 검증해보면 좋습니다.\n\n이해의 단계에는 스펙트럼이 있어요. => 오 이런게 있네 -> OK 알겠다 -> 와... 완전히 이해했다. -> 아..! 그게 이래서 그런거였구나 -> 아 그건 말이지... 이런거야 등 내가 어떤 개념을 이해한다는 것에는 다양한 스펙트럼이 있어요. 우리의 뇌는 효율을 추구해서 적당히만 알아도 안다고 치고 넘어갑니다. 그렇지만 정보접근 -> 지식습득 -> 이해 -> 깨달음 -> 설명가능 -> 나아가 모르는 사람에게 정보전달 가능 -> 모르는 사람에게 지식습득 가능 -> 이해 -> 깨달음 까지 가능한 수준까지 학습과 이해에는 너무 다양한 수준이 있습니다.\n\n=> 또한 왜 그런지 1차적으로 알고 있거나 혹은 그 원리나 이면까지 혹은 그 역사적 배경이나 다른 관점의 융합 혹은 유사한 개념 다른 개념들까지 더 깊게 혹은 연관되어 넓게 연결해서 이해하는 것들도 있죠. 이렇게 이해의 스펙트럼에 대한 부분이 선명해지면 내가 AI를 쓰더라도 얼마든지 \"왜 이렇게 되는거야?\" \"다른 방법은 없어?\" \"언제부터 이 방법을 썼어?\" \"그전에는 어떻게 했는데?\" \"이게 베스트 프랙티스야?\" \"트레이드 오프는?\" 등등 다양하게 물어가면서 선명도를 높일 수 있습니다. AI를 더 잘 쓸 수 있는 좋은 방법들을 많이 찾아보길 바래요!\n\n\n이번 과제의 핵심은 평소에 쓰던 것들의 동작 원리를 직접 구현해보면서 이해하는 거였어요. 깊이를 내려가고 싶다면 그 영역의 핵심 컨셉만 한번 직접 구현해보면 됩니다. 이번에 그 방법을 배웠기를 바라요.\n\n다음 챕터는 설계예요. 아는 것들을 어떻게 잘 관리하고 개선할 수 있는지에 대한 체계를 함께 배워보도록 합시다. 수고했습니다!\n",
    "assignment": {
      "name": "STEP10 React 아키텍처 해부하기 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter2-2/pull/59"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/48"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/1"
    }
  },
  {
    "passed": true,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/19"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/36"
    }
  },
  {
    "passed": true,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/13"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/47"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/14"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/5"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/10"
    }
  },
  {
    "passed": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/43"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/40"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/37"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/7"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/34"
    }
  },
  {
    "passed": true,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/16"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/33"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/45"
    }
  },
  {
    "passed": false,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/50"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/2"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/44"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/39"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/11"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/30"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/12"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/28"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/4"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/38"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP11 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/32"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "안녕하세요 승훈님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n기본과제 요구사항에 스토리북이 포함되어있는데 스토리북 작성이 안 되어있네요..! ㅠㅠ\n다만 과제에 무척 몰입해주셔서 기본과제는 합격으로 남겨놓도록 하겠습니다! 고생하셨어요~!\n\n> tailwind의 namespace 충돌을 어떻게 해결할 수 있을까요?\n\n이건 tailwind의 규칙을 따르는게 최선이라고 생각해요. 아니면 이렇게 시도해볼 수 있을 것 같아요.\n\n```\n// css\n@theme {\n  /* Base Colors */\n  --brand-500: #3b82f6;\n  --brand-600: #2563eb;\n\n  /* Semantic Tokens */\n  --color-primary: var(--brand-500);\n  --color-primary-hover: var(--brand-600);\n\n  --color-text-default: #111827;\n  --color-text-muted: #6b7280;\n\n  --color-bg-default: #ffffff;\n  --color-bg-muted: #f9fafb;\n}\n\n// tsx\n<button className=\"px-4 py-2 rounded bg-[var(--color-primary)] text-white hover:bg-[--color-primary-hover]\" >\n  Save\n</button>\n```\n\n혹은 tailwindcss 에 종속적이지 않은 별개의 테마 시스템을 만들어서 사용하는거죠 ㅎㅎ\nemotion같은걸 이용해서 시도해볼 수 있답니다!\n\n> 3계층 토큰화, 정말 필요할까요?\n\n저는 있으면 좋다고 생각해요 ㅎㅎ\n저희 팀에서도 3계층으로 만들어서 사용하고 있습니다.\n\n일단 1~2계층은 \"전사\"를 기반으로 사용하고, 3계층은 \"프로덕트\" 기반으로 정의해서 사용하는거죠.\n\n꼭 정답이라고 할 수는 없고, 상황에 맞게 유연하게 대처하면 된다고 생각해요!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/48"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "고생하셨습니다 다솜님!\n디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! cva나 twMerge같은 유틸 함수도 잘 분리해서 사용해주셨구요. \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n\n> 1. 제네릭 hooks의 타입 설계\n\n말씀해주신 것처럼 타입을 줄이는 방법도 있고, 방법은 여러가지가 있겠지만 지금은 크게 복잡하지 않은 상태이니 가능한 큰 시나리오에 대비해서 작업을 하기 보다는 그것보다 작은 관점에서 개선을 하고 점점 복잡한 시나리오를 대응해나가는 방법도 좋을것 같아요. 액션에 종속되는 데이터 타입을 만들어서 맵처럼 구성해 사용하고 나중에 좀 더 복잡한 시나리오가 생긴다면 분리된 제너릭 형태로 다양하게 대응되게 하는게 좀 더 가독성이 좋지 않을까..! 싶기는 합니다. \n\n> 2. Zod schema와 Form 타입의 관계\n\ninfer를 활용해 SSOT을 지키려고 하시는게 추후 버그를 방지하는데 있어 큰 역할을 할거에요! 추론이 불가능한 부분에 대해서만 수동 타입을 정의하는게 좋습니다.\n\n> 3. 컴포넌트 폴더 구조의 선택\n\n개인적으로는 이 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\n> 4. Constants 중앙화의 범위\n\n저는 개인적으로 해당 파일에서만 하면 해당 파일에 두고 여러 곳에서 사용할 수록 분리해서 모듈에서 관리하는데요. 개인적으로도 다솜님 말씀처럼 한 파일에서 관리하면 가독성이 안좋아지고 비대해진다는 관점에서 각 파일 또는 도메인 별로 분리해서 관리하고 사용했던 것 같아요. 굳이 배럴파일은 안만들구요. \n\n> 5. 타입 단언의 적절한 사용\n\nhttps://www.vinuteam.com/blog/28 요기 글 보면 coerce같은 기능들이 있는데요. 단언을 하기보다는, 관련 기능들을 활용해서 타입을 맞춰보면 좋을것 가타요!\n\n> 6. TailwindCSS의 실무 활용 경험\n\n저도 과거 css 클래스를 나누는 경험이 더 익숙하던 사람이라.. 처음에 나왔을 때 이 사실을 받아드리지는 못했었는데요. 결국 css로 작성하더라도 캡슐화 되어있던 여러 css들의 우선순위나 네이밍 문제, (변수가 잘 활용되기 어렵던 과거 환경에서의) 토큰 강제가 어려운 점들이 있었습니다. 이런 점들에 있어서 다솜님이 구성해주신 여러 유틸 함수들을 활용해 덧붙이는 형태로 로직을 그대로 드러나게 해서 오히려 문제를 해결해 많이 활용하게 되었던 것 같아요. 그리고 css-in-js의 런타임, 빌드 시간 등 문제도 겹쳤던 것 같구요.(지금은 아니지만) \ntailwind를 사용해도 저걸 꼭 분리하지 않고 작성해야한다는 것은 아니니까 컴포넌트 화 또는 유틸리티 클래스를 활용해서 기존 장점을 누리려고 해보시는 것도 좋을 것 같습니다.\n\n고생하셨습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/25"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "안녕하세요 정원님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) 3단 레이어 구조의 실용성: 신규 팀원 온보딩 시 \"이 색상을 바꾸려면 어디를 수정해야 하지?\"라는 질문에 대한 학습 곡선이 어느 정도일지요?\n\nA)\n음.. 견고한 설계일수록 학습 비용은 올라갈 수 밖에 없다고 생각해요. 팀의 철학을 온전히 이해하는 과정이 생각보다 오래걸린달까?\n\n가령, 함수형 패러다임의 경우 이게 \"좋다는 것\"은 누구나 알지만 이걸 \"학습하고 활용하는 것\"은 완전히 다른 문제입니다.\n\n단순히 디자인 토큰에 대한 이해 뿐만 아니라 디자인 시스템의 철학이나 이걸 왜 사용해야 하는지 어떻게 활용해야 하는지 어떤 상황에 이점이 있는지 등을 알아가는건 쉽지 않죠.\n\n그래서 적절한 트레이드오프를 판단하기 위해선 현재 내가 수행하고 있는 프로젝트에 대한 이해가 필요하다고 생각해요. 단순히 디자인 시스템 하나만 보고 판단하기는 어려울 수 있죠.\n\n근데 잘 생각해보면.. 1주일 정도면 충분히 이해할 수 있지 않을까요?\n\nQ) HEX + var() 참조 방식의 협업 영향: HSL 직접 정의 대신 HEX + var() 참조로 변경한 이유가 \"단일 진실 공급원\"이었습니다. Figma 등 디자인 툴에서는 주로 HEX를 사용하는데, 이 방식이 디자이너 핸드오프 시 장점이 될 수 있을까요? 반대로, shadcn/ui가 hsl(var(--primary)) 패턴을 쓰는 이유(opacity 조작 용이)를 포기한 것에 대한 트레이드오프는 어떻게 보시나요?\n\nA)\n흠... 디자이너마다 다르지 않을까요? hsl을 잘 쓰고 싶다면 이걸 회사 혹은 조직의 정책으로 가져가야 한다고 생각해요.\n어떤 회사에서는 이러한 방식이 익숙할 수 있고, 어떤 회사에서는 익숙하지 않을 수 있으니까요 ㅎㅎ\n\n일단 제가 속한 조직에서는 익숙하게 사용하는 방식은 아니라는점..! 그래서 이야기 드리기가 어렵네요\n\n\nQ) Dark Mode 토큰 설계: 현재 .dark 클래스에서 Semantics 토큰을 재정의하는 방식입니다. 고대비 모드(prefers-contrast: high) 나 시스템 테마 자동 감지 같은 추가 요구사항이 생기면 현재 구조에서 확장이 용이할까요? prefers-color-scheme: dark와 .dark 클래스 토글 방식을 병행하는 것이 좋을지, 하나로 통일하는 것이 좋을지 다른 분들의 의견이 궁금합니다.\n\nA) 수동으로 토글하는 방식도 있고, 시스템에 동기화 하는 방식도 있기 때문에 두 가지 모두 지원하면 좋지 않을까요!? 보통 수동으로 이걸 다루기보단 라이브러리나 프레임워크 레벨에서 제공하는 경우들이 많은 것 같아요 ㅎㅎ\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "고생하셨습니다 연욱님!\n아쉽게 심화 과제까지는 마무리 못하셨지만 잘 구현하셨어요!\n많은 곳들에서 사용중인 디자인시스템을 어떻게 구현하는지, 그리고 그 부분에 있어 사용하는 기술들에 있어 어떤 장단점들을 누릴 수 있는지 간접적이나마 느끼셨다면 좋겠네요.\n\n> 과제에 대한 내용은 아니지만 이직과 관련해 질문이 있습니다!\n\n멘토링때 관련된 질문을 들었다면 더 자세히 이야기를 해볼 수 있었을 것 같은데요. 우선 잘 할 수 있습니다. 하지만, 당연히 잘 되려면 그만한 수반되는 여러 경험들과 공부가 있어야겠죠. 우선 지금 있는 팀원들이 어떤 경험을 했는지 그리고 다른 팀원분들한테도 물어봐서 어떤것들을 경험했는지 한번 정리해보세요. 그리고 그 부분에 있어 프런트엔드 개발자에게 어떤역량을 의미하는지 비교해보고 커리어적으로 도움이 될 수 있는 경험인지 자체적으로 판단해보세요. 저한테 물어보셔도 좋구요! 그리고 일단 그 부분에 대해 부족한 부분들을 자체적으로 회사에서 채울 수 있는 노력을 하면 가장 좋고, 아니라면 혼자 공부를 해야겠죠. \n\n과거처럼 이직 시장이 따뜻했다면 크게 문제는 없었겠지만, 지금은 너무 추운것 같아요. 안된다는 것은 아니지만 추워진 만큼 그만큼 더 열심히 해야 하는 것은 맞는 것 같아요. 결국 절대적으로 뭔가를 해야지만 합격을 하는게 아니라 옆에있는 경쟁자들보다 잘하면서 그 자리에 내가 더 잘 맞아야 합격하는것이니까요. 경력에 있어서 엄청 특별한 경험을 하는 분들은 이야기 해보면 크게 없을거에요. 경험적인 부분, 하드 스킬 뿐만 아니라 소프트 스킬 부분까지 내가 경쟁자들에 비해 그 자리에 어떤 점이 더 뛰어나고 잘 맞는 사람인지 어필해보는 점을 찾아봐야 합격할수 있을것 같아요.\n\n다음 주도 화이팅입니다. 고생하셨어요!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/19"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "지현님 안녕하세요 ㅠㅠ\n코드 작업은 해주셨던 것 같은데, 따로 배포도 안해주시고 저장소 실행해봐도 구성을 따로 해주신 부분은 없는 것 같네요 ㅠ\n각 단계에 맞춰서 기능이 온전히 다 구현되어있기 어려워서 불합격 드렸습니다. 아쉬운데 꼭 여유 있으실 때 마무리 잘해보고 다른 팀원분들과 의견 많이 나눠보시면 좋을거 같습니다.\n다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/36"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/29"
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "잘했어요 대현! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 최신 기술의 방향성을 체득하는 것이 목표였습니다. 태스크 매니저 에이전트를 만들어서 학습 과정 자체를 관리한 접근이 인상적이었어요. 이제는 어떻게 하는 법이 아니라 이런 응용력이 더 실력의 변별력이 되어간다 생각하는데 멋지네요.\n\n테스트 코드와 Radix Select가 충돌했을 때 NativeSelect를 선택한 것도 좋은 판단이었습니다. 이론적으로 완벽한 것보다 팀의 현재 상황에 맞는 걸 선택하는 게 실무니까요.\n\nQ) Atomic Design 폴더 구조를 제거하고 components/ui, components/forms, components/tables 등으로 재구성했습니다. 그런데 작업 중 \"이 컴포넌트는 어느 폴더에 넣어야 하지?\"라는 판단이 자주 흔들렸습니다. FSD(Feature-Sliced Design)가 대안으로 자주 언급되는데, 소규모 프로젝트에서는 feature별 폴더 중복이 오버헤드처럼 느껴집니다. 프로젝트 규모에 따라 어떤 폴더 구조를 선택하시는지, 또는 FSD를 미리 연습해두는 게 실무에 도움이 될지 조언 부탁드립니다.\n\n=> 맞아요. 처음에는 폴더를 구분할때 역할을 중심으로 구분하면 1차구조는 쉽습니다. 그렇지만 곧 2차 구조가 필요하다고 느끼죠 components 폴더안에 100개씩 파일이 있으면 인간은 피로도를 느끼고 정리를 하고 싶어지니까요. 사실 어떤 폴더구조가 좋으냐? 라고 물어 본다면 어떤게 좋다라고 말할수는 없지만 원칙은 있습니다. 외울게 적고 에측하기 쉬운 구조죠. FSD가 주목받는 이유는 이미 유명해져 이름을 외우기가 쉽고 외워진 이름을 토대로 예측가능하다는 점에 있습니다. 미리 연습을 한다는 건 어떻게가 아니라 왜 이러한 방식이 더 좋다라고 하는가겠죠.\n\n=> 외울게 적고 예측하기 좋은 폴더 구조는 나에게도 그렇지만 누구에게도 그래야 합니다. 처음에는 대부분 역할별로 시작합니다. /components /libs /serevice를 모르는 사람은 없으니까요. 2차 폴더링의 경우에도 폴더명을 보고 무엇이 들어있을지 예측이 된다면 좋은 폴더명입니다. /componets/mocuels보다는 /components/tables가 훨씬 더 뭐가 들어있을지 예측하기 쉽죠. FSD의 경우 2차 폴더구조를 최대한 도메인이나 엔티티의 이름을 사용하고 나머지의 이름을 고정하면서 외우기 쉽고 예측하기 쉽도록 하고자한 의도가 있습니다.\n\n=> FSD를 미리 연습해두면 좋습니다. FSD만 연습하기 보다는 지금 하고 있는 폴더구조를 객관적인 눈에서 예측하기 쉬운 구조인가? 아닌가? 를 바탕으로 판단해보세요. 그리고 어떻게 이름을 바꾸면 혹은 구조를 만들면 더 외울게 적고 예측가능한가를 고민해보는 그 노력이 큰 도움이 될거에요!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/17"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "안녕하세요 도현님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) CVA를 모든 컴포넌트에 적용하는게 좋을까요? 지금은 PageHeader와 ManagementStats 같이 variants가 명확히 필요한 컴포넌트에만 적용했는데, 일관성을 위해 모든 커스텀 컴포넌트에 적용하는게 나을까요? 제 생각엔 variants가 2개 이상 필요한 컴포넌트에만 적용하는게 맞는 것 같긴 한데, 실무에서는 어떻게 하시는지 궁금합니다.\n\nA)\n모든 구간에 적용할 필요는 없다고 생각해요! 말씀하신 것 처럼 필요할 때 확장하는 방식으로 만들어가면 어떨까요!?\n\n---\n\nQ) shadcn/ui 컴포넌트를 수정할 때 두 가지 방식이 가능한데 어떤게 좋을까요?\n\nA)\n저는 방법1이 좋다고 생각합니다. shadcn의 철학 자체가 \"쉬운 커스텀\"이라고 생각해요. 그래서 패키지를 통해 제공하는게 아니라 내재화 하여 제공하는거라서요!\n\n\"나중에 업데이트를 받거나 변경사항을 추적하기 어려울 것 같아서 고민입니다. (미리 안쓰는 기능이나 스타일링을 다 지워둔다면 문제 없을 것 같긴합니다)\" 라고 말씀해주셨는데, 어떤 디자인 시스템이든.. 업데이트하면 추적하기가 어려운건 비슷합니다 ㅋㅋㅋ 보통 대규모 공사를 한달까..\n\n---\n\nQ) shadcn/ui 컴포넌트들을 보면 다양한 props와 기능이 기본으로 제공되는데, 프로젝트에서 안 쓰는 기능들은 미리 지워두는게 좋을까요?\n\nA) 웬만하면 보존하는게 좋다고 생각해요. 대체로 Primitive 유형의 컴포넌트일텐데, 이런 친구들은 확장성을 최대한 고려해줘야 나중에 손이 덜 갔었어요.\n\n---\n\nQ) 프로젝트 디자인 시스템이 shadcn/ui 기본 스타일과 많이 다르다면 아예 variants를 재정의하는게 나을까요, 아니면 필요한 부분만 오버라이드하는게 좋을까요?\n\nA)\n흠.. 개인적으로 variants를 아예 재정의 하는게 좋다고 생각합니다! 우리 팀의 테마 시스템을 만드는거죠 ㅋㅋ\n그리고 만에하나 (대체로 그럴일은 없겠지만?) 다른 디자인 시스템으로 교체한다고 했을 때 테마 시스템은 유지를 해줘야 쉽게 엎어칠수 있어요.\n\n---\n\nQ) 이번 과제를 하면서 Design Token으로 spacing 같은 경우에는 sm, md같은걸 미리 정의해두지 않고, space-y-1 같은 방식으로 사용했는데, 이걸 정의한다면 아마도 마진, 패딩, gap 등 모든 곳에서 정의를 해놔야되지 않을까 라고 생각이 드는데 디자인 토큰을 사용하면 숫자로 사용하는걸 지양하는게 좋은지 (통일성), 아니면 문서화를 통해 숫자로 여백을 지정하는 걸 쓰되, 가이드라인을 따라서 쓰도록 하는지 실무에서는 어떤 방식을 더 많이 사용하는지 궁금합니다!\n\n흠.. 여백을 미리 정의해서 사용하면 좋긴 한데... 저의 경험적인 측면으로 이야기 드리자면 결국엔 숫자를 사용하게 되더라는...\n\n근데 이건 디자이너 분들과의 합의가 필요하다고 생각해요. 디자이너 분들께서 토큰을 잘 사용하신다면, 토큰 기반으로 설계하는게 좋겠죠!?\n\n토큰을 잘 사용하지 못하는 분들도 있어서 그럴 때는 하나하나 다 변환하는게 어렵기 때문에 숫자를 사용하는게 편할 수 있어요.\n\n제일 좋은건 모든 조직이 디자인 시스템 위주의 협업 방식을 채택하는거라고 생각합니다 ㅎㅎ\n그치만 그게... 생각보다 굉장히 어렵달까... ㅠㅠ 그렇네요\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/24"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "안녕하세요 민석님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n> 기존 before폴더구조를 제 나름대로 역할/관심사 기반으로 다시 수정을 했는데 코치님은 어떤식으로 폴더구조를 잡았을지 궁금합니다.\n\n저도 아마 민석님께서 구성하신 것 처럼 구성했을 것 같아요!\n혹은 https://github.com/adobe/react-spectrum/tree/main/packages/%40react-spectrum\n이런 패키지 보시면 하나의 컴포넌트를 아예 패키지로 구성한 다음에 필요한 것들만 import 하여 사용하는 방식으로 되어있는데, 이런식으로 구성할 수도 있답니다 ㅎㅎ\n\n지금은 디자인 시스템이 프로젝트에 내재화 되어있는데, 이걸 완전히 어플리케이션 프로젝트 바깥으로 분리해서 관리한다고 생각해보는거죠.\n\n아마 비슷한 구성이 되지 않을까 싶긴 해요!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/13"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "민지님 굉장히 진보적인(?) 디자인 시스템이네요.\n결국 아무리 복잡해져도 본질로 돌아간다는 메세지였겠죠? 고생하셨습니다 ㅋㅋㅋㅋ\n\n나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n고생하셨고 다음주도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/49"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "수고했어요 성민! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. 과제가 진행되지 않아 채점을 불합격이지만 꼭 다음에 이 과제의 의도를 이해하고 도움이 되기를 바래요!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/47"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "안녕하세요 소리님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) shadcn의 기본 사양에선 button등의 요소에 cursor: pointer가 적용되어 있지 않습니다. (tailwind와 동일한 사양으로.) 그래서 글로벌 css에서 cursor: pointer를 오버라이드 했습니다. 이건 취향 차이일까요?\n\nA)\n흠.. 저도 cursor pointer 적용을 선호하다보니.. 취향으로 봐야할까요 ㅋㅋ 모르겠어요.\n불편하면 적용하는거죠 뭐~\n\n---\n\nQ) RHF에는 controlled 방식과 uncontrolled 방식이 있습니다. 각각 어떤 상황에서 적절할까요? 우선 shadcn 공식 문서에서의 예시는 controlled이기 때문에 그 방식을 따랐습니다.\n\nA)\n렌더링 최적화 하나만 두고 생각 했을 때에는 uncontrolled 가 좋긴 한데, 나머지 외의 상황에서는 controlled 가 대체로 좋다고 생각합니다.\n\n저는 React 같은 라이브러리를 사용하는 이유가 \"데이터를 UI로 표현하기가 적합\"하기 때문이라고 생각해요. 그런데 Uncontrolled는 이를 역행하는 방식인거죠. 정말 꼭 필요한 상황이 아니라면(가령, 렌더링 최적화가 너무 필요하다거나) 굳이? 라는 생각을 하고 있어요.\n\n---\n\nQ) Edit Modal의 경우엔 모달 내부에서 post/user를 조회하고 있습니다. 일관성을 위해 Create와 동일하게 props로 주입하는 게 나을까요?\n\nA)\n말씀해주신것 처럼 일관성있게 관리하면 좋다고 생각해요!\n아니면 아싸리 Context 같은걸 만들어서 관리한다거나!?\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/6"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "우정님 고생하셨습니다\n전반적인 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \ncva나 twMerge같은 유틸 함수도 잘 분리해서 사용해주셨구요. \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\nFSD 관련해서도 적용해주셨는데, 잘 적용을 했는지 검토하기에는 앱 자체의 규모가 매우 작기때문에 불필요한것 같아요. 추후 과제 진행하는데 있어서 다시 이야기 나눠보면 좋을 것 같습니다 ㅎㅎ\n\n폴더 관점에서 이야기를 덧붙여 보면 개인적으로는 이 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\n고생하셨습니다! 담주도 화팅입니당",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/42"
    }
  },
  {
    "passed": true,
    "name": "김준모",
    "feedback": "잘했어요 준모! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. ManagementPage를 페이지를 아주 세세하게 나눠보려고 시도한 점이 눈에 띄었습니다.useEntityManagement 훅으로 분리하고 UI와 비즈니스 로직을 나눠보고자 했군요. 상태관리도 없고 데이터 별로 구분이 안되어 있는 코드인데 리팩토링의 세세함이 깊어서 수고를 많이했겠다 느껴집니다. \n\n그렇지만 지금처럼 리팩토링을 한다고 해서 더 나아진다는 느낌은 안 받았을 거라고 생각합니다. 지금처럼 UI에서 데이터를 가지게 되면 Props는 더 복잡해지고 나눌수록 더 힘들어졌을거에요. 이번 기회로 UI와 데이터의 의존 관계나 더 나운 구성을 느꼈기를 바래요.\n\nKRDS 디자인 토큰을 도입하면서 Primitive와 Semantic을 구분한 접근도 좋았습니다. 타입을 중앙에서 관리하고, CVA로 조건문을 선언적으로 정리한 부분도 마찬가지고요. 특히 접근성까지 신경 쓴 건 실무에서 놓치기 쉬운 부분인데 잘 챙겼네요.\n\n다크 모드 구현에서 Before 디자인을 유지하면서 개선해야 하는 딜레마를 경험한 것도 의미 있습니다. 사실 디자인 시스템을 개편할 때에는 리뉴얼을 하고 싶은건데 실무에서는 리소스 부족으로 기존 디자인을 억지로 유지해야 하는 경우도 생기죠. 고생스러운 작업이었을텐데 아주 잘했습니다!\n\nQ) 역할 기반 구조가 지금 상황에 적합한지, shadcn/ui와 레거시 컴포넌트를 함께 사용하는 구조에 대한 조언을 받고 싶습니다.\n\n좋은 질문이에요. 지금 주무님이 선택한 역할 기반 구조(components/ui/, components/domain/management/)는 적합합니다. 폴더 구조의 핵심은 \"외울게 적고 예측하기 쉬운가\"거든요. ui/는 순수 UI 컴포넌트, domain/management/는 도메인 컴포넌트라는 게 명확하니 누가 봐도 예측 가능하죠.\n\nshadcn/ui와 레거시를 섞어 쓰는 건 과도기 전략으로 맞습니다. 실무에서는 \"전체를 한 번에 갈아엎기\"보다 \"점진적 마이그레이션\"이 훨씬 현실적이거든요. 다만 몇 가지 원칙을 지키면 좋아요.\n\n우선 경계를 명확히해야 합니다. 미리 분리를 해두는거죠. 새로운 기능은 shadcn/ui로, 기존 레거시는 필요할 때만 마이그레이션하는 식으로 규칙을 정하는 거죠. components/ui/legacy/ 같은 폴더로 레거시를 모아두면 \"이건 언젠가 마이그레이션할 대상\"이라는 게 보이잖아요.\n\n그렇지만 일관성을 유지하세요. 특히나 최신 버전의 컨벤션이나 구성으로 인터페이스등은 맞춰 두는 것입니다. 그러면 나중에 변경하기가 편해요. 아니면 래퍼나 어댑터 컴포넌트들을 만들어서 최대한 변경되는 코드를 최소화 하면서 점진적으로 교체를 진행하는 거죠.\n\n역할 기반 구조는 프로젝트가 더 커지면 domain/ 아래에 user/, post/ 같은 도메인별 폴더가 생길 수 있어요. 혹은 나중에 반대로 도메인을 기준으로 하고 /entities/user/ui 처럼 단계를 만들 수 있겠지요. 무엇이든 간에 그게 더 \"외울게 적고 예측하기 쉬운가?\"를 계속 점검하면서 구조를 조정하면 됩니다. 좋지 않은 폴더구조는 인지적 피로도를 가져오는데 그걸 느낄 수 있으면 좋아요! 지금처럼 판단 기준을 명확히 갖고 가면 어떤 구조든 잘 관리할 수 있을 거예요. 수고했습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/27"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "잘했어요 채영! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙등을 몸으로 느껴보는 것이 목표였습니다. 이번 과제에서 가장 인상적이었던 건 접근성에 대한 깊은 이해였어요. ESC키 미지원, ARIA 속성 부재, 닫기 버튼 마크업 순서 오류까지 KRDS 문서를 참고하면서 구체적으로 파악하고 블로그에 정리한 거죠. 퍼블리셔 출신이라 TailwindCSS를 선호하지 않았다가, \"유틸리티 클래스 기반이라 토큰 적용을 즉각적으로 할 수 있다\"는 걸 깨달은 과정도 좋았습니다.\n\nManagementPage를 hook으로 분리한 것도 좋았지만, 코드를 보면 여전히 entityType에 따라 분기 처리가 많이 남아있을 거예요. UI 컴포넌트가 \"이게 User야? Post야?\"를 계속 물어보면서 다르게 동작하는 구조죠. 실제로 작업하면서 \"이 분기가 여기도 있고 저기도 있네?\"하면서 복잡함을 느꼈을 거예요. 다음 과제에서는 엔티티별로 컴포넌트를 분리하는 관점의 차이를 느껴보기를 바랍니다.\n\nQ1) 다크모드에서 특정 토큰만 적용 안되는 이유?\n\nTailwindCSS v4에서 토큰 이름이 기존 Tailwind 네이밍과 충돌하거나, @theme inline 안팎에서 변수를 혼용하면 우선순위 문제가 생길 수 있어요. @theme inline 블록 안에 색상을 정의하면 Tailwind가 자동으로 유틸리티 클래스를 생성해줍니다. 다크모드가 특정 토큰만 적용 안 됐다면, 그 토큰이 `.dark` 클래스 안에서 재정의되지 않았거나 CSS 특이도 문제일 가능성이 높습니다.\n\nQ2) shadCN 탭에서 role=\"tab\"으로 테스트 수정하는 게 의도된 건가요?\n\n네, 맞습니다! 접근성 관점에서 탭은 `role=\"tab\"`이 맞거든요. 기존 테스트가 `role=\"button\"`으로 찾은 건 before 패키지가 접근성을 제대로 구현하지 않았기 때문이에요. 채영이 shadCN으로 바꾸면서 접근성이 개선된 거고, 테스트도 그에 맞춰 수정하는 게 올바른 방향입니다. 수고했습니다!\n\nBP 선정이유 : 접근성과 토큰이라고 하는 주제를 깊이있게 들어가서 문제를 해본 경험들이 다른 참가들에게도 모범이 되는 사례라고 생각했습니다.\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/14"
    }
  },
  {
    "passed": false,
    "name": "김현우",
    "feedback": "안녕하세요 현우님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n다만 스토리북 작성이 안 되어있네요 ㅠㅠ 심화과제를 불합격으로 남겨놓도록 하겠습니다.\n\nQ) 사실 리팩토링되는 코드도 처음엔 다른 개발자가 심혈(?)을 기울여 작성했던 코드였을 것 같은데, 그러한 코드들도 리팩토링 되는 걸 보면 좀 안타깝다는 생각도 듭니다. 리팩토링 되지 않을 코드를 작성하려면 갖아야할 관점 같은 것이 있을지 궁금합니다. 그리고 코치님 개인적으로나 팀에서 리팩토링을 결정하기까지의 근거들도 궁금합니다.\n\nA)\n결국 코드는 제품을 위해서 존재하는 것이고, 제품 개발에 방해된다면 당연히 없애거나 개선해야 한다고 생각해요 ㅎㅎ 어쩔 수 없는거죠.\n\n리팩토링 되지 않을 코드를 작성하려면, 다양한 요구사항에 대해 생각해보면 좋겠죠!?\n우리가 리팩토링을 하는 이유는 \"요구사항의 변경에 대응하기 용이한 코드\"를 만들어가기 위함이라고 생각해요.\n그러니까 다양한 요구사항에 대한 \"시뮬레이션\"을 돌려보면서 (꼭 직접 작성하지 않더라도..?) 어떤 상황에 대응할 수 있는 코드인지, 코드의 수정 동선은 괜찮은지 등 다양한 관점으로 바라보는거죠.\n\n의사결정의 근거는 대체로 회고를 통해서 산출이 되어요.\n\"요즘 개발할 때 불편한점 혹은 문제되는 점\"을 다같이 이야기 해보고, 이 때 나오는 주제를 선정해서 리팩토링을 진행하는거죠.\n\n---\n\nQ) 컴포넌트를 구현할 때 설계를 먼저하고 구현을 하듯, 리팩토링 과정에서도 설계하는 작업이 필수적이라고 생각합니다. 이때 어떠한 것들을 고민하시고 계획하시나요? 그리고 실질적으로 리팩토링할 때 꿀팁 같은게 있을까요? 가령 선 테스트 코드 작성 후 리팩토링 같은 게 있을 것 같은데, 이외에 다른 것이 있을까요?\n\nA)\n위에서 이야기한 것과 동일한데요, \"어떤 요구사항에 대응할 수 있는가\"를 볼 수 있어요.\n가령, 지금처럼 디자인 시스템을 만든다고 가정했을 때 일단 만들어서 배포해보고 다양한 프로젝트에 설치하여 잘 적응 되는지 등을 토대로 판단해보는거죠.\n\n그런데 사실 그렇게 하기가 쉽지 않아요. 시간제약이 무엇보다 크달까..\n\n여튼 저는 리팩토링을 할 때에는 가끔 \"극단적\"인 생각이 필요하다고 생각해요.\n디자인 시스템을 만든다면, 지금은 리액트로 되어있지만 vue 기반의 프로젝트에서 불러올때는 어떻게 해야 좋은지 고민해보는거죠 ㅎㅎ\n\n코드 자체에 대해 생각하기보단, 코드의 쓰임에 대해 생각해보는 습관을 가지시면 좋답니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/5"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "수고했어요 은주! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. 과제가 진행되지 않아 채점을 불합격이지만 꼭 다음에 이 과제의 의도를 이해하고 도움이 되기를 바래요!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/10"
    }
  },
  {
    "passed": true,
    "name": "노유리",
    "feedback": "안녕하세요 유리님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) Radix UI Select 테스트 문제: ManagementPage.test.tsx:39에서 Radix UI Select는 HTML의 네이티브 <select>가 아니기 때문에 getByRole('combobox') 등으로 접근이 어렵습니다. Radix UI Select를 올바르게 테스트하는 방법이 있을까요? 실무에서는 이런 경우 어떻게 처리하나요?\n\nA)\n저는 실무에서 UI 테스트를 거의 하지 않는 편이랍니다. 대체로 비즈니스 로직을 hook으로 분리해서 hook에 대한 테스트를 진행해요.\n\nUI는 data를 표현하는 수단이고, data의 input/output에 검증이 잘 되면 ui에도 자연스럽게 잘 반영이 되지 않을까!? 라는 판단입니다 ㅎㅎ\n\n물론 정확하지 않을때도 분명 있지많요!\n\n---\n\nQ) 과제 목표는 \"Atomic Design의 폴더 구조가 실무에서는 불편하다\"를 체감하는 것인데, 레거시 컴포넌트들(atoms/, molecules/, organisms/)을 모두 삭제하고 ui/만 남겨야 할까요? 아니면 비교를 위해 남겨두는 것이 더 좋을까요? 실무에서는 마이그레이션 시 레거시 코드를 즉시 삭제하나요?\n\n저의 경우, 원본 코드는 마지막까지 보존하고 리팩토링이 완료되어 교체가 잘 되었음을 인지하는 순간 제거하는 편입니다.\n원본 코드에 핵심 로직이 있을 때 이를 비교해가면서 보기도 쉽고, 요즘엔 또 AI가 있다보니 원본 코드와 리팩토링 코드를 비교하면서 문제될 부분을 찾아달라고 하면 좋달까..!?\n\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/41"
    }
  },
  {
    "passed": true,
    "name": "도희정",
    "feedback": "안녕하세요 희정님~ 6주차 과제 잘 진행해주셨네요 ㅎㅎ\n다만 PR에 남겨주신 내용이 없는게 아쉽네요 ㅠㅠ\n추후에 시간 되시면 꼭 회고해보시면 좋겠어요!\n고생하셨습니다~!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/43"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "정말 잘했어요 수범! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. 수범님 회고에서 가장 인상적이었던 건 디자인 시스템을 \"재료 창고와 요리사\"로 비유한 설명이었어요. components.css를 재료 창고로, CVA를 레시피로 설명하면서 \"재료는 무엇(What)인지 알지만 어디에 어떻게(How) 쓰일지는 모른다\"는 표현이 정말 탁월했습니다. 이 비유는 다른 사람에게 토큰화를 설명할 때도 쓸 수 있을 정도로 명확해요.\n\n\"예쁘게 만들기가 아니라 레거시를 마이그레이션한다면 어떻게 할 것인가\"에 집중한 것도 pragmatic한 선택이었어요. 실무에서는 디자인까지 바꾸면 안 되는 경우가 대부분이니까요. 다크모드에서 단순 반전이 아니라 접근성을 고려한 대비 전략을 세우고, Input에 밝은 배경을 유지한 결정도 훌륭했습니다. \"다크모드는 접근성 문제의 연장선\"이라는 깨달음이 핵심이죠.\n\n다만 코드를 보면 UI와 도메인을 분리했다고 했지만, 여전히 entityType 같은 분기가 많이 남아있을 거예요. 실제로 작업하면서 \"이 분기 처리를 어디에 둬야 하지?\"하는 복잡함을 느꼈을 텐데, 다음 과제에서는 엔티티별로 컴포넌트를 완전히 분리하는 방식을 경험해보기를 바랍니다. 수고했습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/40"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "아니 용태님 ㅋㅋㅋㅋㅋㅋㅋ\n너무 재밌네요.... 최근에 본 어떤 글보다 압도적인 재미였어요 허허\n\n이와는 별개로 패키지도 모노레포로 분리해주시고, 스토리북도 잘 배포해주셨네요 ㅎㅎ 고생하셨습니다!!\n다음 과제도 기대해볼게요 ㅋㅋ\n\n특별히 리뷰 받고 싶은 부분은 없는 것 같아서 피드백은 바로 마무리하게요!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/37"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "안녕하세요 지영님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) UI 컴포넌트가 어느 정도까지 비즈니스 로직을 가지는 것이 적절한지 궁금합니다.\n\nA)\n흠.. 말씀해주신 케이스 모두 저는 UserForm에 만들어서 관리할 것 같아요 ㅎㅎ\n다만 UserForm의 비즈니스 로직은 훅으로 분리해서 따로 관리하는거죠. 아마 현재 방식와 크게 다르지 않으리라 생각합니다.\n\nUserForm이 Form의 다양한 요소를 합성하여 사용하는 레이어라고 보시면 될 것 같아요!\n\n여튼 UserForm을 정교하게 분리하여 관리하려고 하면 오히려 관리 비용이 기하급수적으로 늘어지 않을까..!? 라는 생각이 들어요..!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/23"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "안녕하세요 창수님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n다만 과제 회고는 작성해주질 않으셨네요 ㅠㅠ 아쉽습니다.\n추후에 궁금한점 생기면 언제든 편하게 디스코드로 문의주세요~!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/26"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "잘했어요 형우! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 최신 프론트엔드 생태계의 방향성을 체득하는 것이 목표였습니다. 회고에서 \"개성 넘치는 CSS → 부트스트랩 → 디자인 토큰 → Radix-UI → shadcn/ui → Storybook\"으로 이어지는 발제의 역사적 맥락을 자기 언어로 기술한 부분이 인상적이었습니다. \n\n\"퍼블 출신이라 아직까지 스타일 라이브러리가 유용한지 모르겠음 => 내가 css 치는게 더 빠를 듯\" 이라는 대목도 공감이 갔습니다. 저도 퍼블리싱을 했다보니 지금의 CSS 라이브러리들의 발전사가 참 맘에 들지도 않고 불편하다고 생각해요. 디자인 토큰방식은 편리가 아니라 일단 만들고 난 이후에 최종적인 정리의 마지막인 부분이라고 생각하는게 좋습니다. 그렇게 퍼블리싱을 하려고 하면 답답한 게 맞죠.\n\n이건 이후에 프로젝트가 커지고 나면 디자인은 크게 달라지는게 없고 점점 디자인의 변화나 빠르게 결과를 만들기 보다 관리를 더 잘 할 수 있는 방향이 더 중요해지니 처음에는 퍼블리싱을 위주로 하다가 만들기 위함에서 나중에는 관리를 더 잘 할 수 있도록 진화했다는 관점에서 알아주시면 좋겠습니다.\n\n너무 너무 수고 많았습니다. 다음 과제도 화이팅입니다\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://hyeongwoo94.github.io/front_7th_chapter3-1"
    }
  },
  {
    "passed": false,
    "name": "박희정",
    "feedback": "희정님 고생하셨습니다~\n분리되어가는 코드는 확인했는데, 아직 완료가 된 코드라고 보기에는 어렵네요ㅠㅠ 배포도 따로 안되어있고, 스토리북 구성도 되어있지 않아서 합격을 드리지는 못할 것 같습니다.\n\n꽤나 디자인시스템은 다양한곳에서 적용을 시도했고, 이득을 많이 본 구조이기도 하죠. AI시대에서 중요성이 꽤 많이 대두될거라고 저는 개인적으로는 생각하고 있습니다. 나중에 여유있을 때 꼭 시도해보고 의견 나눠보시면 좋을것 같아요. 고생하셨습니다~",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/46"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "잘했어요 승현! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. Before 패키지 분석이 아주 꼼꼼했어요. 특히 \"Button이 entityType과 action을 알고 있어서 재사용이 불가능하다\"는 문제를 정확히 짚었고, 그걸 순수 UI 컴포넌트로 분리하면서 비즈니스 로직을 상위로 올린 과정이 잘 드러났습니다.\n\n데일리 회고에서 \"형태적 Atomic을 제공하는 스타일시트와 기능적 Atomic을 제공하는 Headless 컴포넌트를 분리해서 바라봐야 한다\"고 정리한 부분도 인상적이었어요. Atomic Design이 왜 애매한지를 단순히 \"어렵다\"가 아니라 관점의 분리로 이해한 거죠. 이런 식으로 기술의 배경을 자기 언어로 소화하는 게 진짜 학습입니다.\n\n**Q3) Primitive vs Semantic 분리가 적절한가?**\n\n지금의 과제 수준으로는 사실 2-tier 구조(primitive → semantic)로도 충분합니다. 절대적인 기준이 아니라 지금 상황에서 제일 나은 것이 무엇인가? 라는 기준에서 적절함을 판단하는 것이기에 적절합니다.\n\n**Q4) TailwindCSS vs CSS Variables 사용 기준**\n\n지금 혼합해서 쓰는 건 과제 단계에서 자연스러운 거예요. 처음 디자인 시스템을 구축할 때는 아직 어떤 토큰이 반복적으로 쓰일지 파악이 안 되니까 CSS Variables로 먼저 정의하고 필요할 때 직접 쓰게 되거든요.\n\n다만 최종적으로는 자주 쓰이는 토큰들을 Tailwind 클래스로 매핑해서 체계를 잡는 게 더 좋습니다. `bg-[var(--color-alert-info-bg)]`처럼 직접 변수를 쓰는 건 \"이 변수 이름이 뭐였지?\" 하고 찾아봐야 하잖아요. 반면 `bg-alert-info`처럼 Tailwind 클래스로 등록해두면 자동완성도 되고 팀원 누구나 예측 가능해지죠. 결국 \"외울게 적고 예측하기 쉬운\" 방향은 체계화된 Tailwind 클래스 쪽입니다.\n\n수고했습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/34"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "고생하셨습니다 수빈님!\n\n나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n> 디자인 토큰 네이밍 컨벤션\n\n음..!  이미 테오가 발제에서 말을 했을 것 같은데, 일반적으로 3 티어 레벨로 관리하는 것이 지배적인 것 같아요. 계층에 맞게 그리고 그 값이 범용적으로 어떻게 쓰이고, 묶여서 관리되는 것들은 대부분 디자인 측에서 정의가 되서 진행이 되더라구요. 결국 디자인 시스템을 유지한다는 것 자체가, 전체적인 일관성을 유지한다는거고 primary 를 예시로 들어주셨는데, 개별로 되어 있을 때 좀 더 확장성을 갖고, 묶어서 관리할 경우 꼭 묶어서 다녀야 한다는 강한 규칙이 생기는 것이기 때문에 신중해야 할 것 같아요 ㅎㅎ \n\n> ** Before UI 유지 vs 디자인 개선**\n\n개선 관점에서는 디자인 시스템을 도입한다면, 리팩터링 관점에서 기존 UI를 그대로 유지되도록 마이그레이션 하고 단계별로 가는게 안정적인것 같아요. 결국 너무 큰 범위의 개선을 한번에 하다보면 어느 부분에서 수정이 이뤄졌는지부터 나중에는 원래동작이 뭐였지..? 단계까지 가게 되더라구요.\n핵심은 작은 단위로 나눠서 이터레이션을 반복적이게 가져가는 것이니까 거기에 집중해보면 어떨까..! 싶습니다. \n\n> ** 폴더 구조 관련**\n\n음..! 디자인 시스템 관련 폴더 구조는 유지보수 관점에서 지켜보는게 좋을것 같은데요. 같은 파일 내에 분리를 하는것도 방법일 수 있고, 제가 멘토링 시간에 공유드린 글들을 참고하다보면 버저닝 정책때문에 모든 컴포넌트들을 별도로 패키징화 시켜 배포하는 분들도 있구요. 결국 같은 관심사를 가진 컴포넌트를 비슷한곳에 위치시키고 관리하는게 핵심인것 같아요. 테오의 의도가 그게 맞는지는 모르겠지만.. 제가 생각했을때는 아토믹디자인이 잘못 구현이 되어있다면 아토믹 디자인을 제대로 배치하는게 유의미하지 않았을까 싶어요!\n\n폴더 관점에서 이야기를 덧붙여 보면 개인적으로는 이 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\n고생하셨고 담주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/18"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "안녕하세요 소은님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) 뷰와 로직 분리의 적정선\n\n과거에 뷰와 로직 분리를 위해 VaC 패턴과 같이 뷰와 로직을 엄격하게 분리하는 디자인 패턴을 도입하여 사용해 본 경험이 있는데, 장단점이 있었던 것 같습니다. 특히 단점으로 느꼈던 것 중에는 오히려 뷰와 로직이 너무 극단적으로 분리되어 있다보니 어떤 로직이 화면의 어떤 요소와 연결되는 지 한 눈에 파악하기에는 어려웠고 파일 네비게이션을 더 자주 하게 되었던 것 같습니다. 반면 너무 분리가 되어 있지 않으면 코드가 과도하게 길어지고 가독성이 떨어지는 문제가 발생하는 것 같은데, 어떤 기준을 가지고 코드를 분리하는 게 적절할 지 아직 고민이 되는 것 같습니다. 코치님께서는 활용하시는 기준이 있으신 지, 참고할만한 내용이 있다면 공유해주실 수 있으실까요?\n\nA)\n저희 팀도 VAC를 적극적으로 사용하고 있어요.\n\nUI에 특화된 로직이 아닌 도메인 로직의 경우 hook으로 분리해서 관리하는게 거의 대부분의 상황에 좋다고 생각해요 ㅎㅎ 무엇보다 테스트를 작성하기가 무척 용이하답니다!\n\n결국 UI는 \"데이터\"를 표현하는 수단이라고 생각해서, hook을 통해 데이터를 제어하고, 데이터의 input/output에 대한 테스트를 작성해서 관리하는거죠.\n\n중요한건 \"일관성\"이라고 생각해요. 개똥같은 기준이여도 일관성있게 작성이 되면 다른 사람과 함께 코드를 작성할 때 오해를 줄여나갈 수 있는거죠.\n\n---\n\nQ) after/index.css를 더 적절하게 빌드하는 방법\n\n현재 vite 빌드를 통해 after/index.css를 '그대로' dist 파일에 전달하는 방법을 찾지 못 했습니다. tailwindCSS를 사용할 때에는 이 css 파일을 그대로 사용해야 tailwindCSS 빌드가 잘 동작하는 것 같은데, vite 빌드로는 그 방법을 찾지 못 해 vite 빌드와 별개로 'cp' 명령어를 사용해 직접 소스 디렉토리에서 복사하는 방식을 취하고 있습니다. 이러한 방법이 좋은 방법은 아닌 것 같은데 더 좋은 해결책이 있을까요?\n\nA)\n흠 당연히 포함되는게 맞다고 생각했는데, 코드를 들춰보니 index.ts에 css 파일이 포함되어 있지 않네요 ㅎㅎ\ncss를 포함시켜서 빌드해야 한답니다!\n```tsx\nexport * from \"./index.css\"\nexport * from \"./components/ui/alert\";\nexport * from \"./components/ui/badge\";\nexport * from \"./components/ui/button\";\nexport * from \"./components/ui/card\";\nexport * from \"./components/ui/checkbox\";\nexport * from \"./components/ui/dialog\";\nexport * from \"./components/ui/form\";\nexport * from \"./components/ui/header\";\nexport * from \"./components/ui/helper-text\";\nexport * from \"./components/ui/input\";\nexport * from \"./components/ui/label\";\nexport * from \"./components/ui/Logo\";\nexport * from \"./components/ui/select\";\nexport * from \"./components/ui/table\";\nexport * from \"./components/ui/textarea\";\n```\n\n요로코롬...!?\n\n혹은 css만 별도로 빌드를 해서 사용해야 할꺼에요.\n\n다만 taliwindcss 자체에 대해 생각해보면, 사용하는 측에서도 tailwindcss에 대한 설정이 필요해서, 그냥 package.json에 이렇게 정의해서 관리하는 방법도 있겠네요.\n\n{\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.es.js\",\n      \"require\": \"./dist/index.cjs.js\"\n    },\n    \"./index.css\": \"./src/index.css\"\n  }\n}\n\n지금은 dist으로 되어있는데, src를 참조하게 하는거죠 ㅎㅎ\n\n근데 경험적인 측면으로 생각해봤을 때, tailwindcss의 css 파일 자체를 export 하여 사용하는 방식이... 꽤 곤란한 경우가 많아요 ㅠ\n\n아무래도 라이브러리보단 어플리케이션에 적합하다보니..\n\n그래서 라이브러리 형태로 사용하고 싶다면 emotion 을 통해 직접 정의하는게 훨씬 확장성이 좋답니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/16"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "안녕하세요 재현님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) 디자인 토큰의 레이어 나누기\n발제 자료에서는 디자인 토큰을 Primitive / Semantic / Component 레벨로 나누어 관리하는 방식이 소개되고 있는데, 저는 디자인 토큰을 레이어화 해서 관리해야 할까? 라는 의문이 들었습니다. 색상, 사이즈와 같은 단위의 Primitive 디자인 토큰만으로도 저는 충분히 프로젝트를 관리할 수 있을 것 같다는 생각이 드는데, 코치님의 의견이 궁금합니다 ! 또한 코치님은 디자인 토큰을 어떻게 관리하시는지도 궁금해요 !\n\nA)\n저희 팀에서도 3단계의 레이어를 구분해서 사용하곤 한답니다!\n\n범용적으로 활용할 수 있는 기본적인 디자인 토큰을 먼저 정의한 다음에,\n프로젝트 단위의 메인컬러/서브컬러 혹은 무언가 의미가 있는 토큰을 분리해서 관리하는거죠\n마지막으로 컴포넌트 레이어에서 활용할 수 있는 토큰을 정의해놓는 편이에요.\n\n만약 \"회사의 브랜딩 컬러\"가 변경되었을 때 2차 레이어에 있는 토큰만 변경하면 일괄 수정 될 수 있어요 ㅎㅎ\n\n컴포넌트로 단위로 분리하는 이유는, 각 컴포넌트마다 독립적인 색상을 사용할 수 있기 때문이라고 생각해요. 그치만 말씀해주신 것 처럼 컴포넌트 레이어의 토큰을 무조건 분리할 필요는 없다고 생각합니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/20"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "진성님 고생하셨습니다~\n디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n폴더 관점에서 이야기를 덧붙여 보면 개인적으로는 이 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\n> 코치님도 비슷하게, 초기에 작성한 테스트 코드가 대규모 구조 변경 과정에서 거의 전부 다시 써야 하는 상황을 겪으신 적이 있으실까요?\n그리고 이런 상황에서는 어디까지를 ‘반드시 지켜야 할 영역(Contract)’으로 보고 테스트를 가져가야 할지, 혹은 테스트 전략을 어떻게 가져가는 것이 Best Practice에 가까운지 코치님의 경험과 기준이 궁금합니다.\n\n결국 지금과 같은 상황이라면 기존에 있는 테스트가 전체적으로 수정이 되어야 하는 상황이 맞습니다. 아무리 외부 변화에 영향이 없게 테스트를 짜도 영향이 있을 수 밖에 없는 규모의 작업인 것 같아요. 대신 저희가 함께 학습했던 시각적 회귀 테스트 같은 것들을 만약 컴포넌트들을 대상으로 운영했다면 깨지지 않고 다양한 시나리오가 추가되는 형태였으니 이상적이지 않았을까 싶습니다 \n\n이런 경우가 실제 회사에서도 많지 않으니 너무 걱정하지 않아도 될 것 같고\n다만, 지금은 어떻게 보면 전체적인 기능은 유지하되, 컴포넌트 분리 및 개선이니 모듈 구조에 영향을 받는 테스트가 아니라면 모두 정상적이게 동작하고 통과해야 하는 경우이라고 생각해보면 좋을것 같습니다.\n\n고생하셨습니다! ",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/21"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "**[5팀 오새듬] Chapter3-1. UI 컴포넌트 모듈화와 디자인 시스템 #33**\n\n잘했어요 새듬! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. Before 패키지 분석이 꼼꼼했어요. Atomic Design 구조를 쓰고 있지만 역할이 명확하지 않다는 점, 관심사 분리 부족, 단일 책임 원칙 위반, 스타일링 방식 불일치까지 문제점을 체계적으로 정리했네요.\n\n\"디자인 토큰화만 잘 되어 있다면 shadcn의 variant만 잘 분리하면 초기 작성에만 시간이 걸리고 이후에는 유지보수도 쉽고 재사용성이 높다\"는 깨달음도 좋았습니다. 이게 디자인 시스템의 핵심이에요. 처음에 체계를 잡는 데 투자하면 나중에 그 이상으로 돌려받는 거죠.\n\n다만 아쉬운 부분이 있어요. 토큰을 3단계(primitive → semantic → component) 대신 primitive만으로 충분하다고 판단했는데, 이번 과제에서는 오히려 2단계까지 가보는 게 학습에 도움이 됐을 거예요. `--blue-600`만 있으면 \"이 파란색이 버튼용인지, 링크용인지, 브랜드 컬러인지\" 코드만 봐서는 알기 어렵거든요. `--color-brand-primary: var(--blue-600)`처럼 semantic 레이어를 하나 두면 의도가 명확해지죠. 실무에서 \"이 색상 바꿔주세요\" 할 때 primitive만 있으면 모든 사용처를 찾아다녀야 하지만, semantic이 있으면 한 곳만 바꾸면 되니까요.\n\n그리고 컴포넌트 분리와 리팩토링을 시간 부족으로 못 했다고 했는데, 이 부분이 사실 이번 과제의 핵심이었어요. UI 컴포넌트가 도메인 로직을 품고 있을 때 어떤 문제가 생기는지, 분리하면 어떻게 달라지는지를 직접 경험해보는 게 목표였거든요. 다음 과제에서는 엔티티별로 컴포넌트를 분리하는 관점을 꼭 경험해보길 바랍니다.\n\n수고했습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/33"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "수고했어요 태준! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. 과제가 진행되지 않아 채점을 불합격이지만 꼭 다음에 이 과제의 의도를 이해하고 도움이 되기를 바래요!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/45"
    }
  },
  {
    "passed": false,
    "name": "윤지훈",
    "feedback": "고생하셨습니다! 지훈님\n아쉽게 바쁘셔서 과제를 제대로 마무리 해주시지는 못했던 것 같네요.ㅠㅠ\n그럼에도 지금까지 진행해주셨던 내용 남겨주셔서 다행입니다.\n말씀해주신것처럼 다음에 꼭 마무리 해보고 궁금한 점 DM 보내주세요 ㅎㅎ\n\n다음주는 파이팅입니다!!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/50"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "안녕하세요 예인님! 6주차 과제를 다 수행하기에는 시간이 많이 부족했나보군요 ㅠㅠ\n이번주 과제는 잘 수행할 수 있기를 바랍니다!! 고생하셨어요~!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/3"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "잘했어요 윤지! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. ManagementPage를 여러 로직과 컴포넌트로 분리를 잘 해주었네요. 수고많았습니다.\n\n과제에서 진행하면서 윤지도 느꼈을 수도 있도 (아닐 수도 있겠지만) EntityFormModal이나 EntityTable등 UI가 비즈니스 로직에 대한 분기를 가지면 나중에 분리를 해도 계속해서 `entityType`에 따라 분기 처리를 해야 한다는 것을 알 수 있습니다. 그러다보면 분리를 했지만 복잡성이 더 커지는 부작용을 맞이하죠.\n\n더군더나 `<EntityFormModal entityType={entityType}>`처럼 UI 컴포넌트가 도메인을 알고 있으면, 나중에 Product, Order, Comment 같은 엔티티가 추가된다면 그 모든 컴포넌트들 전부에 분기를 추가해야 하고 Props도 점점 복잡해지게 됩니다. 이번 기회로 UI가 다양한 엔티티를 직접 다루기 시작하면 확장이 어려워진다는 걸 느꼈기를 바래요.\n\n일반적인 방향은  `<UserFormModal>`, `<PostFormModal>`처럼 도메인별로 컴포넌트를 분리하고, 공통 UI는 `<FormModal>`, `<Table>` 같은 범용 컴포넌트로 추출하는 거예요. 그러면 새 엔티티 추가할 때 기존 코드를 안 건드리고 새 컴포넌트만 만들면 되니까요. 지금 하고 있는 다음 과제에서 엔티티를 중심으로 분리하는 관점의 차이를 느껴보기를 바랍니다.\n\n**Q) Button variant 설계 - 시맨틱 variant vs 형태 기반 variant + 색상 prop?**\n\n좋은 질문입니다. 그리고 이런 류는 보통 정해진 정답은 없고 원칙만 있죠. \"외울게 적고 예측하기 쉬운가?\" 그래서 팀에서 정하기 나름입니다. 자주 쓰이고 모두가 암묵적으로 알고 있는 사실상의 표준(?)들은 variant로 작성합니다. 뜬금없이 예외같은 거라면 className을 쓰면 되죠. 그 뜬금없음이 너무 반복이 되어 다수가 된다면 variant로 승급이 되겠죠.\n\n중요한 건 \"팀이 합의한 규칙\"이 있어야 한다는 겁니다. variant가 늘어나는 기준, className 덮어쓰기 허용 범위 같은 거요. 그게 없으면 각자 마음대로 하다가 디자인 시스템이 무너지거든요. 변수에 대한 대응을 하면서도 또 디자인팀과 긴밀하게 대화하면서 표준화 시도도 계속 해봐야겠죠. 그래서 실무가 참 복잡한 거 같아요. \n\n수고했습니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/2"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "고생하셨습니다 정민님 \n\n나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n스토리북 환경도 각각 분리를 잘 해주셨는데, 디자인 시스템의 경우 스토리북 자체를 활용해서 테스트를 하는 경우도 많고 개발자만 보는 화면이 되지 않을 가능성도 높아서 가능한한 대부분의 시나리오들을 널어서 활용하는 형태로 갔으면 좋지 않았을까 싶네요!\n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n> 프로젝트 규모나 성격에 따라 3계층 레이어드나 FSD처럼 명확한 구조를 반드시 적용해야 하는 기준이 있는지, 혹은 제가 작업한 구조로 진행해도 괜찮은지 알고 싶습니다.\n\n저는 개인적으로 나쁘지 않다고 생각하는 편인데요. 과제의 의도와 제 생각이 정확하게 일치하는지는 모르겠지만, 아토믹 디자인 관점에서 ui 배치가 제대로 되지 않았다면 배치를 제대로 하는 형태로 운영해보는게 좋지 않았을까..! 싶습니다. 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\nFSD를 적용하는 것은 공부 관점에서는 충분히 시도해볼법 하지만,  지금의 구조에서는 과하지 않을까..! 라는 생각입니다.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/8"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "고생하셨습니다. 현지님! 나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n고생하셨고 담주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/44"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "안녕하세요 이진님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) ui/Table은 순수 UI를 담당하고 organisms/DataTable은 기능(검색/정렬/페이징) 책임으로 분리했는데 적절한 분리였는지 궁금합니다.\n\nA)\n레이어를 구분해주셨군요 ㅎㅎ 좋습니다.\n적절하게 잘 분리했다고 생각해요!\n\nDataTable 내의 비즈니스 로직도 훅으로 분리하면 어땠을까!? 라는 생각도 듭니다 ㅋㅋ\n\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/39"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "고생하셨습니다 희재님!\n회고가 아주 꼼꼼하게 잘 작성되어 있네요.\n\n나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n> CVA의 복잡도 관리\n\n보통 이런 경우에는 base variants와 compound variants를 활용해서 구성하고, Compound 패턴을 활용하거나 Slot 패턴같은 것들을 활용하는 것도 방법인것 같아요. 말씀해주신것 같은 상황에서는 사실 엄청 variant가 나눠진다고 보기 어려울 수 있는데, 너무 복잡해지는 케이스에서는 저렇게 처리할 것 같습니다.\n\n> Tailwind 클래스 가독성\n\n보통은 clsx나 tw merge 같은것들로 처리를 하는 편이고, 길어지는 부분들에 대해서는 Headwind로 일관되게 만들려고 하는 편인것 같아요. 묶어서 함께 관리할 수 있는 것들은 묶어서 관리할 수 있지만, 오히려 묶음으로써 관리하는데 더 어려움이 느껴지는 편인것 같습니다.\n\n\n> 디렉토리 구성 방식\n\n저도 동일하게 사용하는 편이에요! 같은 이야기를 하는 부분에 함께 위치하려고 노력하는 편이에요! 여러 곳에서 사용하지 않는 경우에는 굳이 분리를 하지 않고 한 파일내에서 유지하다가 필요해지는 시점에 분리를 합니다. 응집도 관점에서 비슷한 이야기를 하는 모듈들을 모아야 유지보수 관점에서 좋기 때문에 모든 개발 관점에서 비슷하게 운영하는 편입니다 ㅎㅎ\n\n> 접근성 처리\n\neslint-plugin-jsx-a11y같은 eslint 툴을 이용해보거나 스토리북 a11y 애드온을 활용해보는 것도 훨씬 도움이 많이 될것같아요 ㅎㅎ lighthouse를 활용해보는 것도요! 이런것들을 활용하면 개발 단계에서 놓치지 않고 필수적인 것들을 잘 챙길수 있을것 같아요.\n\n이런것들을 작은 컴포넌트, 아톰, molecule, 프리미티브 단에서 잘 정의가 되어야 조합되는 컴포넌트에서도 잘 챙길수 있기 때문에 미리미리 준비 단계에서 잘 준비하려고 실무에서는 노력했던 편인것 같습니다.\n\n고생하셨고 담주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/22"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "나리님 고생하셨습니다~\n시간이 많이 부족했음에도 불구하고 잘 작성해주셨네요. \n필요로 하는 기능은 모두 충족 하는 것 같습니다.\n\n나머지 디자인 시스템 구현이라거나 디자인 토큰도 잘 정의해주셨고, shadcn 활용해서 컴포넌트 분리도 적절하게 잘 해주셨네요! \n회고도 아주 꼼꼼하게 잘 작성해주셨어요 :+1 \n\n여담으로 RHF와 zod뿐만 아니라 비슷한 별개의 라이브러리들이 RHF와 더 호환이 잘되는 경우도 있거든요 ㅎㅎ 필요성이나 장점은 많이 느끼신 것 같으니 그런것도 한번 찾아보셔도 도움이 될 것 같습니다. \n\n저는 개인적으로 나쁘지 않다고 생각하는 편인데요. 과제의 의도와 제 생각이 정확하게 일치하는지는 모르겠지만, 아토믹 디자인 관점에서 ui 배치가 제대로 되지 않았다면 배치를 제대로 하는 형태로 운영해보는게 좋지 않았을까..! 싶습니다. 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요. 이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\nFSD 관련해서도 적용해주셨는데, 잘 적용을 했는지 검토하기에는 앱 자체의 규모가 매우 작기때문에 불필요한것 같아요. 추후 과제 진행하는데 있어서 다시 이야기 나눠보면 좋을 것 같습니다 ㅎㅎ\n\n> 이번 과제를 하다보니 디자인 시스템을 만든다는게 토큰의 범위를 어디까지 잡아야할지 어려운 것 같습니다.\n\n이 부분에 관해서는 발제에서도 다룬 것처럼 3티어로 나눠서 각각 단계를 나누고 채워가는 형태로 진행하는데요. 실제 현업에서는 디자이너 분들이 이런 부분들을 직접 정의해주시는데, 제가 가서 여쭤보기로는 2번째 티어 3번째 티어에 대해서는 어느정도 구현이 되어있고 필요한 부분에 대해서만 정의하면서 나아가는 형태이고 첫번째 티어의 경우 피그마에 정의되어 있는 부분들에 대해 배리에이션을 주면서 만들어 나가시는 것 같더라구요. 아마 저희가 직접 정의를 하면서 고민이 많으셨던것 같은데, 현업에서는 완전 규칙 처럼 된 것은 없지만 어느정도 정해진 규칙에 맞춰서 생성한다. 과제에 있어서는 필요한 부분 정도만 채워도 충분하다로 봐도 되지 않을까..! 싶습니다.\n\n고생하셨고 담주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/11"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "안녕하세요 한슬님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n다만 과제 회고를 남겨주지 않으셨네요 ㅠㅠ 아쉽습니다.\n리뷰 받고 싶은 부분이 없어서 일단 피드백은 바로 마무리하겠습니다!\n추후에 궁금한점이 생기면 디스코드를 통해 편하게 문의주세요~",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/30"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "잘했어요 민수! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 최신 기술의 방향성을 체득하는 것이 목표였습니다. AI를 적극 활용해 빠르게 완료한 것도 좋지만, 더 인상적인 건 과제를 진행하면서 \"많은 제약이 결국 일관된 스타일을 만든다\"는 걸 체득한 부분이 좋네요. 모든 기술들은 저마다의 이유가 있는데 그걸 이론적으로가 아니라 진짜로 그렇구나 이해하는건 어려운거라서요.\n\n그렇다고 해서 이 모든 기술들이 내 실무에도 도움이 되거나 공감대가 있는 기술이 아닐수도 있습니다. 그래서 기술의 이점과 원칙과 실무에서의 제약과 상황을 항상 함께 같이 고려를 해야 하는게 개발자의 기술결정 능력 부분에서도 중요한 능력이라고 생각합니다.\n\n**Q) 디자인시스템이 확립되지 않은 회사에서 디자인 시스템을 도입하려면 무엇부터 시작하는게 좋을까요?**\n\n그래서 디자인 시스템을 도입하다는 생각보다는 우선 필요의 공감과 함께 이 과정이 모두에게 도움이 되어야 하도록 만들어야 합니다. 아무도 나에게 도움이 되지 않은 업무가 추가가 되는 건 반기지 않으니까요. 또한 문제에 대한 공감대를 가지는 것과 실제로 업무외에 그 작업을 할건가 라는 건 또 다릅니다. 그래서 업무를 기왕하는 김에 더 편해지는 방향으로 가기 위해 하는 거라는 인식과 방향을 만들어야 해요.\n\n디자이너들은 다양한 디자인을 하고 많이 개편을 해보고 싶어해요. 그러니까 디자인 수정을 제한하는 형태로 느껴지는게 아니라 더 디자인을 잘 반영하기 위해서 하는 거라는 입장을 취하면서도 \"제약과 약속\"이 더 좋은 디자인을 만든다라는 부분들을 함께 이야기를 나누면서 디자인은 자유롭게 그러나 디자인에 쓰이는 숫자나 팔레트등은 통일하고 정리해보자는 식으로 논의를 해보면 좋겠습니다. 개발자가 농담으로 17px은 안 쓰고 싶다 하면 그런 공감대는 디자이너도 어떤 건지 아니까 공감을 해주더라구요. \n\n저도 이런식으로 우선 수치나 색상등을 제한하고 토큰화 시키면 디자인도 하기 편해지고 나중에 수정하기도 편해진다고 figma 토큰 시스템을 알려드렸고 이러면서 다크모드 자동 전환 같은 것도 보여드리면서 토큰에 익숙해지면 variant나 component의 네이밍이나 종류등을 정해두고 디자인을 다양하게 만드는 방식으로 함께 진행했었습니다. 스토리북도 좋지만 디자인 시스템은 사실 디자이너들의 것이리기에 디자인의 체계가 정리가 되는게 먼저라고 생각해요.\n\n이후에 디자인의 체계가 갖춰지면 스토리북으로 만들어서 보여주면서 variant등도 알려주면서 뭔가가 갖춰져 가는 것들을 보여주면 디자이너들도 뿌듯하고 이게 포트폴리오가 될 수 있다는 점도 어필하면 나중에는 함께 또 으샤으쌰가 되고 그랬습니다\n\n민수만의 방식으로 즐거운 성과 만들어 보기를 바랍니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/35"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "잘했어요 재윤! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. Before 패키지 분석이 정말 꼼꼼했어요. 스타일링, 컴포넌트 설계, 폼 관리, 아키텍처, 접근성까지 문제점을 체계적으로 정리했고, 특히 접근성 부분에서 Modal의 focus trap 미구현, aria-modal 부재까지 짚어준 부분이 좋았네요. 접근성은 신경쓰기 어려운 부분인데 잘 작성해주었습니다.\n\n엔티티와 UI간의 관계에 대해서는 과제의 의도를 느꼈기를 바래요. `useManagementData`, `useManagementForm`, `useManagementActions`로 분리를 하다보면 계속해서 `entityType`에 따라 분기처리가 필요해진다는 것을 알게 됩니다. 이렇게 되면 나중에 Product, Order, Comment 같은 엔티티가 추가될 때 모든 훅과 컴포넌트에 분기를 추가해야 해요. 코드를 쪼갠 건 맞지만, 분기의 복잡성은 여전히 남아있게 됩니다.\n\n그래서 더 나은 방향은 엔티티를 중심으로 분리하는 것입니다.  `useUserData`, `usePostData`처럼 엔티티별로 훅을 만들고, `<UserTable>`, `<PostTable>`처럼 엔티티별 컴포넌트를 두는 거죠. 공통 UI는 `<DataTable>`, `<FormDialog>` 같은 범용 컴포넌트로 추출하고요. 그러면 새 엔티티 추가할 때 기존 코드를 건드리지 않고 새 파일만 만들면 됩니다. 다음 과제에서 이 관점의 차이를 경험해보길 바라요.\n\n**Q) @theme과 @theme inline 이해가 맞는지?**\n\n네, 맞게 이해했어요! `@theme`은 빌드 타임에 값이 확정되어야 해서 `var()` 참조가 불가능하고, `@theme inline`은 `var()` 참조가 가능하면서 중간 변수를 건너뛴다는 핵심을 잘 짚었습니다. \"참조 체인이 있으면 inline 필수\"라는 정리도 정확해요.\n\n수고했습니다!\n\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/12"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "안녕하세요 진아님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) 이런 프로젝트에서 폴더구조는 어떻게 하는게 좋을까요? 요즘 실무에서는 fsd를 많이 사용할까요?\n\nA)\n보통 디자인 시스템은 별도의 패키지로 분리해서 사용하는 편이랍니다 ㅋㅋ\n폴더구조의 경우 FSD 를 타이트하게 사용한다기보단, \"관심사를 묶어서 응집도를 높이는\" 방식으로 많이 사용해요. FSD도 결국 관심사를 뭉치는 방법을 표현한거라서요.\n\nhttps://feature-sliced.github.io/documentation/kr/examples\n\n이런 예제 페이지를 많이 참고해보시면 좋답니다!\n\n중요한건 FSD를 사용한다는 것이 아니라, FSD 같은 기준이 왜 만들어졌고, 그래서 FSD의 핵심이 무엇인지를 알아가는 것이라고 생각해요.\n\n \nQ) shadcn-ui를 사용하면서 컴포넌트 구조와 Storybook 기준을 어떻게 가져가는 게 좋을지 고민이 있습니다.\n\nA)\n제가 아직 실무에서 깊이 있게 shadcn을 사용해본 경험은 많지 않아서 어떤 경험이 좋다더라 라고 이야기 하기는 힘든 감이 없지않아 있네요.\n\n다만 확실한건 shadcn은 쉬운 \"수정\"을 추구하기 때문에 설치하는 방식이 아니라 내재화 하는 방식으로 제공한다고 인지하고 있는 상태입니다.\n\n그래서 원본 컴포넌트를 랩핑하기보단, 그냥 막 수정해보는거죠 ㅋㅋ 대신 확장성있는 인터페이스를 유지하는 방식으로!\n\nQ) 컴포넌트의 추상화에 대해 혹시 코치님의 기준이 있을까요? 예를 들어 모달의 경우 유저정보를 생성하는 모달, 유저정보를 수정하는 모달, 게시글을 생성하는 모달, 게시글을 수정하는 모달이 있을 수 있습니다. 저는 이걸 UserDialogContent(유저정보 생성, 수정), postDialogContent(게시글 생성, 수정)으로 분리를 했는데 이걸 누군가는 종류별로 4가지 컴포넌트를 만들수도 있을것 같습니다. 어느정도 기준에서 컴포넌트를 묶는게 좋을지 판단하는 좋은 기준이 혹시 있을까요?\n\n단순히 유저 정보 / 게시물 이라고 판단하기보단 생성/수정에 공통 로직이 얼만큼 존재하는가에 따라 다르다고 생각해요. 공통 로직이 생각보다 많이 없다면 분리하는게 좋을 것이고, 겹치는게 많으면 하나로 관리하는게 좋겟죠!?\n\n비즈니스 로직과 UI가 생각보다 불일치할 때가 있어서, 이건 그때 그때 판단을 해야하는 문제라고 생각합니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/15"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "안녕하세요 선민님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) Context vs Zustand: 현재 프로젝트 규모에서는 Context + Hooks로 충분했지만, 규모가 커지면 Zustand 같은 상태 관리 라이브러리 도입이 필수적일까요?\n\nA)\nUI를 다룰 때에는 굳이 Zustand 같은걸 사용할 필요는 없다고 생각해요 ㅎㅎ\n상태관리 라이브러리의 경우 \"도메인 로직\"을 다룰 때 더 빛을 발휘하니까요!\n\n---\n\nQ) 폼 컴포넌트 재사용: UserForm과 PostForm에 공통되는 패턴이 있는데, 더 추상화할 수 있는 방법이 있을까요?\n\nA)\n지금 정도의 수준이 적당하다고 생각합니다 ㅎㅎ\n아니면 Form 자체를 Compound Component 로 묶어서 사용한다거나!?\n\n---\n\nQ) 집계 로직과 useMemo 최적화 기준\n\n통계 계산 로직은 useMemo로 메모이제이션할 수 있으나, 현재 데이터 크기와 렌더 빈도를 고려했을 때 과도한 최적화라고 판단해 이번 과제에서는 가독성을 우선했습니다.\n실무에서는 이런 “가벼운 집계 로직”에 대해 어느 정도 수준부터 useMemo 같은 최적화를 적용하시는지, 그리고 팀 차원에서 사용하는 기준이나 룰이 있는지 궁금합니다.\n\nA)\n\n저희 팀은 \"판단 기준\"을 생각하는 것 자체가 커뮤니케이션 비용이라고 생각하여 그냥 값을 다룰 때에는 useMemo를 사용하는 편이에요.\n\n다만, 제가 개인적으로 가지고 있는 기준은 결과값이 \"원시타입\"일 때에는 useMemo를 안 써도 되고, 객체나 배열 등의 값을 반환하는 경우에는 useMemo를 씌우는 편입니다.\n\n이게 \"연산 최적화\" 때문이라기보단, useCallback이나 useEffect 등의 dependencies 에서 사용할 때 문제가 될 수 있다보니, 이런 기준을 적용하고 있어요!\n\n---\n\nQ) Form 모듈화와 useImperativeHandle 선택\n\nModal에 submit 버튼이 있고 Form이 필드를 가지고 있는 구조라 useImperativeHandle + forwardRef를 사용해 부모에서 submit을 트리거하는 패턴도 고려했습니다.\n다만 프로젝트 규모 대비 복잡도가 높다고 판단해, handleSubmit을 부모(Modal)에서 주입하고 Form은 register, errors 등 입력 책임에만 집중하도록 구성했습니다.\n\n```tsx\n<ManagementModal onConfirm={handleSubmit(onSubmit)}>\n  <UserForm register={register} errors={errors} />\n</ManagementModal>\n```\n\n이런 구조 선택이 적절했는지, 혹은 실무에서 모달 + 폼을 분리할 때 더 선호하시는 패턴(useImperativeHandle, 전역 폼 상태, 별도 FormContainer 등)이 있다면 조언을 듣고 싶습니다.\n\nA)\n이러한 방식도 좋고, 개인적으로는 이럴 때 Context를 사용하면 어떨까!? 라는 생각을 하는 편입니다 ㅎㅎ\nuseImperativeHandle의 경우 생각보다 이 흐름을 이해하는게, 작성자가 아니면 어렵다고 많이 느꼈어요.\n제가 어떤 의도를 가지고 만들었는지를 다른 사람이 이해하기가 쉽지 않달까... ㅠㅠ\n\n여튼, 제일 직관적인 방식은 Context 라고 생각해요!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/28"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "잘했어요 세준! 이번 과제는 레거시 코드를 현대적인 디자인 시스템으로 개편하면서 컴포넌트 설계 원칙을 체득하는 것이 목표였습니다. FSD 아키텍처를 적용해서 pages/features/entities/shared로 계층별 책임을 분리하고, Primitive/Semantic 2단계 디자인 토큰 시스템까지 구축한 시도가 인상적이었어요. 특히 Zod + React Hook Form으로 검증 로직을 완전히 분리하고, CVA로 variant를 타입 안전하게 관리한 부분도 좋았습니다. Tailwind 커스텀 유틸리티를 @utility 규칙으로 생성하면서 px → rem 변환 스크립트까지 만든 건 정말 수고가 많았을 거예요. \n\n지금 과제를 하는 데에는 힘이 많이 들어갔어요. 그리고 처음에 배울때에는 이렇게 오버엔지니어링이다 싶을 정도로 끝까지 가본다음에 어디까지는 필요하고 어디까지는 필요없구나는 몸소 느껴보는거 너무 좋습니다. 실제 FSD를 막상해보면 조금 과하다는 생각이 들었을 거에요. 지금 폴더명이나 파일명과 내용들이 너무 세세하게 잘게 되는 게 느껴졌을텐데 이렇게 되면 되려 내가 외울게 많아지는 부작용이 있어요. 앞으로 FSD를 계속 해보면서 가급적 외워야 하거나 새로 만들어야 하는게 적어지는 방향으로 만들어 보면 좋을 거에요\n\n**Q) DTO가 여러 도메인을 섞어 담고 있을 때, FSD 기준으로 어떤 Slice에 배치해야 하는가?**\n\n정말 좋은 질문이에요. 이건 FSD를 적용할 때 가장 자주 만나는 딜레마인데, 사실 명확한 정답은 없습니다. 다만 판단 기준은 있어요.\n\n가장 쉬운 방법은 그냥 endpoint 기준을 따라가는 것입니다. 우리팀의 백엔드가 잘하는 사람이건 그렇지 못한 사람이건 디버깅을 하거나 문제를 확인할때에는 백엔드의 구조를 알아야만 하죠. 그러니 `/api/followers/*`로 시작하는 건 다 `entities/follower/api/`에 두는 거죠. 이게 가장 예측하기 쉽고 \"외울게 적고 예측하기 쉬운가?\"를 만족하니까요.\n\nfigma처럼 백엔드는 그저 데이터를 동기화 해주는 도구이고 클라이언트에서 데이터 구조가 복잡한 경우라면 그럴때는 백엔드 API와 독립적으로 그리고 DTO를 받자마자 각 엔티티 형태로 변환하는 어댑터를 만들면 좋습니다.  이렇게 하면 API 레이어에서는 DTO를 받지만, 그 위 레이어에서는 깔끔하게 분리된 도메인 모델을 받게 만드는 거죠. 그러면 DTO의 혼란이 상위로 전파되지 않아요.\n\n근데 대부분의 경우에는 클라이언트 중심의 어플리케이션을 하기 보다는 백엔드 중심으로 이미 설계가 다 끝나다보니 너무 완벽하게 분리하려고 하지 마세요. 실무에서는 서버가 주는 대로 받아야 할 때가 훨씬 더 많답니다. 하하.\n\n저도 여러가지 방법들을 시도하면서 깨달은 바이니 알려준건 참고만 하시고 직접 해보면서 비교해가며 느껴보기를 바래요. 수고하셨습니다!\n",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/4"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "안녕하세요 채은님! 6주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) 현재 리팩토링 한 hooks가 조금 과하게 설계되어 있다는 느낌을 받고 있습니다. (ex .useTableColumns, useEntityStats)\n아직 시간이 없어서 개선을 하지는 못했지만, 도메인 관련된 로직이지만 순수 계산함수나, 단수 상수를 반환하는 로직은 유틸로 분리해도 괜찮지 않을까?하는 판단에 대해서 어떻게 생각하시는지 궁금합니다.\n\nA)\n일단 hook은 보존해도 무방하고 hook 내부의 로직들을 순수함수와 상수로 분리해서 사용하면 어떨까!? 라는 의견입니다 ㅎㅎ\n\n무엇이 더 좋고 나쁘고가 있다기보단 \"일관성\"이 필요하다고 생각해요.\n\n저는 개인적으로 컴포넌트 내부의 로직은 거의다 hook으로 분리하는 편이랍니다!\n\n---\n\n\nQ) 테일윈드에서는 이미 기본값을 공해주고 있는데 겹치는 값들 또한 토큰으로 관리하는 방식이 좋은 방법일까요?\n\nA) 만약 tailwindcss를 사용하지 않는 결정을 하게 된다면 어떻게 될까요!? 혹은 디자인 시스템을 아예 라이브러리로 만들어서 사용한다거나!? 이럴 때에는 tailwindcss 가 발목을 잡을 수 있답니다!\n그래서 tailwindcss에 의존적이여도 잘 발라낼 수 있는 (쉽게 제거할 수 있는) 방법을 고민해보시면 좋다고 생각해요.\n\n관련 논의: https://discord.com/channels/1288769861589270590/1444676819059216514\n\n---\n\nQ) 현재 EntityContext로 전역 상태를 관리하고 있습니다. AI로 진행하다보니 Context 관리로 진행되었는데 현재 프로젝트에서 관리하는 props 개수를 봣을 때에는 과한 설계라고 생각이 들었습니다. 혹시 멘토님은 기준으로 Context를 관리하시는지 궁금합니다!\n\nA) 특정 페이지 혹은 특정 구역(?)에서 쓰이는 구간을 Context로 관리하면 좋다고 생각해요. 전역 상태를 만든다기보단, scope를 구성해서 사용하는거죠.\n\n어떤 영역에서만 쓰이는 공통 값이 있을 때 context로 묶어주면 편하답니다!\n똑같은 변경주기를 가진 값이라고 해야하나..?",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/38"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "준태님 굉장히 꼼꼼하게 잘 정리해주셨네요!\n디자인 시스템도 잘 적용해주셨고, 각 작업데 대한 과정도 세세하게 되어있어서 어떻게 진행하셨는지 잘 이해할 수 있었습니다 :+1\n피그마도 구성해주셨구요 ㅎㅎ 폴더 구조 분리도 적절했습니다. 회사에서도 단계별로 잘 적용하고 지금보다 훨씬 복잡할텐데 잘 풀어나가시면 좋겠네요!\n\n> 아토믹 패턴을 도입하기 좋은 상황(또는 조건)이 뭔지 궁금합니다! 대규모 웹서비스거나 개발팀 규모가 클 때 효과적인 패턴인가요?\n\n저는 개인적으로 디자인 시스템을 도입하는데가 가장 최적이지 않나 싶어요.  \n이 atomic 디자인이라는걸 저희도 사용하지만, 디자인 시스템을 구축하는 디자이너들도 함께 사용하고 있을거라 커뮤니케이션 관점. 컴포넌트를 적절하게 나눈다는 관점에서 유지를 하는게 더 좋지 않을까 라는 생각이 있습니다. 디자인 시스템을 구축한다는 관점에서 지속적이게 디자이너들과 소통을 해야 한다는 점이 생각하는 것보다 훨씬 더 중요하고 큰 작업이 될것이라고 생각해요.  관련해서 읽어볼만한 글도 함께 드릴게용\n\nhttps://tech.kakaoent.com/front-end/2023/230330-frontend-solid/\n\n> 모노레포를 도입할 때, '이런 레포지토리끼리는 하나의 모노레포로 엮지 말아야한다.' 하는 레포지토리끼리의 상성 관계가 있을까요?\n\n상성 관계라기보다는 도메인적으로 전혀 연관성이 없거나.. 관리 정책 관점에서 함께 있으므로 장점이 발휘되기 어려운, 의존도 다르게 쓰는 부분들은 굳이 한 저장소에 위치시키는게 필요할까 싶어요! 개발 환경과 관리적인 관점에서 많이 고민하는게 좋을것 같아요.\n\n> 컴포넌트에서 비즈니스 로직을 분리할 때 어느 정도로 분리하는게 좋은지 판단이 서질 않습니다..! 예를 들어 컴포넌트에서는 이벤트 핸들러 정도만 남겨두고 나머지 로직은 최대한 커스텀 훅으로 분리하면 될까요? 아니면 컴포넌트에서 UI 구조가 명확히 잘 보인다 싶으면 비즈니스 로직 분리를 그만해도 되는 걸까요?\n\n음.. 그런 기준보다는 한 컴포넌트에 단일 책임 관점에서 함께 위치시키는게 적절할지 분리하는게 적절할지를 고민해보면 좋을것 같아요. 딱 적합한 규칙, 지켜야 되는 관행 같은것들은 없다고 생각하거든요. 기계적으로 뭘 분리한다기 보다는 화면을 그리는 책임, 비즈니스 로직 (데이터를 처리하는 계층) 같은 것들을 나눈다거나 하도록 책임에 맞춰 나누면 되지 않을까..! 싶습니다.\n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP12 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-1/pull/32"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/43"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/32"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/1"
    }
  },
  {
    "passed": true,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/26"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/29"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/30"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/24"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/33"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/17"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/31"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/35"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/18"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/40"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/12"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/36"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/15"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/9"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/21"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/14"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/6"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP13 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/8"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/43"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "수고하셨습니다. 다솜님!\n\n- searchTerm 전역 상태 관리\n너무 복잡하게 생각하실 필요 없을 것 같아욥. \n이게 너무 단순한 조언일지 모르지만 \"필요할 때, 그 이유때문에 사용하면\" 됩니다. 멘토링때 말씀드렸던 리팩토링과 같은 이치죠\n이유가 있다면 그리고 현재 대체가능한 대안이 없다면 사용하시면됩니다.\n\n요즘은 같이 캐싱기반에 패칭도구인 Tanstack Query가 상태관리도구의 대부분의 영역을 커버하고 있습니다.\n그럼 어느때 상태관리 도구를 사용해야하느냐 할때,\n서버에 저장할 필요없는 UI의 휘발성 상태를 멀리 떨어져있는 UI들이 공유할 때 사용하는 것은 그 이유중 하나일 것 같아요.\n\n\n- Compound Component 패턴과 Context 설계에 대한 질문\n제가 뭔가 잘못 이해한건 아닌지 모르겠지만, 왜 제너릭타입이 필요한거에요?\nactiveTab의 type이 스트링이면 되지 않나요?\n뭔게 제가 의도를 파악하지 못한 것 같은데욥 tabㅇ\n탭과 패널을 매칭하는 키 격인 activeTab을 string으로  제한하면 많은 부분이 해결될 것 같아요!\n\n\n- Props 유지와 selectedCoupon 관리 기준\ntotals는 부모(StorePage)에서 계산 후 props로 전달하는 현재 방식이 저는 적절한 것같아요.\ntotals가 서브 노드의 한곳에서만 사용된다면 성능상의 이슈로 서브컴포넌트에서 직접 훅을 사용하라고 말씀드렸을텐데 그것도 아닌것 같아요.\n전역과 로컬 상태에 대한 기준은 재사용성과 프롭드릴링을 피하는 관점에서 잘 선택하시면 될 것 같습니다.\n서브컴포넌트가 다른곳에서 재사용된다면 저는 서브노드에서 상태를 불러올것 같아요. 무거운 계산이라면 메모이제이션도 활용해서 계산할때 비용을 줄일 수도 있고욥.\n그렇지 않으면 저도 이렇게 만들것 같아욥.\n\n뭔가 답이 있다기 보다는 상황에 따라 자신만에 이유를 만드는게 제일 중요한 것 같아요.\n\n- Zustand Selector와 Storage\n세밀한 selector는 리렌더링을 줄여 성능 최적화에 유의미합니다. 현재 cartContext() 패턴도 객체 분리로 괜찮으나, selector 직접 사용이 더 정밀합니다. \n실제로 개발자도구를 사용해 어떻게 영향을 주는지 직접 눈으로 하나씩 확인해보시면 좋을 것 같아요.\n\n스토리지는 사실 적절히 영리하게 대응하셨다고 생각합니다. 말씀하신대로 수동으로 구현해도 괜찮고요.\n이건 사실 그냥 선택의 문제인 것 같습니다 :) \n\n- 아이콘 네이밍\n장기적인 관점에서는 모양보다는 용도기반 네이밍이 유리합니다.\n옹도기반 네이밍이 모양보다는 좀 더 추상적인 개념이고 변경가능성을 수반합니다\n이는 꼭 아이콘 네이밍 뿐 아니라\n변수나 함수에대한 네이밍에서도 동일합니다~\n\n헥헥.. \n다솜님 말씀하신대로 내용이 많고,  제가 시간이 별루 없어서 최대한 작성한다고 했는데 부족하거나 잘못 답변하게 있을 수도 있어요\n이해해주세요~",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/32"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "으아니 정원님!\n아무 내용이 없는걸 보니 많이 바쁘셨나보군요.\n물론 그러시겠지만, 지금 과제들도 여유 있으실때 꼭 진행해보고 팀원분들과 의견 나누시면 좋을것 같습니다\n궁금하신거 있으면 편하게 질문주시구요.\n\n고생하셨어요!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/1"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "안녕하세요 연욱\t님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~! 다만 심화과제까지 하기에는 시간이 많이 부족했었군요 ㅠㅠ 아쉽습니다.\n\n> 개발 속도나 지식·경험이 아직 부족한 상황에서, 주어진 시간 안에 과제 제출의 완성도를 조금이라도 높일 수 있는 방법이 궁금합니다. 특히 제한된 시간 속에서 어떤 기준으로 우선순위를 정하고, 무엇부터 손대야 가장 효과적일지 코치님의 의견을 듣고 싶습니다!\n\n흠.. 실무와 학습을 나눠놓고 보자면\n실무는 사실 \"동작하는 코드\"가 제일 중요하다고 생각해요. 일단 동작을 해야 리팩토링이라도 할 수 있으니까요 ㅎㅎ\n\n그런데 학습에서는 \"시간 제한 + 완성도\"를 모두 챙기는게 그렇게 의미있는건가? 라는 생각이 들어요.\n사람마다 학습하는 속도가 다르고 관심있는 분야가 다르고, 관심사가 다르기 때문이죠.\n무엇보다 정답이랄게 딱히 없달까...\n\n그래서 저는 학습할 때에는 효과적인 방법 보단, 내가 관심있는 분야를 조금 더 파고들어가는게 좋지 않나!? 라는 생각입니다!\n그럼에도 불구하고 제일 효과적인 방법은, 이 지식을 제일 잘 알고 있는 사람에게 가서 내가 궁금한 부분을 물어보면서 배우는거죠!\n\n아래의 링크도 한 번 살펴보시면 좋겠어요!\n\n---\n\nhttps://www.threads.com/@aicoffeechat/post/DRohYCJkkPF \n\n1. 공부 순서를 완전히 Top-Down 방식을 따르라고 합니다.\n우리는 보통 기초부터 닦고 응용으로 넘어갑니다. 수학 배우고, 선형대수 배우고, 그제야 머신러닝을 하죠. 가브리엘은 정반대입니다. \"일단 프로젝트부터 만들어라\"라고 합니다. 코드를 먼저 짜고, 버그를 고치고, 작동하면 그때 \"왜 작동하지?\"를 파고들어야한다고요.\n2. AI에게 집요하게 물어보기 (재귀적 갭 채우기)\n모르는 게 나오면 챗GPT한테 끝까지 물어보는 겁니다. \"이 코드가 왜 작동해?\" -> \"행렬 곱셈 때문이야\" -> \"행렬 곱셈이 뭔데? 직관적으로 설명해 줘\" -> \"그래프 그려줘\". 이렇게 꼬리에 꼬리를 물고 내려가면 3일 만에 Diffusion Model의 기초를 다 뗄 수 있습니다. 학교에서 6년 걸릴 걸 며칠 만에 끝내는 거죠. (개인적으로 너무 공감되는 방법입니다)\n3. 진짜 문제'를 찾아라. 그게 최고의 스승이다.\n학교 공부가 지루한 건 '압박감'과 '실전성'이 없어서입니다. 가브리엘은 스타트업에서 실제 제품 추천 시스템을 만들며 코딩을 배웠습니다. 고객사 웹사이트를 스크래핑하고, A/B 테스트를 돌리면서 \"당장 해결해야 하는 문제\"에 닥치니까 뇌가 스펀지처럼 흡수하는 거죠.\n4. 이력서 대신 '데모'를 보여주기\n이젠 아무도 어느 학교 나왔는지 궁금해하지 않습니다. 기업은 딱 하나, \"돈을 벌어다 줄 수 있는가\"만 봅니다. 복잡한 자기소개서 대신, 클릭 한 번으로 당신의 실력을 증명할 수 있는 '데모 링크'를 보내라고 합니다. 가브리엘은 고객사 문 두드릴 때 아예 그 회사의 추천 시스템을 개선한 결과물을 인쇄해서 들고 갔습니다.\n5. '나를 위한' 조언만 듣기\n대부분의 조언은 무시해도 된다고 이야기합니다. 특히 본인의 경험에 갇힌 사람들의 조언은요. 가브리엘은 부모님이나 학교 선생님의 \"안전한 길로 가라\"는 말 대신, 자신과 결이 맞는 사촌의 조언을 따랐습니다. 자신의 인센티브와 맞지 않는 사람의 조언은 과감히 필터링하라고 합니다.\n6. 기회는 '밀도'에서 나온다\n왜 굳이 샌프란시스코로 갔냐는 질문에 이렇게 대답합니다. 거기엔 '나처럼 생각하고, 나처럼 일하는' 미친 사람들이 모여있기 때문이라고요. 환경이 주는 레버리지는 상상 이상이라고 강조합니다.\n\n---\n\n이정도로 요약할 수 있겠네요!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/26"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "지현님 \n이번과제에는 시간이 부족하셨나봅니다.\n다음 과제는 꼭 완주하세요!!!!!!!!!!!!!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/29"
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "안녕하세요 대현님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\n제가 분명 피드백을 남겼는데 다 사라졌네요... 이게 무슨일이지... ㅠㅠ\n\n---\n\n> 폼 상태(editingProduct, productForm)를 선언한 컴포넌트와 자식 컴포넌트에서만 사용하여 로컬상태로 두었는데요. 폼 상태의 경우 이 처럼 로컬에 두는 것과 전역으로 올리는 것 중 어떠한 방법이 더 효율적일지 궁금합니다.\n\n폼상태는 개인적으로 Context로 관리하는게 제일 마음 편하다고 생각해요.\n참고로 Context와 전역상태는 다른 개념이랍니다!\n\n혹은 react-hook-form 처럼 정의하는 방법도 있겠네요 ㅎㅎ\n\n그리고 로컬 상태로 관리한다고 했을 때도 고려해본다면.. 지금은 props를 다 상위 컴포넌트에 정의한 변수 명으로 하위 컴포넌트의 props를 정의해주고 있어요.\n컴포넌트 입장에서 이건 잘못된 의사결정이라고 생각합니다.\n\nProductForm 이 독립적으로 쓰일 수 있도록 만들어줘야 한다고 생각해요.\n가령 이런 모습을 상상해보시면 좋답니다.\n\n### as-is\n```tsx\n<ProductForm\n  editingProduct={editingProduct}\n  productForm={productForm}\n  setProductForm={setProductForm}\n  handleProductSubmit={handleProductSubmit}\n  resetProductForm={resetProductForm}\n/>\n```\n\n여기서 쓰이는 setProductForm이 지역상태일 수도 있고 전역상태일 수도 있겠죠? 그런데 지금은 setProductForm 이라는 이름으로 역할을 제한하고 있지 않나? 라는 생각이 들어요.\n이 외에도 이미 `ProductForm` 이라는 이름에 Product를 다루고 있음을 암시하고 있는데, props에도 다 product가 들어가있습니다.\n\n### to-be\n```tsx\n<ProductForm\n  editing={editingProduct}\n  values={productForm}\n  onChange={({ key, value }) => setProductForm(prev => ({ ...prev, [key]: value }))}\n  onSubmit={handleProductSubmit}\n  onResetClick={resetProductForm}\n/>\n```\n\n이렇게 변경해보면 어떨까요? 오직 ProductForm 입장을 고려하는거죠.\nhtml tag의 attribute 를 상상해보시면 좋을 것 같아요.\n\n\n> atomWithStorage 사용 시 테스트 환경에서 createStore()로 격리하는 방식 외에 더 좋은 패턴이 있는지 알고 싶습니다.\n\n지금은 이게 최선이라고 생각해요!\n전역상태는 말 그대로 전역공간에 데이터를 올려놓고 사용하는건데\ncreateStore는 Provider를 통해 전역상태의 Scope를 제한하는 방식이라고 보시면 좋답니다 ㅎㅎ\n그래서 테스트간의 격리를 위해 필수인거죠.\n이거 말고 다른 방법을 고민하고 있따면... 결국 나만의 방식으로 Context/Provider를 만들어야 합니다. 무척 귀찮고 번거롭겠죠!?\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/30"
    }
  },
  {
    "passed": true,
    "name": "김도현",
    "feedback": "고생하셨습니다 도현님!\n회고를 보는데 시간이 많이 없으셨음에도 AI를 활용해서 잘 해주신것 같아요\n쏙쏙 함수형 프로그래밍 책도 상당히 좋은데요! \n뭔가 책보다는 과제 직접 수행해보시면서 다른 분들 코드리뷰도 많이 해보고 고민 해보시면 더 좋을것 같아요 ㅎㅎ\n절대적인 기준은 없지만 각자 생각하는 고민들을 보다보면 실용적인 내용들이 많이 보이실것 같아요.\n그럼 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/19"
    }
  },
  {
    "passed": false,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/24"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/10"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "우정님 수고하셨습니다.\n\n* getRemainingStock처럼 두 개 이상의 엔티티를 다루는 로직을 어떻게 분리하고 어디에 위치시켜야 할까요?\n제가 못찾는 것인지 getRemainingStock으로 검색하면 아무것도 안나오는데요.\n먼저 생각하신 내용과 약간의 코드도 같이 주셨으면 답변이 수월했을 것 같습니다!\n혹시 calculateRemainingStock.ts인가요?\n사실 여러가지 방법이 있을것 같아요 utils의 정의를 N개 이상에서 사용되는 계산로직들이라고 정의한다면 그곳에 넣어도 될 것 같고욥.\n이렇게 하든 저렇게하든 뭐가 매우 좋다기보다는 우정님의 의도만 있으면 되고 그 의도에 대한 일관성만 유지하는 것이 중요합니다.\n\n* view만 담당하는 컴포넌트들에서는 비즈니스 로직을 몰랐으면 해서, formatPrice 같은 유틸함수도 상위에서 props로 받게 했는데 이런 접근이 괜찮은지 궁금합니다.\ncartPage의 formatPrice를 말씀하시는것이죠?\n비지니스 로직을 캡슐화 하려는 시도는 좋은 시도 있는 것 같아요.\n오히려 비지니스 로직을 특정 레이어로 일관성을 유지하는 것도 좋을 비니지스를 캡슐화하는 레이어를 추상화해서 약속하는 거죵.\n그런데 이 함수 만으로는 그렇게 하긴 과한 것 같고요.\n아무튼 비지니스 로직을 분리해서 UI를 몰라도 되게하는 방법은 매우 추천합니다.\n\n수고하셨습니다.\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "안녕하세요 준모님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\n일단 지금 기본과제가 정상적으로 실행되지 않고 있어요.\n이유가 뭘까 고민해봤는데...\n전반적으로 AI가 만들어놓은걸 그대로 사용하신 것 같네요ㅠㅠ\n혹시 몰라서 과거의 커밋으로 되돌아가서 테스트 해봤는데 여전히 오동작하네요.. ㅎㅎ\n\n배포된 페이지도 동작하지 않고..\n심화과제는 테스트 통과해서 잘 되나 살펴봤는데 역시 안 되네요ㅠ\n\n왜 되나 싶었는데 테스트도 아마 AI가 다 수정하면서 강제로 통과된게 아닌가 싶네요.\n\n\n> 도메인 단위로 props를 묶어서 전달하는 방식이 과하게 뭉친 형태는 아닌지, 더 나은 구조가 있을지 궁금합니다.\n\n음.. 지금 PR을 열어서 확인해보려고 해도 파일들이 다 접혀있다보니 뭔가를 확인하기가 어렵네요 ㅎㅎ;\n여튼 props를 내려주는 방식을 보니까 전부 \"외부에서 정의된 이름을 그대로\" 내려주고 있어요.\n\nprops를 사용하는 컴포넌트 입장에서 이름이 정의되어야 하는데 지금은 다 바깥에 정의된 이름을 그대로 props에 넘겨주고 있다보니... 좋은 모습은 아니라고 생각해요.\n\n가령 HeaderActions의 경우 지금은\n\n```tsx\n<HeaderActions\n  isAdmin={isAdmin}\n  setIsAdmin={setIsAdmin}\n  cart={cart}\n  totalItemCount={totalItemCount}\n/>\n```\n\n이렇게 정의되어있는 상태인데, HeaderActions 입장에서 정의된게 아니라 HeaderActions를 사용하는 App 컴포넌트 입장에서 정의된 props입니다.\n\n이걸 HeaderActions 내부의 코드를 토대로 정의해보면 이런 모습이겠죠?\n\n```tsx\n<HeaderActions\n  isAdmin={isAdmin}\n  onLogoClick={() => setIsAdmin(!isAdmin)}\n>\n\t{cart.length > 0 && (\n    <span className=\"absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center\">\n      {totalItemCount}\n    </span>\n  )}\n</HeaderActions>\n```\n\ntotalItemCount를 출력하는 부분을 아예 children으로 분리하는거죠.\n혹은 이렇게 아예 명시적으로 표현하다거나?\n\n\n```tsx\n<HeaderActions\n  isAdmin={isAdmin}\n  countArea={cart.length > 0 && (\n    <span className=\"absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center\">\n      {totalItemCount}\n    </span>\n  )}\n  onLogoClick={() => setIsAdmin(!isAdmin)}\n/>\n```\n\n컴포넌트 바깥이 아니라 컴포넌트 내부에서 어떻게 쓰이는지가 중요해요.",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김채영",
    "feedback": "안녕하세요 채영님! 7주차 과제 잘 진행해주셨네요. 압도적인 회고에 놀랐습니다 ㅎㅎ 고생하셨습니다~!!\n\n> 처음부터 기능과 구조를 설계할 때 어떤 기준이나 접근 방식으로 시작하면 좋을까요?\n\n제일 중요한건 요구사항이라고 생각합니다 ㅎㅎ\n요구사항은 기능 요구사항과 비기능(기술) 요구사항이 있어요.\n\n기능 요구사항에 제일 잘 대응할 수 있는 설계가 있으니 이를 먼저 고려해야 한답니다.\n비기능 요구사항은\n- 모노 레포 vs 모놀리식 레포\n- vue vs react\n- csr vs ssr\n- ..\n\n이런 것들이죠!\n\n어떤 요구사항을 어떤 방식으로 구현하는지에 따라 설계가 완전히 달라지기 때문에, 요구사항에 대한 접근이 중요해요.\n정답이 딱히 없는 영역이랄까...\n\n코드를 작성할 때에도 \"기능 요구사항이 추가/수정/삭제 된다면 어떻게 될까?\" 를 항상 고민해보시면 좋답니다!\n내가 작성한 코드가 어떤 요구사항에 잘 대응되는지 시뮬레이션을 돌려보는거죠 ㅎㅎ\n\n\n> 구조 설계 단계에서 피그잼이나 노션에 어떤 내용을 정리하면 실전에서 가장 효과적인지 노하우가 있을까요?\n\n저는 \"사용자 시나리오\"와 \"엣지 케이스\"를 정리해보는거라고 생각해요.\n\n1. 사용자 시나리오를 만들고\n2. 사용자 시나리오에 대한 use-case 를 설계하고 \n3. use-case 에 대응 되는 구간을 설계하고\n\n이런 과정이랄까... 이게 글로 설명하기는 어려운데 다음에 멘토링 때 기회가 되면 저희 팀에서 했던 방식을 소개해드릴게요!\n\n\n> 패턴과 함수형 사고를 자연스럽게 적용할 수 있도록 훈련하는 방법이 궁금합니다!\n\n일단 함수형으로 코드를 다 작성해보는거죠 ㅎㅎ\n함수형 사고는 결국 \"선언형 패러다임\"과 연관있다고 생각해요.\n\nAI를 이용해서 \"이걸 선언형 패러다임으로 만든다면 어떤 모습일까?\"를 계속 물어보는 방법도 좋답니다!\n\n패턴은.. 저도 잘 모르겠어요 ㅋㅋ\n\n제일 도움이 많이 되었던건 \"리팩토링\"을 반복적으로 해보는 것이라고 생각해요.\n만들었던 것을 다시 수정하고 수정하고 수정하는 과정을 거치면서 훈련을 하는거죠.\n다만 똑같은 방식으로 만들기보단 다양한 시도를 해보시면 좋답니다!\n\n저는 극단적인 오버엔지니어링을 하면서 실력이 많이 늘었었어요. 그러면서 밸런스를 맞춰가는거죠!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/3"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/33"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/17"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/42"
    }
  },
  {
    "passed": true,
    "name": "박수범",
    "feedback": "안녕하세요 수범님! 7주차 과제 잘 진행해주셨네요. 압도적인 회고에 놀랐습니다 ㅎㅎ 고생하셨습니다~!!\n\nQ1) 아키텍처 및 구조 관점 (FSD)\nFeature와 Entity의 경계 및 위젯의 역할 축소에 대해 의견이 궁금합니다.\n이번 리팩토링에서 장바구니 계산 로직(calculateCartTotal)은 entities로, 상태 관리(useCart)는 features로 분리했습니다.\n특히 AdminDashboard 위젯이 가지고 있던 폼 상태와 유효성 검사 로직까지 features 레이어(ProductManagementForm 등)로 내리면서 위젯이 오로지 조립 역할만 하게 되었는데요.\n이 구조가 FSD의 의도에 부합하는지, 혹은 위젯이 너무 껍데기만 남은 것은 아닌지 아키텍처 관점에서의 피드백이 궁금합니다.\n\nA1)\n굳이 FSD에 부합할 필요가 있을까요?\n저는 Entity가 \"리액트에 의존적이지 않은 코드\" 라고 정의해야 제일 편하다고 생각해요 ㅎㅎ\n말씀해주신 것 처럼 순수한 계산 로직이 entity에 있으면 좋달까!?\nfeature도 적절하게 분리해주신 것 같습니다.\n\n다만, FSD에 너무 집착하진 않았으면 좋겠어요.\nFSD는 관심사를 분리하는 일종의 패턴이고, 이 패턴 자체가 굉장히 복잡합니다.\n\n위젯은 뭐.. 없어도 되는 레이어라고 생각합니다 ㅎㅎ\n개인적으로 entities와 features를 합쳐도 무방하지 않나!? 라고 생각해요!\n\n---\n\nQ2) 상태 관리 및 동기화 관점 (Zustand & Sync)\nApp.tsx에서의 수동 데이터 동기화 패턴이 적절한지 궁금합니다.\nZustand의 persist 미들웨어를 사용하는 대신, persist를 제거하고 App.tsx에서 useEffect를 통해 로컬스토리지와 스토어를 수동으로 동기화하는 방식을 택했습니다.\n이는 테스트 환경에서의 격리와 레거시 데이터 호환성을 확보하기 위함이었는데요. 이 패턴이 장기적인 유지보수 측면에서도 유효할지, 혹은 더 나은 대안이 있을지 의견이 궁금합니다.\n\n음.. 일단 제일 큰 문제는 최초에 렌더링할 때 storage의 값을 사용할 수 없다는 점인데요, 이건 추후에 발목을 잡을 수 있답니다 ㅎㅎ\n그냥 persist 미들웨어를 사용하고, 이 때 테스트를 어떻게 작성하면 좋을지 알아보는게 더 좋지 않을까요?\n\n레거시 데이터 호환성은... 어떤 레거시를 이야기하는지 잘 모르겠네요..!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/31"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/39"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "고생하셨습니다 지영님! 과제도 잘 진행해주셨고, 고민 남겨주신것 보니 리팩토링 관점에 있어서 깊은 고민을 하셨던 것 같아서 너무 좋네요! \n남겨주신 질문 빠르게 답변 남겨볼게요.\n\n> 1. 파일 분리 수준과 디렉토리 구조\n\n현재 수준의 분리도 적절하다고 생각해요. 명확한 규칙으로 파일, 폴더가 나뉘어져 있고 어디에 어느 파일, 로직이 있겠구나 라고 인식이 가능하니까요. 지금의 수준에서는 더 가지 않아도 괜찮다고 생각하고, 더 규모가 커진다면 FSD처럼 피처 단위로 명확하게 계층을 나누는것이 좋다고 생각해요. 현재의 기준처럼 비즈니스 로직, 상태관리와 부수효과, UI 단계로 각각 모델, 훅, 컴포넌트로 분리하는게 적절하다고 저는 생각합니다. \n\n> Props 전달 패턴\n\n개인적으로는 특정 도메인에 종속된 form 값이라면.. 아예 훅같은걸로 묶어서 관리하는게 더 좋을 것 같아요! 지금의 방식은 말씀해주신것처럼 관리가 어려워지고 재사용 관점에서도 좋지 않을 것 같아요. 대안으로 말씀해주신 방법 두개 모두 좋지만, 저는 훅으로 분리해서 관리하는게 더 좋다고 생각합니다.\nreact-hook-form의 구조를 참고해보면 좋을것 같아요!\n\n> Event Emitter 패턴 사용\n\n음.. 개인적으로는 전역 상태 라이브러리나 Context API를 사용하는게 적절하다고 생각이 드는데요! 개인적으로는 컴포넌트 트리 바깥에서 이뤄지는 작업들이라면 해당 패턴을 사용하는게 나쁘지 않아보이지만, 컴포넌트 내부에서 이뤄지는 어떻게 보면 상태나 컴포넌트에 영향을 줄 수 있는 부분들은 라이프사이클 내에서 이뤄지는게 안정적이다 라고 볼 수 있을 것 같아요. 예측 가능하게요.\n\n> addNotification 알림 처리 패턴\n\n현재의 구현과 다르게 훅 내에서 훅을 사용하고 있는 형태가 결합도를 높이는 방식이라고 생각해요. 지금처럼 메서드를 주입하는 형태는 오히려 결합도를 낮추는 방식이에요. 지금의 방식은 매번 주입을 해야하기 때문에 조금 귀찮을 수 있지만요 ㅎㅎ \n\n훅에서 직접 알림을 발생시켜 UI가 나타난다는 관점에서 책임 범위를 벗어난다고 생각할 수 있는데, 결국 어떤 상황에 어떤 메세지가 노출된다는건 도메인에 얽힐 수 있는 내용 같아요. 결과만 반환하고 UI 노출만 훅 바깥에서 처리한다면 조금 더 순수성은 높아지지 않을까..! 싶은데 적절한 수준만 잘 맞춰서 운영하면 될 것 같아요.\n\n메세지는 상수파일로 각각 도메인에서 분리해서 사용하면 좋을것 같아요 ㅎㅎ\n\n전반적으로 질문을 주실 때 정답인지, 올바른지에 대해 질문을 주셨는데요!\n사실 전부 '왜'라는 부분에 답변을 어떻게 하느냐가 중요한것 같아요.\n왜 이 패턴을 쓰고 왜 이 기능을 쓰고 그럼 이 '왜'라는 부분에서 발생하는 문제가 해결되었는지 정도만 보면 되거든요 ㅎㅎ\n\n고민이 전부 합리적이였고 저도 쓰면서 재밌었네요. 고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/35"
    }
  },
  {
    "passed": false,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/41"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "안녕하세요 형우님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\n> 위의 실무에서 적용 방법은 AI가 답해준 방법입니다. 추가적으로 주의해야하거나 유용한 방법이 있다면 알려주시면 감사하겠습니다!\n\n흠... AI가 작성해주긴 했는데 무슨 말인지를 솔직히 잘 모르겠어요 ㅠㅠ\n이해가 안 된다고 해야하나..\n\n- 게릴라 처럼 티 안나게? -> 이게 무슨말일까요..?\n- \"순수 함수\"로 로직 빼내기 -> 점진적으로 순수함수들을 분리할 수 있으면 좋겠네요!\n- 나만의 작은 FSD\" 만들기 -> 이거랑 현재 과제랑 어떤 연관이 있는걸까요? 지금 당장은 고민하지 않아도 될 것 같아요.\n- 신규 기능만 \"제대로\" 만들기 -> 이것도 무슨소린지...\n\n너무 AI 에게 의존하진 않았으면 좋겠습니다 ㅠㅠ\n\n\n제가 개인적으로 추구하는 방식에 대해 알려드리자면.\n\nhttps://junilhwang.github.io/TIL/clean-code/as-requirements-change/\n\n조금... 긴 호흡의 글이긴 한데 한 번 참고해주시면 될 것 같아요 ㅎㅎ\n\n글에서 전개하고자 하는 내용은\n\n1. 순수함수로 최대한 분리하면 Vanilla로 되어있는 프로젝트를 손쉽게 React로 전환할 수 있다.\n2. 관심사(데이터와 UI, 이벤트 등)를 잘 분리해서 가지고 있으면 마찬가지로 경계를 잘 분리할 수 있다.\n3. 1~2를 토대로 테스트 또한 잘 작성할 수 있다.\n\n입니다!\n\n결국 FE 개발자는 데이터를 UI로 전환하는 작업을 하는 것이라고 생각해요.\n\n그렇다면 데이터를 다루는 부분과 UI를 표현하는 구간을 자연스럽게 분리해줘야 하는데요,\n분리가 되지 않는 모습이 컴포넌트 내부에 데이터를 다루는 로직이 산재해 잇는 경우입니다.\n\nReact를 다시 Vue로 전환한다고 했을 때 혹은 Vanilla로 전환한다고 했을 때 이런 부분이 크게 문제될 수 있어요.",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://hyeongwoo94.github.io/front_7th_chapter3-2/"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "안녕하세요 희정\t님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!\n\nQ1) 훅의 책임 범위\n\n- useCart가 너무 많은 책임을 지고 있는 것 같은데, 제가 잘못 설계한걸까요?\n- 아니면 이 정도 응집도는 괜찮은 건가요?\n\n\nA1)\n\n너무 많은 책임을 가지고 있는게 맞다고 생각해요 ㅎㅎ\n\nhttps://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/\n\n제가 작성한 글인데 한 번 참고해보시면 좋겠어요!\n\n일단 cart와 coupon을 분리할 수 있지 않을까 싶어요.\n\n이제보니 이미 useCoupon이 있네요 ㅎㅎ\n\nuseCartUseCase\n\tuseCart\n\tuseSelectedCoupon\n\n요렇게 만들어서 관리할 수 잇지 않을까 싶기도 하고!?\n\n---\n\nQ2) Props 분리 기준\n\n- 저는 \"driling 깊이(2-3단계 이상)\"를 주요 기준으로 삼았는데, 이 기준이 적절한가요?\n- 멘토님은 어떤 기준으로 어떤 props는 남기고, 어떤 props는 전역 상태로 빼시는지 궁금합니다.\n\nA2) \n\nui 상태와 관련 있는 경우 -> 로컬상태 or Context\n도메인과 관련 있는 경우 -> 전역상태\n\n저는 \"전역상태관리\" 에서 \"전역\"보다 \"상태관리\"가 더 중요하다고 생각해요.\n어플리케이션 전반에 쓰이는 도메인과 연관된 상태를 묶어서 분리하는거죠!\n\n다만 도메인 상태임에도 불구하고 Props로 내리는 경우가 있을텐데,\n재사용 가능한 형태의 컴포넌트인 경우에는 props를 통해 데이터의 원천과 관계 없이 사용할 수 있도록 하는 편이랍니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/40"
    }
  },
  {
    "passed": false,
    "name": "손승현",
    "feedback": "안녕하세요 승현\t님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\nQ1) Hook 설계\n\nuseCart에서 getItemTotal, getItemDiscountRate 같은 헬퍼 함수를 반환하는 것이 적절한지, 아니면 컴포넌트에서 직접 모델 함수를 호출하는 것이 나은지 궁금합니다. 현재 방식은 편리하긴 하지만 Hook이 조금 과부화(?)되는 단점이 있는것 같습니다.\n\nA1)\n\n흠.. 굳이 헬퍼함수를 useCart가 반환할 필요가 있을까요!?\n아예 `cartUtils` 라는 이름으로 네임스페이스를 하나 구성하고, 해당 유틸함수 하위에 함수를 묶어두면 어떨까 싶어요.\n\ncartUtils.getItemTotal\ncartUtils.getItemDiscountRate\n\n요로코롬 사용할 수 있도록!\n\n---\n\nQ2) 모델 함수의 위치\n\ngetMaxProductDiscountRate를 models/discount.ts에 넣었는데, 이게 models/product.ts에 있어야 하는지 고민됩니다.\nEntity 간 경계가 모호할 때 어떻게 분리하는 것이 좋은지 궁금합니다.\n\nA2)\n\n흠.. 저는 product가 더 적합하지 않나!? 라는 생각입니다 ㅎㅎ\n인자를 잘 보면 결국 product의 discount에서 가져오는거라, discount 자체가 product의 하위 가지라고 생각해요.\n\nmodels/product/discount 처럼 계층을 구성하는 방법도 있겠네요!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/11"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "안녕하세요 수빈님! 과제를 다 수행하기에는 시간이 많이 부족했군요 ㅠㅠ\n8주차 과제는 부디 잘 수행할 수 있기를 바랍니다!\n고생하셨어요~!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/28"
    }
  },
  {
    "passed": true,
    "name": "안소은",
    "feedback": "고생하셨습니다 소은님~\n과제도 잘 진행해주셨고 회고도 아주 꼼꼼히 잘 정리해주셨네요.\n적용해주신 패턴도 합리적인 이유로 잘 선택해주셨고 접근 방식도 좋았던 것 같아요 ㅎㅎ 명확하게 각 패턴들의 장단점을 이해하고 사용하려고 하시는 부분도 좋네요\n\n> 멀티패러다임 프로그래밍의 적절성\n\n예를 들어 계산 로직은 순수 함수로, 엔티티의 동작은 인스턴스 메서드로 분리한 것이 가독성 측면에서 적절한 선택이었는지 의견이 궁금합니다.\n-> 좋은 고민인데요..!  넵 좋은 방향이였다고 생각해요 ㅎㅎ 말씀대로 개발자 입장에서는 쓰기 좋은 방향인데, 훅이 너무 거대해진다는 단점이 생기는것 같아요. 이야기를 듣고 생각이 드는건 모델에 액션이 묶여있는 그 Rich Domain Model과 유사한데, 일반적으로는 데이터와 액션을 분리해서 관리하는걸 선호하는 것 같아요. (마치 리덕스처럼요) 훅이 너무 거대해진다면, 데이터와 업데이트 로직(행위)를 분리해서 관리하는것도 좋을 것 같아요!\n\n(저는 지금은 별로 거대하고 복잡하게 느껴지진 않는것 같아요 ㅋㅋ)\n\n> Hook 분리 기준\n\n넵 저도 동일한데요. 이 부분은 데이터 변환 로직이다보니.. 너무 과하게 분리되면 로직을 파악하게 어려울 수 있어서 적절한 기준을 만드는게 좋은 것 같아요. 너무 과도하게 복잡한 로직들은 분리하고, 컴포넌트 내부에 유지를 하는게 좋지 않을까 라고 생각이듭니다.\n\n고생하셨고 담주도 화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/22"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/16"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "진성님 수고하셨습니다.\n\n- Store 분리 기준\n네 저는 현재 과제 상황에서는 무난하다고 생각합니다.\n확장성을 생각한다면 분리해두는 것이 더 나은 선택이긴 한데요.\n그건 먼 미래의 확장성을 \"예상\"하는 것이고 과제와 같이 예상이 아니라 확정인 상황에서는 \n묶는 것도 나쁘지 않다고 생각합니다.\n\n그리고 결국 순환 참조를 예방하는 방법을 단방형성의 참조를 유지하기 위한\n적절한 레이어 구분과 그 일관성을 철저히 지키는 수밖에 없을 것 같아요.\n예를들어 UI상태 -> 비지니스 상태 -> 데이터 상태  이렇게 알관성있는 참조구조.\n\n*  순수 함수의 trade-off\n순수함수를 유지하면 좋지만 추상화 래밸이 높아질수록 결국 사이드 이펙트를 활용할 수 밖에 없어요.\n그래서 결국 계산만 하는 순수함수와 사이드 이팩트를 활용하는 함수의 레이어를 의도를 가지고 명확히 구분하면 될 것 같습니다.\n아주 간단히 예를들면 calculateItemTotal(순수함수)와 스토어를 활용해 카트의 토탈을 계산하는 getCartTotal 이란 함수를 만드는 거죠.\n\n\n- 상태 관리 도구 선택에 대한 고민 Zustand는 어느 지점에서 필요한가?\n\n무엇을, 어떻게, 언제까지 만들어야하는 것부터 검토가 필요할 것 같아요.\n만들어야할 어플리케이션의 규모를 파악하고 어플리케이션에 필요한 상태들에 대해서 미리 정의를 해둔 다음에 그다음 상태관리 도구를 선택할 수 있을 것 같습니다.\n\n저는 뭐 jotai나 zustand나 역할면에서는 큰 차이가 없다고 생각합니다. 그래서 그냥 상태관리 도구라고 퉁칠게요.\n\n어플리케이션에서 공유되는 상태가 단순하고 거의 바뀌지 않느 상태라면 Context API로 충분히 만들 수 있을 것 같고\n그렇지 않으면 상태관리 도구를 고려할 것 같습니다.\n\njotai냐 zustand냐의 문제는 그냥 취향이나 익숙함의 차이인 것 같아요 :) \n\n수고하셨습니다.",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/12"
    }
  },
  {
    "passed": false,
    "name": "오새듬",
    "feedback": "안녕하세요 새듬님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 다만 심화과제는 시간이 많이 부족했던 것 같군요 ㅠㅠ\n\n궁금한점 있으면 언제든 디스코드를 통해 문의주세요!\n피드백은 바로 마무리하겠습니다~",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/36"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "안녕하세요 지훈님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\nQ)\n리팩토링을 할 떄 순서를\n\n1. 페이지 단위\n2. 컴포넌트 분리 (순수UI -> 조합 컴포넌트(?))\n3. 기능 분리 (hook, entities, utils)\n\n이 순서로 진행했는데, 페이지 단위부터해서 그런지 props가 정말 많아진 것 같네요..(의도치 않게 과제 의도에 부합해버린 ^^..)\n혹시 UI부터 시작해서 마지막을 페이지 분리로 갔어야 리팩토링 과정이 덜 번잡했을까요??\n\nA)\n음.. 뭔가 정해진 순서가 꼭 있나? 라는 생각이 들긴해요 ㅎㅎ\n어떤 상황에서는 Top-down 으로 지금처럼 리팩토링하는게 더 유리할 수 있고,\nTop-down 으로 하기 어려운 상황, 가령 너무 복잡하고 거대한 코드를 리팩토링 할 때에는 bottom-up 으로 차근차근 올라가야 수월할 수도 있죠.\n\n복잡도에 따라 다르다고 생각합니다!\n\n다만 제가 과제를 수행한다고 생각했을 때,\n저는 state 하나를 시작으로 분리했을 것 같아요.\n\n가령 App.tsx에 products라는 상태가 있고, 이 products를 사용하는 함수들이 존재합니다.\n\n일단 이렇게 시작하는거죠.\n\n```tsx\nconst useProducts = () => {\n  const [products, setProducts] = const [products, setProducts] = useState<ProductWithUI[]>(() => {\n    const saved = localStorage.getItem('products');\n    if (saved) {\n      try {\n        return JSON.parse(saved);\n      } catch {\n        return initialProducts;\n      }\n    }\n    return initialProducts;\n  });\n}\n```\n\n그리고 App.tsx 에서 products를 제거합니다. 그러면 여기저기서 빨간줄이 생기겠죠!? 빨간줄이 생기는부분을 다시 useProducts로 옮겨오고\n이 때 모든 코드를 그대로 옮겨올 것인가, 혹은 hooks의 인자로 둘 것인가에 대한 판단이 필요해요\n\n가령, 이렇게요!\n\n### as-is\n```tsx\nconst addProduct = useCallback((newProduct: Omit<ProductWithUI, 'id'>) => {\n  const product: ProductWithUI = {\n    ...newProduct,\n    id: `p${Date.now()}`\n  };\n  setProducts(prev => [...prev, product]);\n  addNotification('상품이 추가되었습니다.', 'success');\n}, [addNotification]);\n```\n\naddNotification 이라는 함수를 App.tsx 에서는 그대로 사용하고 있어요. 그런데 저는 그렇게 하고 싶지 않아서 아래처럼 분리한답니다.\n\n\n### to-be\n```tsx\nconst useProducts = ({ onSuccess }) => {\n\tconst [products, setProducts] = const [products, setProducts] = useState<ProductWithUI[]>(() => { ... });\n\n\tconst addProduct = useCallback((newProduct: Omit<ProductWithUI, 'id'>) => {\n\t  const product: ProductWithUI = {\n\t    ...newProduct,\n\t    id: `p${Date.now()}`\n\t  };\n\t  setProducts(prev => [...prev, product]);\n\t  onSuccess('상품이 추가되었습니다.');\n\t}, [addNotification]);\t\n}\n```\n\n이렇게 hooks 의 인자로 onSuccess 를 받아와서 사용하는거죠.\nuseProducts는 이렇게 정의할 수 있겠죠?\n\n이런 과정을 거치면 관심사를 쉽게 분리할 수 있게 된답니다!\n관심사의 분리는 보통 data를 중심으로 발생하니까요 ㅎㅎ\n\ndata를 CRUD 하는 영역과 (hook)\ndata를 사용하는 영역 (ui)\n\n요로코롬 분리되는거죠.\n\n그리고 CRUD는 액션에 해당하고, CRUD에 필요한 정제는 계산에 해당하겠죠?",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/13"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "안녕하세요 윤지님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\n> 코치님만의 커스텀 훅 분리 기준이 있으신가요?!\n\n컴포넌트가 \"UI\"와 관련된 상태를 들고 있는게 아니라면, 대체로 커스텀 훅으로 분리하는 편이랍니다 ㅎㅎ\n\n저는 컴포넌트의 관심사는 \"데이터의 조작\"이 아니라고 생각해요.\n컴포넌트에게는 \"만들어진 데이터\"를 보여주는 것이 제일 중요합니다.\n\n데이터를 조작하는 모든 과정은 사실 컴포넌트 입장에서는 \"알빠?\" 인거죠 ㅋㅋ\n\n그래서 컴포넌트 내부의 다양한 로직을 아예 통째로 Custom Hook 으로 분리하는 편입니다.\n그리고 Custom Hook 에 대해 테스트를 작성하는거죠.\n\n그 다음에 hook의 계층을 정렬하는 편입니다.\n\nhttps://junilhwang.github.io/TIL/clean-code/%EC%A1%B0%EA%B0%81%EB%AA%A8%EC%9D%8C/%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/\n\n단어와 단어를 뭉쳐서 문장을 만들고\n문장과 문장을 뭉쳐서 문단을 만드는 것 처럼\n\n커스텀훅 하나하나를 하나의 \"문장\" 이라고 생각하는거죠.\n문장의 역할을 하는 커스텀훅들을 모아모아 문단의 역할을 커스텀훅을 만들어서 사용하는 방식입니다.\n\n여튼, 커스텀훅이 FE 개발의 패러다임을 바꾼 혁명(?)에 가까워서 잘 활용해보시면 좋겠어요!\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/2"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "정민님 수고하셨습니다.\n\n- 액션 분리의 적정 수준은?\n실용적인 기준이라고 한다면 어플리케이션이나 모듈을 역할 별로 추상화해서 레이어를 구분해 미리 정의하고 일관성을 유지하는 것일 것 같습니다.\n그래서 개발할때 이레이어는 순수함수로 구현하고 상위 레이어는 액션으로 사이드이팩트를 허용하고 의존관계는 이렇고를 미리 정의해두고 그 기준에 맞게 일관성을 유지하는 것이죠.\n그 기준은 프로젝트마다 달랐던 것 같습니다.\n사실 순수함수과 사이드이팩 분리할줄만 하는 것으로 충분하다고 생각합니다.\n순수함수는 순수함수대로 유지하고 액션은 액션대로 일관성만 유지된다면\n그 이후에는 재사용성이 필요하냐 아니냐로 분리의 여부를 따지면 될 것 같아요.\n\n* Props Drilling 해결 방법\n공유되는 거의 바뀌지 않고 영향범위가 넓은 상태라면 Context API를 사용합니다. 예를들어 테마나 설정 정보같은 것들이요..\n그렇지 않은 경우 상태관리 도구를 활요해 도메인 별로 분리해서 사용할 수 있을 것 같습니다.\n\n* 테스트 전략\n이렇게 단순하게는  뭐가 맞다 판단하기 힘들 것 같아요. ㅜㅜ\n제일 중요한건 어플리케이션을 적절한 레이어로 구분하는 것이에요.(FE는 디렉토리 구조에서 레이어가 얼추 나오죠.)\n그리고 그 레이어별로  테스트 전략을 만드는 거죠. 어떤 레이어는 테스트를 안할 수도 있어요.\n예를들어 이 레이어는  로직이랄게 없고 단순하게 계산된 값을 받아서 사이드 이펙트만 만드는 레이어다. 라고하면 테스트를 안하기로 전략을 짜는거죠.\n사실 테스트는 무엇을 테스트할까보다도 일단 100% 테스트는 하는 건데 어떤 것을 테스트 하지 않을 것이고 왜 테스트가 이 레이어에 효과가 없는 것인지를 정의하는 것이 중요한 것 같습니다. 즉 테스트 하지 않을 영역을 아주 얇게 발라내는 작업이 중요합니다. 그러면서 구조도 탄탄해지죠.",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "안녕하세요 현지님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\n> 왜 다들 작업을 작은 단위부터 하는지, 혹은 state 부터 분리를 하게되는지 알게 된 것 같습니다!\n\n핵심을 잘 짚어주신 것 같아요! 저의 경우 state와 이를 사용하는 코드를 hook으로 분리하고, 다시 hook에서 순수한 계산 로직을 별도의 함수로 분리해서 관리하는 편입니다 ㅎㅎ\n\n이렇게 점진적으로 분리하다보면 생각보다 리팩토링이 수월하답니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/27"
    }
  },
  {
    "passed": false,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/15"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "희재님 수고하셨습니다.\n\n* models 디렉토리 내에서 calculator, validator, updater 등으로 파일을 잘게 쪼개는 방식이 일반적인지, 아니면 도메인 모델 단위로 하나의 파일에 모으는 것이 더 나은지 궁금합니다\n일단 지금 희재님이 나눈 방식이 저는 나쁘지 않다고 생각합니다. 슬라이스의 역할을 적절히 추상화하신 것 같아요.\nFSD도 사실 FSD를 마치 헌법처럼 그대로 차용하는 것보다 레이어를 어떻게 다루는가 그리고 각 레이어의 세그먼트와 같은 좋은 컨셉들을 어떻게 잘 활용할 것인가가 더 중요한것 같아요.\nFSD도 회의적인 의견이 많으니까요. 좋은 컨셉만 뽑아서 나에게 혹은 우리팀에 혹은 이 프로젝트에 현실적으로 효율적으로,  효과적으로 활용하는 것이죠.\n전 적절하다고 생각합니다. 중요한건 의도와 일관성인 것 같습니다 :)\n\n* onSuccess/onError 패턴을 사용해 제어권을 위임하는 방식이 리액트 생태계에서 권장되는 패턴인지, 더 나은 대안이 있을지 피드백 부탁드립니다.\n넵 이건 아주 넓게 사용되는 방법이고 리액트뿐만아니라 많은 라이브러리에서도 활용되고 있습니다. 콜백을 활용한 디커플링의 일반적인 응용이죠.\n이벤트 핸들러도 동일한 위임입니다. 비동기라면 promise를 활용해도 될 것 같고요.\nthrow를 예외를 발생시킬 수도 있고, 둘다 지원하는 경우도 있습니다.\n방법 넘어 특정 모듈의 예외를 외부로 위임하는 것이 옳으냐라고 묻는다면, 위임은 반드시 필요한 부분인 것 같아요.\n내부에서도 처리할 것이 있다면 처리하고 외부에서도 처리할 것을 처리하라고 알려주는 것이죠.\n\n근데 해당 로직들을 살펴보니 조금 과하다는 생각도 들어요.\n예를들어 removeFromCart같은 경우는 return 값이 true, false면 될 것 같기도 합니다.\n이런 예외 처리는 결괏값 or  예외 이거든요.\n예를들면 단순히 두 인자를 받아서 더해주는 함수라고 본다면\n결과를 합산해서 리턴하던가 혹은 인자중에 문자가 있다던지 계산을 할 수 없는 경우에는 예외를 던지거나 이런거죠.\nremoveFromCart의 경우는 결괏값으로 봐야할 것을 예외처리로 한 것 같아욥.\n\n다만 저 레이어는 모종의 이유로 저런 인터페이스로 추상화 할 것이다라는 약속이 있다면 그렇게 해도 될 것 같습니다 :) \n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/7"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "수고하셨습니다 나리님.\n\n- Jotai Derived Atom 성능\n매번 실행되는 로직에는 derived atom을 사용하는 것이 의존되는 atom이 변경될 때만 재계산하기 때문에 성능적으로 나은 것으로 알고 있습니다.\n제가 jotai를 예전에 한번보고 실무에서는 사용을 해본적이 없는데요 의도한 질문이 이게 맞는지 모르겠네요.\n\n* Service 레이어의 순수함수들이 많아지면서, 함수 간의 의존성 관리가 복잡해질 수 있습니다. 예를 들어 calculateItemTotal이 getMaxApplicableDiscount를 사용하는데, 이런 의존성을 어떻게 관리하는 것이 좋을까요?\n\n제가 질문의 의도를 파악하지 못했습니다. 지금 동일 파일에 있는 calculateItemTotal이 getMaxApplicableDiscount를 의존하는 것에 어떤 문제가 있는 것일까욥?\n의존성이 복잡하다라고 느껴지는 포인트를 제가 이해하지 못한 것 같습니다 :)\n함수가 많아진 부분이라면 이건 반대로 역할별로 함수를 잘 분리했다고도 할 수 있을 것 같아요.\n\n* 엔티티 컴포넌트와 UI 컴포넌트의 경계를 정하는 기준이 때로는 모호합니다. 예를 들어 CartItemComponent는 엔티티 컴포넌트인데, 내부에 Button, DeleteButton 같은 UI 컴포넌트를 사용하고 있습니다. 이런 구조가 적절한지, 아니면 더 분리할 수 있는지 궁금합니다.\n그 기준이 모호한 점이 FSD의 단점입니다 :) \n그래서 이게 feature야 entity야 같은 것의 구분을 명확하는 것에 집중하기보다는 레이어간의 의존 구조와 각 세그먼트의 역할을 일관성있게 유지하는 것이 중요합니다 :)\n저도 명확히 구분하지 않습니다. 애초에 FSD의 레이어 구분은 모든 어플리케이션에 맞출려고 과하게 일반화해서 그냥 우리 프로젝트에 맞게 레이어를 새로 만들거나 축소하는 것이 좋은 것 같습니다.\n\n- 훅 간 의존성을 갖게 될 때에는 어떻게 해야 할까요?\n훅사이에 의존성은 늘 있습니다. 이게 문제는 아닌 것 같아욥 다만 방향에 일관성만 있으면 좋을 것 같습니다.\n의존을 DI형식으로 주입한다는 것은 결국 디펜던시를 주입하는 \"구조\"로 만든 다는 것인데요.\n이렇게 하는 이유는 인터페이스를 유지한채로 훅을 교체하는 구조가 필요한 상황이라면 그렇게 해도 됩니다.\n사실 크게 보면 이런 의존성을 주입하는 구조가 좀 더 유연한 것은 맞는데요.\n모듈이 그런구조가 필요하지 않는데 주입하는 구조로 가는건 과할 수도 있을 것 같습니다.\n왜냐면 DI가 의존성 디커플링에 좋다라는 이유로 주입할거면 모든 코드에서 의존성을 주입하는 구조로 가야 하는 것이 맞으니까요.\n주입이 필요하다는 건 결국 의존성을 변경해 재사용하는 상황이 있는가, 즉 이런 확장 방식이 필요한가를 잘 생각해보셔야할 것 같습니다.\n예를들면 우리의 이밴트 핸들러도 사실 근본적으로 동일해요.\n어떤 버튼 클릭했을때 한가지 기능만 한다면 사실 콜백으로 핸들러라는 의존성을 주입할 필요가 없죵.\n그냥 그기능을 내부에서 구현하면 되니까요. 그런데 우리는 클릭했을때의 동작을 변경할 수 있는 \"의도\"를 가지고 의존성을 콜백이라는 이름으로 만든 것이죵.\n\n제가 잠을 제대로 못자서 설명이 제대로 됐는지 모르겠네요.\n아무튼 나중에라도 혹시 좀 더 이야기해보고 싶으시면 말씀해주세욥.\n\n수고하셨습니다.\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/9"
    }
  },
  {
    "passed": true,
    "name": "정한슬",
    "feedback": "한슬님 과제 잘 해주셨네요 ㅎㅎ\n이번 기회로 전역상태 라이브러리를 활용하면 어떻게 편리하게 개발할 수 있는지 그리고 그 기준을 어떻게 잡을지 잘 느낄수 있었던 과제였던것 같네요 :+1\n계층도 잘 나눠주신것 같고, 이 계층을 나누는데 있어서 단일 방향으로 의존성 방향을 정해서 누릴 수 있는 장점들에 대해 잘 고민해보셨으면 좋겠네요! (아마 이번 주 과제에서 계속 느끼시겠죠?\n\n> localStorage 관련 질문\n\n일단 테스트를 통과하기 위해 실제 코드를 넣는 경우는 사실 현업에서는 하지 않는 방식이니 다른 방법을 찾아야 할 것 같은데요.\n\n음.. 제가 직접 디버깅을 해드리기엔 조금 어려울 것 같은데 말씀해주신 부분이라면\nhttps://zustand.docs.pmnd.rs/guides/testing\nzustand같은 라이브러리를 사용하다 보면 상태를 리셋해주는 여러 세팅들을 해주는게 필요할 수 있어요! 테스트 간 상태를 넘나들 수 있는거죠.\n이런 부분을 참고해서 한번 작성해보시면 좋지 않을까! 싶습니다\n\n> Props 드릴링 관련 질문\n\n저는 개인적으로 전역 상태를 쓰더라도 상태를 사용하는 컴포넌트에 가까이 두고 여러곳에서 사용할 경우 점점 끌어올리다 전역 상태로 이동하는 편인데요. 굳이 우리가 드릴링을 하지 않아야된다! 라는 관점으로 상태를 보기보다는 이 상태, 논리에 대한 뭉치가 데이터 흐름 관점에서 사용되는 쪽에 가깝게 위치하는지, 함께 잘 뭉쳐있는지 부터 고민을 하는게 좋은 것 같아요!\n\n고생하셨고 다음 주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/38"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "안녕하세요 민수님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\nQ)\n기본과제를 진행하면서 useValidate에 해당하는 훅은 전역상태관리 없이는 구현이 큰 의미가 없을 것 같아 넘어갔습니다. (노티피케이션 관련해서 프롭스로 전달하며 사용하고 싶지 않았습니다.) 이후 심화과제를 진행할 때 useValidate 훅을 넣는 것을 고려해 보았는데, 쿠폰폼이나 프로덕트 폼의 검증은 결국 다른 엔티티를 대상으로 하고 있어, 엔티티를 업데이트 하는 훅을 전달하는 방향으로 구현해야 될 것 같은 느낌이라 결국 컴포넌트 안에서 직접 검증을 진행하는것이 더 효과적이지 않나? 싶은 생각이 들어 구현하지 않게 되었습니다.\n\nuseValidate가 사용된다면 어떤 형태로 구현되고, 사용될 수 있을지 궁금합니다.\n\n\nA)\n흠.. 꼭 구현해야 할까요? 지금처럼 진행해도 무방하다고 생각합니다 ㅎㅎ\n다만 꼭 구현을 해야 한다면,\n\n이렇게 쓰이는 모습을 상상해보시면 좋을 것 같아요\n\n```tsx\nconst [formData, setFormData] = useState({ key1: ..., key2: ..., key3: ... })\n\nuseValidate(formData, {\n\trules: {\n\t\tkey1: () => { ... },\n\t\tkey2: () => { ... },\n\t\tkey3: () => { ... },\n\t},\n\tonError: () => { ... }\n})\n```\n\nformData에 대한 검증 규칙을 훅 외부에서 정의하고, 훅 내부에서는 규칙을 검사하는 코드를 작성하고, 규칙에 위배될 때 onError 를 통해 추가 동작을 유도하는거죠 ㅎㅎ\n\n다만 꼭 이렇게 작성할 필요는 없다고 생각해요.\nreact-hook-form 같은 것들을 참고해보시면 좋답니다!\n\n\n",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/25"
    }
  },
  {
    "passed": true,
    "name": "진재윤",
    "feedback": "안녕하세요 재윤\t님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\n> Toast나 Cart처럼 앱 전체에서 접근해야 하는 건 Zustand로, searchTerm 처럼 특정 페이지 안에서만 의미 있는 건 Props로 유지했는데, 검색어는 HeaderWidget에서 입력하고 ShopPage 안의 ProductListWidget에서 사용하는데 둘이 직접 데이터를 주고받을 수 없으니까, 공통으로 감싸는 App에서 searchTerm 상태를 관리하고 각각에 Props로 내려주는 방식을 썼는데 Props와 전역상태관리 중 어떤게 더 좋은 선택일까요?\n\n저는 이렇게 구분하는 편입니다!\n\n1. 도메인 데이터와 관련 있다 -> Zustand 같은 상태관리 라이브러리를 통해 사용\n2. UI 와 관련 있는데, 스코프가 넓다 -> Context 를 이용하여 UI 데이터가 쓰이는 영역을 지정\n\n가령 Toast는 도메인과는 연관 없기 때문에 Context/Provider 를 통해 구성하고\nProduct의 경우 도메인과 관련있기 때문에 Zustand를 통해 구성하는거죠.\n\nsearchTerm의 경우에는 \"검색어\" 라는 키워드 하나만 놓고 보면 Zustand 일 수 있지만..\n보통 검색어의 경우 queryParams 를 통해 관리하는 편입니다 ㅎㅎ 주소에 동기화 시키는거죠.\n새로고침 했을 때에도 유지할 수 있고!?\n\n> Header 를 widgets 으로 분류 했는데, 최상위 조립 레이어로 보고 App Layer로 만드는게 더 좋은 선택이였을까요? 레이어 계층 구조가 화살표 순서가 아니고 의존 가능 방향이지만 그래도 Pages Layer와 Widgets Layer 로 같이 App.tsx 에 존재하는데 App Layer 로 분류했으면 이질감이 안들었을까 라고 회고 하면서 생각이 들었습니다.\n\nwidgets이 더 적합하다고 생각해요!\napp layer는 보통 어플리케이션의 설정과 관련 있는 것들을 위치하는 경우가 많았던 것 같아요 ㅎㅎ",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/21"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/5"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "고생하셨습니다 선민님! \n과제 잘 진행해주셨네요ㅎㅎㅎㅎ\n항해 끝나고의 스트레스를 벌써 엄청 받으시는것 같은데 ㅋㅋㅋㅋ너무 걱정마시고 키워드위주랑 짧게 한두문장만 남겨두고 천천히 공부하세요\n절대적인 키워드 양이 많더라도 막상 공부를 하다보면 크게 어려운 내용이 아닌 경우도 많고 결국 중요한건 깊게 들어가는 거더라구요. \n계층 구조나 방향성도 잘 정의 해주신 것 같고 약간의 AI의 도움이 있었던 것 같지만 회고 정리도 잘 해주신것 같아요 (불필요한 부분은 지워줘도 괜찮지 않았을까..!)\n\n\n> 1. 훅의 의존성 주입 방식\n\n나쁘진 않은데요!\nhttps://zustand.docs.pmnd.rs/guides/slices-pattern\n요 슬라이스 패턴 한번 사용해보세요!\ngetState로 할 경우 해당 스토어에 의존이 생기니 이 패턴을 검토해보고 아니면... 그냥 컴포넌트에서 상태를 전달받아 넘겨주는 형태로 구현을 하는게 결합도를 낮추는 방향이라고 생각됩니당\n\n> 2. Compound Components vs 심플한 Props 분기\n\n넵 합리적인 생각입니다 ㅎㅎ\n과한 복잡성이 없고, UI에 자유성을 부여한다거나 상태를 내부에 유지할 필요가 없고, 하위 컴포넌트에 대한 제한도 정해져있으니 분기로 처리하는게 좋은 방향일수도 있어요.\n대신 다양한 곳에서 사용이 되고 UI의 모든 분기를 한 컴포넌트에 처리하기 힘들다면 그때 합성 컴포넌트 패턴을 고려해보세요!\n\n> 3. 전역 상태 범위 결정 기준\n\n가능하면 컴포넌트 내부에 상태를 유지해보고, 여러 컴포넌트에서 이 사용이 되면서 점점 상태가 끌어올려지고 props 드릴링이 발생하는 거니, 해당 증상이 발현될 때 전역 상태로 옮겨야겠다라고 고려해보세요! \n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/20"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "안녕하세요 세준님! 7주차 과제 잘 진행해주셨네요. 고생하셨습니다~!!\n\nQ)\n도메인 모델 + 상태(useCart) 내부에서 에러를 throw하는 방식이 적절한지에 대한 고민이 있습니다.\n현재 validateAddToCart에서 재고 부족 시 throw new Error()로 검증 실패를 표현하고 있고, 해당 에러는 상위 Feature 레이어에서 catch하여 UI 피드백(토스트 등)으로 처리하고 있습니다.\n\n하지만 다음과 같은 이유 때문에 이 방식은 올바르지 않은 설계라는 생각이 듭니다.\n\n- 엔티티/도메인 계층은 순수성과 사이드 이펙트가 없어야한다.\n- 에러를 던지는 행위 자체가 사이드 이펙트다.\n- 그렇다면 검증 자체를 features에서 수행해야하는가?\n\n\n궁금한 점\n\n- 검증 로직이 상위 레이어에서 수행하는 것이 적절한지?\n- 혹은 Result/Either와 같은 패턴으로 검증 실패를 도메인이 표현하고 상위 레이어에서 UI 피드백을 처리할지?\n\nA)\nthrow를 하는 부분은 크게 문제되지 않는다고 생각해요 ㅎㅎ 사이드 이펙트라고 보기도 어렵지 않나!? 라는 생각입니다.\n사이드 이펙트라는건 시간의 흐름에 따라 달라지는 함수인데, throw가 있다고 해서 input/output에 대한 일관성이 깨지는건 아니라서요!\n\n혹은 제안해주신 \"혹은 Result/Either와 같은 패턴으로 검증 실패를 도메인이 표현하고 상위 레이어에서 UI 피드백을 처리할지?\" 처럼 진행해도 좋다고 생각합니다.\n\n검증하는 구간은 사실 팀 내의 규칙이 제일 중요하다고 생각해요.\n가령, 지금은 addToCart 에서 진행하고 있는데,\nUI에서 버튼을 클릭하는 시점에 혹은 수량을 조절하는 시점에 이미 오류 여부를 알 수 있다고 생각해요.\n그런데 꼭 해당 레이어에서 진행할 필요는 없죠.\n\n가령, 백엔드에게 일괄 위임해도 되고\n혹은 API를 전송하는 시점에 체크할 수도 있고!?\n\n어디가 좋은지는 상황에 따라 다르기 때문에 의사결정이 필요한 부분이라고 생각합니다 ㅎㅎ\n\n단순히 이 코드가 좋다/나쁘다의 기준이 아니라 \"이 코드가 어떻게 쓰이는가\"에 대한 맥락이 필요한거죠.\n\n진리의 케바케... 랄까... 그렇네요 ㅋㅋ",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/14"
    }
  },
  {
    "passed": false,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/6"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "안녕하세요 준태님! 7주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!\n\nQ)\nHeader처럼 앱 내 특정 상태에 대해 접근하는 경우가 빈번한 컴포넌트는 Props 주입과 전역 상태 직접 접근 중 어떤 것이 더 적절한가요? 만약 상황에 따라 다르다면 그 기준이 무엇인지 궁금합니다.\n\nA)\n저는 전역상태가 아니라 컨텍스트를 통해 관리하면 어떨까? 라는 생각입니다 ㅎㅎ\n\n\"전역상태관리\"의 핵심은 \"전역\"이 아니라 \"상태관리\" 라고 생각해요.\n여기서 이야기하는 상태관리는 \"도메인 데이터 자체와 도메인을 다루는 로직\"의 뭉치라고 생각합니다.\n도메인 데이터는 영역과 상관없이 어디에서든 쓰일 수 있어요. 그렇기 때문에 \"전역\"으로 관리할 필요가 있는거죠.\n그리고 모든 내용이 다 쓰이는게 아니라 일부 내용만 쓰일 수도 있습니다. 그래서 selector 같은걸 이용하여 일부 데이터를 가져오고, 이에 대한 렌더링만 유발되도록 만드는거죠.\n\nContext는 도메인과는 조금 다르다고 생각합니다. 특정 스코프에 필요한 데이터를 다룰 때 유용한 도구인거죠. 꼭 전역일 필요도 없어요.\n그래서 \"어플리케이션의 설정\" 과 같은 것들은 Context를 통해 관리해야 역할에 조금 더 적합하지 않나!? 라는 생각입니다 ㅎㅎ\n대체로 UI와 관련된 상태들이 많아요.\n\n---\n\nQ)\n저는 현재 인플루언서 마케팅 도메인의 회사에서 웹 서비스를 개발 및 운영 중입니다. 유저(광고주)가 광고 캠페인을 오픈하려면 다양한 정보의 Form을 작성해야하는데요. 이 때, 특정 form에서 어떠한 값을 선택하는지에 따라 입력 받는 form의 UI와 데이터가 조금씩 달라집니다.\n예컨대, platform으로 인스타그램을 선택하는 경우 팔로워수와 좋아요수를 받아야 하고, 유튜브를 선택하는 경우에는 구독자 수를 받아야 합니다.\n위와 같은 상황에서 중복 코드를 감안하더라도 InstagramCampaignForm, YoutubeCampaignForm, BlogCampaignForm 등으로 분리하는게 좋을까요? 아니면 하나의 CampaignForm으로 관리하고 캠페인 내부에서 분기 처리를 통해 관리하는게 좋을까요?\n처음에는 후자로 구현했다가 기획도 자주 바뀌고 로직도 복잡해져서 전자로 리팩토링했는데, 관리해야하는 컴포넌트가 많아지다보니 다시 전자로 돌아가고 싶은 고민이 듭니다ㅠ\n\nA)\nForm에서 어떤 데이터를 다루냐가 중요할 것 같은데요,\n이럴 때 사용하면 좋은게 Compound Component 라고 생각해요 ㅎㅎ\nCampaignForm의 공통 부분을 재활용할 수 있는 요소로 분리하고\n조금씩 조금씩 다른 부분을 InstagramCampaignForm, YoutubeCampaignForm, BlogCampaignForm 컴포넌트 하위에서 정의하는거죠.\n\n근데 코드 없이 상황을 통해서만 이야기 하는건 사실 큰 효과가 없는 것 같네요..\n복잡도가 높다면 분리하는게 맞고\n복잡도함 속에서 추상화를 찾을 수 있다면 공통로직으로 분리해야 하는데\n이 추상화 로직이 복잡하다면 사실상 분리하는 것만 못한 일이 발생하니까요.",
    "assignment": {
      "name": "STEP14 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-2/pull/8"
    }
  },
  {
    "passed": true,
    "name": "강승훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/44"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/16"
    }
  },
  {
    "passed": true,
    "name": "곽정원",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/joshuayeyo/hh-week8"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/30"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/25"
    }
  },
  {
    "passed": false,
    "name": "김도현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/27"
    }
  },
  {
    "passed": true,
    "name": "김민지",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/9"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/33"
    }
  },
  {
    "passed": true,
    "name": "김우정",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/23"
    }
  },
  {
    "passed": true,
    "name": "김준모",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/42"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/5"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/10"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "노유리",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/8"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박수범",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/43"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/19"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/11"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/2"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/24"
    }
  },
  {
    "passed": false,
    "name": "안소은",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/31"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/29"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/35"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/17"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/12"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/6"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/39"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/36"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/21"
    }
  },
  {
    "passed": true,
    "name": "한선민",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/26"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "",
    "assignment": {
      "name": "STEP15 프론트엔드 아키텍처 설계 및 디자인 시스템 기본과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/22"
    }
  },
  {
    "passed": false,
    "name": "강승훈",
    "feedback": "승훈님 수고 많으셨습니다!\n지금 토요일 오전에 채점중인데요.\n과제 셀프회고 내용이 거의 없네욥.\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!\n\n수고하셨습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/44"
    }
  },
  {
    "passed": true,
    "name": "고다솜",
    "feedback": "다솜님 수고하셨습니다.\n\nQ. 여러 도메인의 API 응답을 결합하여 가공한 쿼리는 FSD에서 어떤 레이어에 두는 것이 적절할까요?\n\nentities의 API를 결합한 쿼리는 features/post/api에 둘 것 같아요. 내부에서 가공하는 로직이 분리되거나 재사용될 수 있다면 model에 두고 사용할 수도 있을 것 같고요.\n말씀하신대로 features 레이어는 하위 레이어인 엔터티를 소비하며 비즈니스 기능을 조합하는 역할을 할 수 있기 때문에 적합해 보입니다.\nFSD는 각 레이어의 의미보다 수직적 의존성 혹은 의존 방향의 일관성이 더 중요한 것 같습니다.\n필요한 경우 레이어는 커스텀할 수 있는 부분이라고 생각합니다 :)\n\nQ. 소규모 프로젝트에서는 Query Key를 중앙에서 관리하는 방식이 더 적합할까요, 아니면 도메인별로 분산하여 관리하는 방식이 더 바람직할까요?\n\n말씀하신대로 필요한것은 가까이두는 것이 FSD의 기본적인 철학에 맞는 것 같아요\n그러므로 각 레이어에서 가지고 있는 것이 맞는 것 같아요.\n\n다만 중앙화냐 분산화냐 보다도\n기본적으로 분산해서 가져가되 왜 중앙화를 해야하는가 이유가 중요할 것 같아요.\n코드래밸에서의 일관성을 꼭 중앙화해야만 유지할 수 있는 것은 아닐 것 같습니다.\n같이 일하는 사람들끼리 컨벤션으로 만들 수도 있을 것 같아요.\n전 이건 컨벤셔으로 충분히 커버할 수 있는 문제라고 생각합니다 :) \n\nQ. 프로젝트의 규모에 따라 FSD 구조를 어떻게 설계하고 결정하는 것이 좋을까요?\n\n소규모라면 차라리 세그먼트를 생략하고 그냥 레이어 밑에 features/post/AddForm.tsx 이렇게\n바로 사용하는 것은 저도 완전히 동의합니다.\n그러다가 필요에 의해 책임을 분리해야할 이유, 예를들어 재사용이 필요하거나 코드가 너무 길어졌거나 등등이 생기면 그때\n세그먼트로 분리할 수 있을 것 같습니다.\n필요한 경우 일관성을 위해 ui라는 세그먼트는 따로 폴더로 구분하지말고 각 슬라이스 루트를 사용한다라고 약속해도 될 것 같고요\n애초에 소규모건 대규모건 처음에 규모가 판단이 안될때도 이 전략은 유용할 것 같아요 :) 좋은 생각입니다.\nFSD를 온전히 그대로 사용하기보다는 커스텀하게 응용하는게 더 좋은 활용법일 것 같습니다.\n\n\nQ. FSD 구조에서 에러 핸들링 로직은 어떤 방식으로 계층화하고 분리하는 것이 좋을까요?\n\n말씀하신 반복적인 에러처리는 예를들어 뮤테이션의 경우 에러 메시지를 받아서 토스트를 띄우는 함수를 만들어서 재사용할 수 있을 것 같아요.\n\n그리고 네트워크에러는 중앙화가 가능하기때문에 한곳에서 처리하거나 fetch하는 모듈을 정의해서 그곳해서 처리하고 그것을 재사용하는 방법도 있고\n추가로 서버단과 약속한 에러타입에 대한 처리도 중앙화할 수 있을 것 같습니다.\n그리고 FSD에 적합한 패턴이라고 따로 없을 것 같아요  그저 중앙화된 처리는 말씀하신 대로 shared 하위에 둔다 정도 일 것 같습니다 :) \n\n그리고 React Query에서 중앙화된 에러처리는 QueryCache와 MutationCache를 자주 활용합니다 :)\n\n\n다솜님은 매 과제마다 아주 깊은 고찰을 하시는 것 같아요!\n너무 멋지고 좋은 자세라고 생각합니다.\n",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/16"
    }
  },
  {
    "passed": false,
    "name": "곽정원",
    "feedback": "잘했어요 죠슈아! 셀프회고가 깔끔하게 정리되어 있고, 특히 \"어디에 무엇을 넣어야 하는가\"를 표로 정리한 부분이 좋았어요. 이렇게 명세화할 수 있다는 건 구조를 제대로 이해했다는 뜻입니다.\n\n\"처음에는 features에서 fetch를 호출했는데, widgets와 중복되어 요청 충돌이 발생했습니다. 책임을 widgets로 단일화하니 깔끔해졌습니다.\"라고 쓴 부분도 좋은 경험이에요. 직접 부딪혀보고 해결책을 찾은 거니까요. 그리고 \"폴더를 보면 코드의 역할이 예측되는 구조가 좋은 구조\"라는 깨달음도 정확합니다. 이게 핵심이에요.\n\nQ) widgets에서 fetch orchestration을 담당하는 것이 FSD 원칙에 맞는 방식인지 궁금합니다.\n\n맞아요. widgets는 entities와 features를 조합해서 완성된 UI 블록을 만드는 레이어니까, 데이터를 가져와서 뿌려주는 역할을 하는 게 자연스럽습니다. 저는 비슷하게 entities는 서버 상태 관리, features는 클라이언트 상태 관리, widgets는 화면 단위로 나누고 있고 widgets에서 features에서 params을 가져오고 entities에서 useQuery를 사용해서 API를 사용하는 형태를 사용하고 있어요.\n\nQ) TanStack Query 도입 시 기존 Zustand store를 어떻게 함께 사용하면 좋을지 조언 부탁드립니다.\n\n서버에서 오는 데이터는 TanStack Query로, UI 상태(모달 열림/닫힘, 선택된 항목 등)는 Zustand로 나누면 돼요. \"새로고침하면 날아가도 되는가?\"로 판단하세요. 모달 상태는 날아가도 되니까 Zustand, 게시글 목록은 서버에서 다시 받아야 하니까 TanStack Query. 이렇게 나누면 각 도구가 자기 역할에 집중할 수 있어요. \n\n일단 API를 사용하나? 그러면 대부분의 경우 Tasntack으로 먼저 시작하면 좋습니다. \n\n수고많았습니다. FSD를 잘해야겠다보다는, 이 철학을 바탕으로 규칙을 설명할 수 있는 폴더 구조를 만드는 게 더 중요해요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외우거든요. 정원이가 정리한 표처럼 \"이건 여기에 둔다\"는 규칙이 일관되게 적용되면 그게 좋은 구조입니다.\n\n3챕터 동안 수고했어요. 이번 챕터를 지나오는 과정을 통해 코드를 설계하고 바라보는 시야가 더 선명해졌기를 바랍니다. 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/joshuayeyo/hh-week8"
    }
  },
  {
    "passed": false,
    "name": "권연욱",
    "feedback": "엇..연욱님 과제를 마무리 해주시지 못했군요.\n관련해서 FSD를 단순히 분류하기 보다는 과정을 진행하고 이를 왜 이렇게 분류했는지, 그리고 관련된 아키텍처들은 왜 이런 기준을 가졌는지 고민해보고 이야기 해보면 좋다고 생각합니다.\n너무 오랜 시간 뒤에 진행하기 보다는 꼭 진행하고 이야기 많이 나눠 보시면 좋겠어요!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/30"
    }
  },
  {
    "passed": false,
    "name": "권지현",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": false,
    "name": "김단헌",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "김대현",
    "feedback": "안녕하세요 대현님!\n\n8주차 과제 잘 진행해주셨네요 ㅎㅎ 고생하셨습니다!!\n\nQ) Post와 User의 합성 타입인 PostWithAuthor 타입의 위치가 고민됐었습니다.\n\n엔티티는 최대한 순수하게 두려고 최소 피쳐 레이어 이상에서 합성하려고 했는데 PostWithAuthor가 여러 feature에서 사용하는 타입이라 어디다가 위치해야할지 헷갈렸습니다.\n\n문서를 찾아보니 비즈니스 엔티티 간의 상호 참조 패턴 중에 Cross-import(@x)를 사용하는 방법(참조: https://feature-sliced.design/kr/docs/guides/examples/types#%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4entity%EC%99%80-%EC%83%81%ED%98%B8-%EC%B0%B8%EC%A1%B0)이 있었고.\n\n최종적으론 `entities/post/@x/with-user.ts`에 뒀는데, 개인적으로 `as unknown as User` 같은 느낌이라 영 맘에 들진 않았습니다. 그냥 features 레이어에서 정의하는 게 더 나았을까요?\n\n코치님의 상황에선 어떻게 접근하셨을지 궁금합니다.\n\nA)\n저는 아마 entities/post 에 넣어서 관리했을 것 같아요!\n이게 entities 간에도 의존관계라는게 있기 때문에, 이를 단방향으로 의존하도록 만들어놓고 관리하는거죠.\n지금 진행해주신 방식도 나쁘지 않다고 생각합니다! 기준을 잡아서 같이 지키면 되는거니까요 ㅎㅎ",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/25"
    }
  },
  {
    "passed": false,
    "name": "김도현",
    "feedback": "이번 과제를 제출하지 못한 것 같아서 아쉬워요. 바쁘거나 여러 사정이 있었겠지만, 시간이 될 때 꼭 한번 해보기를 권합니다.\n\n이번 과제의 핵심은 FSD를 완벽하게 구현하는 게 아니에요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외운다는 점을 이해하고, 일관된 규칙으로 폴더 구조를 만들어보는 경험이 목표입니다. 직접 해보면 \"이 코드는 어디에 둬야 하지?\"라는 고민이 줄어들고, 폴더 이름만 봐도 프로젝트가 뭘 하는지 알 수 있는 구조가 뭔지 감이 잡혀요. 코드의 구조와 선명도가 확실히 달라지는 걸 느낄 수 있을 거예요.\n\n다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/13"
    }
  },
  {
    "passed": true,
    "name": "김민석",
    "feedback": "FSD에 대한 질문\n\n멘토링때도 늘 말씀드리는 편이지만 FSD가 실버불렛은 아니라고 생각해요~\n말씀하셨던대로 애플리케이션을 일정한 기준을 갖고 레이어를 구분하고 각 레이어같의 의존에 방향성을 정한다 라는 컨셉은 참 좋은 컨셉이고\n그리고 각 레이어를 일정한 규칙을 갖고 세그먼트로 일반화해서 역할별로 분리했다는 아이디어도 좋다고 생각합니다.\n이 주요한 아이디어를 가지고 사실 FSD를 그대로 사용하기 보다는 만들려는 어플리케이션이나 팀의 선호도에 맞게 각색해서 사용하는 것이 더 맞는 것 같아요.\nFSD가 레이어를 나누는 기준자체는 중요하지 않은 것 같고 어플리케이션 상황이나 팀 상황에 맞게 커스텀하시면 될 것 같습니다.\n중요한건 일관성이라고 생각합니다.",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/27"
    }
  },
  {
    "passed": false,
    "name": "김민지",
    "feedback": "ㅋㅋㅋ민지님 고생하셨어요\n아니 왜 회고에 요런거 남기세요 ㅠㅠ\n> 기분 : 나의 코드도 남의 눈에는 이렇게 보이겠죠...?\n\nsrc/features/comment/ui/AddCommentDialog.tsx나 다른 부분들도 좀 보이는데, 피처에서 app을 접근하는 FSD 계층을 넘나드는 의존이 보이는 것 같아요! 이런 부분들이 FSD에서 매우 중요한데, 린트 도구같은것들을 활용해서 실수를 하지 않도록 해보는게 좋을것 같아요.\n\n막연한 부분 답변을 좀 드려보면..\n\n> 1. api 파일 위치\n\n넵 맞습니다! 근데 저희가 대부분 앱을 만들고 API통신을 하다보면 결국 대부분이 엔티티를 조작하는 통신을 하고 있는게 보일거에요\n그런관점에서 feature/api에 위치할만한 것들은 생각보다 많지는 않을거에요.\n계속 진행을 하시면서 고민이 드셨겠지만 정확하게 이건 여기! 라고 하기 어려운 기준을 가진 아키텍쳐거든요. \n'답이 맞나?'를 고민하기보다 모두가 공감할 수 있는 기준을 만들고 일관되게 지키는게 중요합니다.\n\n> 2. tags의 도메인 분리\n\nAPI가 잘! 설계되어있다면 그대로 따라가도 괜찮지만, 모든 상황에서 그대로 따르는 것은 약간 걱정이 되는것 같아요. BE측에서도 결국 구현의 편의상 정해지는 개념들이 FE처럼 있을거거든요. 지금은 태그만 독립적이게 관리가 되거나 페이지가 분류되어있거나..하는 케이스가 없으니 포스트에 묶여서 관리되도 무리가 없을 것 같아요.\n\n> 3. 전역 상태 위치\n\n이게 지금 의존을 넘나들게 하는 문제 지점인것 같은데요.\n전역상태이긴 하지만, 각 엔티티에 해당되는 값일 수도 있고 피처나 ui에도 묶일 수 있거든요. 이 상태가 어떤 레이어에 묶이는지를 고민하는게 필요한 것 같아요.\n\n> 4. FSD는 이렇게 작은 규모에도 적합한 형태일까요?\n\n정확합니다.\n지금 구조에서는 과하게 느껴질 수 있는데요! 프로젝트가 앞으로 확장되어 가는 형태라면 적용을 이 단계에서 해볼 수 있지만, 짧은 생명주기를 갖는 프로젝트라면 이런 구조는 적합하지 않은것 같아요.\n\n> 5. 기능 기반으로 해야하는데 도메인 기반으로 구분하는게 맞을까요?\n\n지금의 분류 방향이 맞아요! 이 도메인이라는게 결국 데이터고 데이터를 기준으로 응집도와 결합도가 분류되는게 자연스러운 분류 방식이거든요. 데이터의 흐름으로 분류를 해야 응집도를 높이고 결합도를 낮출수 있어요.\nFSD라는 관점에서 이 엔티티를 기반으로 어떤 기능을 하는지 분류를 하고, 우리들이 회사에서 일할 때 요구사항들도 이 기능을 기반으로 의사소통을 하니  중심을 기능으로 본거져.\n\n아무튼 구현 관점에서 DDD는 이 도메인을 어떻게 관리할지 응집도를 높이는 방향에서 구현을 다르기도 하고, FSD는 프런트엔드에 집중해서 정리가 된 부분이 있다보니 다른 이야기를 하는 부분이 큰걸로 일단 알고 있습니다 \n\n고생하셨고 다음 주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/37"
    }
  },
  {
    "passed": false,
    "name": "김성민",
    "feedback": "이번 과제를 제출하지 못한 것 같아서 아쉬워요. 바쁘거나 여러 사정이 있었겠지만, 시간이 될 때 꼭 한번 해보기를 권합니다.\n\n이번 과제의 핵심은 FSD를 완벽하게 구현하는 게 아니에요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외운다는 점을 이해하고, 일관된 규칙으로 폴더 구조를 만들어보는 경험이 목표입니다. 직접 해보면 \"이 코드는 어디에 둬야 하지?\"라는 고민이 줄어들고, 폴더 이름만 봐도 프로젝트가 뭘 하는지 알 수 있는 구조가 뭔지 감이 잡혀요. 코드의 구조와 선명도가 확실히 달라지는 걸 느낄 수 있을 거예요.\n\n다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/9"
    }
  },
  {
    "passed": true,
    "name": "김소리",
    "feedback": "고생하셨습니다 소리님!\n모호한 부분이 있을텐데도 불구하고 과제 전부 잘 마무리 해주셨네요\n엔티티의 경우 여러 페이지에서 반복적으로 사용되는 데이터 패턴이 있거나 읽기 목적의 데이터들이 보이는 경우에 고려해주시고 피처는 말씀대로 동작에 관한 것들을 분류해주면 될 것 같아요 ㅎㅎ\n\n결국 지금 당장은 나쁘지 않다고 생각하겠지만, 시간이 지나면서 정리가 되지않은 분류가 모호한 코드는 운영에 대한 부담과 난이도가 복리가되서 돌아온다고 많이 이야기를 하더라구요. 이런 부분들에 있어서도 한번 고민을 해보고 접근해도 좋을것 같아요 ㅎㅎ\n\nFSD를 사용하신걸 보면 규칙을 잘 지키려고 노력을 하셨지만..!\nwidgets/posts-table/PostsTable.tsx 같은 곳에서 widget에서 app에 의존을 가져가거나 다른 곳에서도 피처에서 app에 의존을 갖는 경우가 있는 것 같아요. 이게 store의 위치가 애매해서 그런것 같은데, 제가 보기에는 엔티티나 피처 레이어로 가져가도 될 법한 친구들이 있거든요.\n이런 부분들을 정리해보면 좋을것 같아요!\n\n> 순수함수로 분리하면 코드가 깔끔해지지만, 때로는 메모이제이션이나 최적화를 위해 컴포넌트 내부에 두는 게 나을 때도 있지 않나요? 둘의 트레이드오프를 어떻게 판단하시는지 궁금합니다.\n\n리액트 컴포넌트를 운영하는데 있어서는 함께 둘 때 응집도를 높힌다는 관점이 있을 수 있지만, 순수함수로 분리가 가능하다면 분리해서 관리하는게 대부분 좋다고 생각하고 있어요. 요즘에는 컴파일러가 들어오고 명시적이게 메모이제이션이 되겠지만, 굳이 함수 내에 위치시켜서 재선언을 하고 사용을 할 필요가 크게 없었던 것 같아서요. 대신 반대로 분리가 억지인데 굳이 순수함수로 분리하는지를 고민해봐야 할 것 같은데 논리적으로 명확한 분류가 어렵다면 함수에 비즈니스 로직들이 담기는 이름을 짓고 사용하면 되지 않나 싶습니다!\n\n> 공통 컴포넌트, 유틸 함수, 타입 등을 모두 Shared에 넣다 보면 결국 Shared 폴더가 거대해질 것 같은데, 내부적으로 세분화를 어떤식으로 가져가면 좋을까요?\n\n이 부분도 결국 FSD에서 제공하는 규칙대로 slice와 세그먼트에 맞춰서 분류하면 됩니다. 생각보다 그렇게 크게 거대해지지않을거에요!ㅎㅎㅎ\n\n고생하셨고 다음 주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/33"
    }
  },
  {
    "passed": false,
    "name": "김우정",
    "feedback": "우정님 수고하셨습니다.\n\n지금 토요일 오전에 채점중인데요.\n과제 셀프회고 내용이 거의 없네욥.\n역랑을 궁극적으로 발전시키는데에는 동작하는 코드도 중요하지만 코드에대한 생각 정리와 과정에 대한 복기인 것 같습니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/23"
    }
  },
  {
    "passed": false,
    "name": "김준모",
    "feedback": "안녕하세요 준모님! 8주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n다만 심화과제까지 하기에는 시간적 여유가 없었던 것 같군요 ㅠㅠ 아쉽습니다.\n\n> 이런식으로 FSD 에 따라 각 도메인 별로 entities/user/model/store.ts 처럼 store 를 분리해서 넣으면 했갈리지 않나...? 라는 생각을 했는데 어떻게 생각하시나요? 아직 제가 상태관리 부분에 미흡해서 그런 걸 수도 있을거 같습니다만...\n\n흠.. 어떤 부분이 헷갈릴까요!? 그게 중요한 포인트일 것 같아요.\n일단 저는 나쁘지 않다고 생각합니다!\n\n다만 api 호출을 store 내부에서 하고 있어서 이 부분은 조금 조심스러워요.\nstore 내부에서 호출하는게 아니라, store 바깥에서 호출된 결과를 토대로 store에 저장하는 방식으로 만들어주면 어떨까요!?\n그래야 사이드 이펙트가 최소화될 것 같습니다..!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/42"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "김채영",
    "feedback": "잘했어요 채영! 이번 셀프회고는 정말 인상적이었습니다. 특히 \"울림이 안 왔다\"는 솔직한 출발점에서 시작해서 스스로 이해하려고 디스코드에서 토론하고, 실무 프로젝트에 대입해보고, 결국 자기만의 언어로 재정의하기까지의 과정이 고스란히 담겨 있어요.\n\n\"기존의 수평적인 방식이 크레이프 케이크라서 한겹씩 벗겨내서 먹지 않으면 속 재료를 알 수 없다면, FSD는 기능 단위를 세로로 자른 케이크 조각처럼 단면으로 한번에 속 재료를 알 수 있다\"는 비유가 정말 좋았어요. 이렇게 자기 언어로 개념을 재정의할 수 있다는 건 진짜로 이해했다는 뜻입니다.\n\n그리고 채영이가 \"엔티티 중심 사고로 돌아가려는 자신을 발견했다\"고 썼는데, 사실 저는 그게 오히려 FSD의 더 큰 강점이라고 생각해요. FSD의 가장 큰 의의는 기존의 역할 기반 구조에서 \"엔티티\", \"화면\", \"기능\" 이 세 가지 관점을 명확히 나누자는 거거든요. 엔티티가 드러나는 폴더 구조가 좋은 구조예요. 그러니까 엔티티 중심 사고를 버리려고 하지 말고, 오히려 그 감각을 살리세요.\n\n저는 entities는 서버 상태 관리, features는 클라이언트 상태 관리, widgets은 화면 단위 이렇게 나누고 있는데 이렇게 하니까 응집도가 높아지더라고요. 그리고 거대한 프로젝트에서 페이지별로 관심사가 다르다면 FSD는 얼마든지 nested하게 쓸 수 있어요. 각 pages 하위에 FSD 구조를 다시 적용하는 방식이죠.\n\nAPI URL 설정 시행착오 과정도 인상적이었어요. 1단계부터 6단계까지 포기하지 않고 하나씩 해결해나간 과정 자체가 좋은 학습이에요. 이런 삽질 경험이 쌓이면 나중에 비슷한 문제를 만났을 때 훨씬 빠르게 해결할 수 있습니다.\n\nQ) 제가 정의한 FSD 슬라이스 기준(도메인 vs 기능)들이 적절한지 궁금합니다.\n\n적절해요. FSD를 잘해야겠다보다는, 이 철학을 바탕으로 내 폴더 구조에 적용하면서 규칙을 설명할 수 있는 구조를 만드는 게 더 중요합니다. 채영이가 정리한 기준을 프로젝트 전체에서 일관되게 적용하면 돼요.\n\nQ) Query mutation 시 낙관적 업데이트 구조가 적절했는지 궁금합니다.\n\n낙관적 업데이트는 사용자 경험을 위한 선택이에요. 실패 시 롤백 처리만 잘 되어 있다면 구조적으로 문제없습니다. 실무에서는 네트워크 불안정한 환경도 고려해서 롤백 로직을 꼼꼼히 테스트하는 게 포인트예요.\n\n3챕터 동안 정말 수고했어요. \"엔티티가 드러나는 폴더 구조가 좋다\"는 감각, 이번 과제에서 충분히 느꼈을 거예요. 그 감각 계속 가져가세요!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/5"
    }
  },
  {
    "passed": true,
    "name": "김현우",
    "feedback": "현우님 올려주셨군요 ㅎㅎ\n회고도 꼼꼼하게 작성해주셨네요 \n구현해주신 부분에 있어서 잘 적용해주시고 고민도 많이 해주셨던것 같아요 \n다만, 다만, tanstack query를 적용하면서 entity로 해당 값들을 관리하는 경우들이 있는데, 이 부분들은 피처에 더 적합하지 않나 싶어요! 단순히 해당 엔티티에 대해 조회하는 목적이 아니라 액션들이 들어가는 부분이 있어서요.\n참고해주시면 좋을 것 같습니다. \n\n추가로 entities/post/ui/PostTable.tsx 에서 여러 엔티티에 접근을 하고 있는것 같아요. 비록 타입이지만, 이 부분에 있어서 의존 방향을 명확하게 해주시면 좋을거 같아요. \n\nshared의 경우에도 가능한 비즈니스 로직을 담지 않아야 하는 공통 로직들이 담겨야 하는데, 해당 부분에 있어서 Post를 참조한다거나 하는 부분이 있는것 같아서 위치를 잘 잡아주면 좋을것 같습니다.\n\n> FSD에서 컴포넌트를 어떤 폴더에 두어야 하는지 헷갈립니다. 가령 페이지네이션 컴포넌트는 독립적인 UI 형태로 재사용할 수 있어 widgets 혹은 shared 중 어느 곳으로 위치 시켜야할지 고민이 되었습니다. widgets과 shared 폴더를 어떤 기준으로 분리하시는지 궁금합니다.\n\n위젯이 항상 이런 부분이 존재하는데요. 위젯은 명시적으로 언제 사용한다고 개념을 잡기 보다는 명시적인 케이스들은 분리하고 피처와 피처를 조합해 사용하거나..레이어의 규칙을 위배되지 않는 선에서 페이지나 앱으로 가기 어려운 컴포넌트를 명확하게 관리하는 영역으로 사용을 저는 자주 했던것 같아요. 적어도 위젯에 대해서는 조금 나이브하게 접근해도 괜찮지 않을까..!\n\n고생하셨고 다음 주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/10"
    }
  },
  {
    "passed": false,
    "name": "남은주",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "노유리",
    "feedback": "고생하셨습니다 유리님!\n과제 관련해서는 잘 정리해주신것 같아요.\n규칙에 맞게 잘 분류를 하려고 노력해주셨구요.\n다만, tanstack query를 적용하면서 entity로 해당 값들을 관리하는 경우들이 있는데, 이 부분들은 피처에 더 적합하지 않나 싶어요! 단순히 해당 엔티티에 대해 조회하는 목적이 아니라 액션들이 들어가는 부분이 있어서요.\n참고해주시면 좋을 것 같습니다. \n\n그리고 /entities/post/api/postApi.ts에서 entities에서 다른 enitity를 접근하는게 있는데, 이렇게 사용이 되면 상위로 끌어올려져야해서 이 부분도 한번 잘 고민해보시면 좋을것 같아요!\n\n기다렸는데 추가 회고 작성은 없어서 여기까지 할게요 ㅎㅎㅎㅎ\n다음주도 화이팅이니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/8"
    }
  },
  {
    "passed": false,
    "name": "도희정",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "박수범",
    "feedback": "잘했어요 수범! 스타크래프트로 FSD를 설명한 부분이 정말 인상적이었습니다. 마린은 체력이 40이고 총을 쏜다는 정보가 Entity, 스팀팩이 Feature, 하단 UI 패널이 Widget이라는 비유가 딱 맞아요. 이렇게 자기 언어로 개념을 재정의할 수 있다는 건 진짜로 이해했다는 뜻입니다.\n\n\"이 구조는 나는 게시판입니다!라고 소리칩니다. 폴더 이름만 봐도 기획서의 목차가 보입니다.\"라고 쓴 부분도 핵심을 정확히 짚었어요. FSD의 가장 큰 의의가 바로 그거예요. 기술 스택이 아니라 비즈니스 도메인이 앞으로 나오는 것. 엔티티가 드러나는 폴더 구조가 좋은 구조입니다.\n\n그리고 Entity Store는 \"누가 로그인했는가\"(정체성), Feature Store는 \"무엇을 검색하고 있는가\"(행동)로 구분한 것도 좋아요. 저도 비슷하게 entities는 서버 상태 관리, features는 클라이언트 상태 관리로 나누고 있거든요.\n\nQ1. 낙관적 업데이트의 실패 처리는 실무에서 얼마나 정교하게 구현하나요?\n\n실무에서는 롤백보다 \"재시도 유도\"를 더 많이 써요. 실패하면 이전 상태로 조용히 돌리고 토스트로 \"다시 시도해주세요\" 정도만 보여주는 게 대부분입니다. 사용자는 자기가 낙관적 업데이트를 경험했는지도 모르는 게 좋아요.\n\nQ2. 서버 상태와 클라이언트 상태의 명확한 구분 기준은 무엇인가요?\n\n\"새로고침하면 날아가도 되는가?\"로 판단하세요. 모달 열림/닫힘은 날아가도 되니까 클라이언트, 검색 결과는 서버에서 다시 받아야 하니까 서버 상태예요. 모달이 특정 데이터에 종속될 때는 모달 상태는 클라이언트에, 그 안에 보여줄 데이터는 서버 상태로 분리하면 됩니다.\n\nQ3. 환경 변수 관리의 Best Practice가 궁금합니다.\n\n실무에서는 .env.development, .env.staging, .env.production으로 나누고 CI/CD에서 빌드 시점에 주입해요. 런타임 주입이 필요하면 window.__ENV__ 같은 전역 객체를 쓴다거나 프레임워크등에서 제공하는 런타임 config 기능등을 활용하면 됩니다.\n\nQ4. SPA 배포 시 404 처리는 어떻게 하시나요?\n\nVercel이나 Netlify는 설정 파일 한 줄이면 끝나요. S3+CloudFront는 CloudFront의 Error Pages에서 404를 index.html로 리다이렉트 설정하면 됩니다. 비용 효율만 보면 Vercel 무료 플랜이 가장 편해요.\n\n3챕터 동안 수고했어요. 스타크래프트 비유처럼 자기만의 언어로 개념을 설명할 수 있게 된 것, 그게 이번 과제의 가장 큰 수확입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/4"
    }
  },
  {
    "passed": true,
    "name": "박용태",
    "feedback": "용태님 수고 많으셨습니다.\n\nQ-1) FSD 질문\n멘토링때도 늘 말씀드리는 편이지만 FSD가 실버불렛은 아니라고 생각해요~\n말씀하셨던대로 애플리케이션을 일정한 기준을 갖고 레이어를 구분하고 각 레이어같의 의존에 방향성을 정한다 라는 컨셉은 참 좋은 컨셉이고\n그리고 각 레이어를 일정한 규칙을 갖고 세그먼트로 일반화해서 역할별로 분리했다는 아이디어도 좋다고 생각합니다.\n이 주요한 아이디어를 가지고 사실 FSD를 그대로 사용하기 보다는 만들려는 어플리케이션이나 팀의 선호도에 맞게 각색해서 사용하는 것이 더 맞는 것 같아요.\n\n분리에 관해서도 마찬가지입니다. 리팩토링의 관점에서의 분리는 저는 \"필요할 때\"한다가 제 기본 마인드입니다.\n하지만 FSD는 분리에 어느정도의 가이드라인이 있고 각 세그먼트별로 분리를 하자는 약속이 있기 때문에 분리를 해야한다고 압박(?)을 받는 것이죠.\n이것도 규칙을 다시 정하면될 것 같아요. 필요한 경우 분리한다 혹은 이런경우는 분리하지 않을 수도 있다 이렇게 룰을 정하면될 것 같아요\n무엇보다 중요한 건 일관성일것이고 일관성의 측면에서는 그냥 무지성으로 세그먼트로 분리하는 것이 더 편할 수도 있습니다.\n일반적으로 저는 함수나 모듈을 같은 파일안에서 분리하는 것은 코드의 리더빌리티를 높일 수 있고 책임범위를 분리할 수 있기 때문에 늘(보통은) 필요하다고 생각합니다.\n다만 무언가를 다른 파일로 분리하는 것은 재사용을 위해서 해당 로직들이 별도의 모듈로 승격이 되는 큰 작업중 하나라고 생각합니다.\n아무튼 무먼가가 특정한 이유로 추상회되어 그룹이 지어진다는 것은 그것을 다른 곳에서 사용한다는 의미니까요.\n그런관 점에서 저는 세그먼트도 상황에 따라 커스텀할 수 있다고 생각합니다 :) \n\n분리되지 않은 투박한 코드가 잘 읽히고 같이 개발하시는 분들도 동의한다면 저도 그걸로 좋다고 생각합니다.\n하지만 어느시점부터 잘 읽히지 않는 다면 그건 뭔가 리팩토리잉 필요하다는 신호라고 생각합니다.(물론 다른 이유도 많지만요..)\n아무튼 코드가 신호를 줄때 분리하는 것이 옳다는 것이 제 생각이고 분리를 위해 분리를 하는 것은 피하는 편입니다.\n\n\nQ-2) TanStack Query 관련 코드 리뷰 부탁드립니다!\n 와 Vue를 사용해본지도 너무 오래되긴 했네요. Vue에 반응형 시스템을 그대로 활용하려면 어쨌거나\nReact query가 만들어 내는 데이터를 Vue의 반응형 시스템 파이프라인에 녹여야 할 것 같은데요.\n결국 React Query가 만든 데이터를 Vue의 API로 감싸서 사용하는 형태가 될 것 같긴하네요.(저도 안해봐서 잘모르겠습니다만...ㅎㅎ)\n크게 생각해보진 않았는데 Vue의 반응형 시스템과 React Query를 잘 녹이려면 생각보다 복잡해질 것 같긴합니다.\n그건 그렇고\n지금 과제로 작성해주신 React Query를 크게 잘못된 것이 보이진 않는 것 같아요.\n일반적으로 사용하는 방식 그대로 사용하신 것 같습니다.\n오히려 그 방식을 Vue에서 사용했을때 뭔가 복잡도가 올라갔었던 것 같습니다.\n이것은 용태님도 개발하시면서 느끼지 않으셨을까 생각해봅니다 :) ",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/43"
    }
  },
  {
    "passed": true,
    "name": "박지영",
    "feedback": "잘했어요 지영! 셀프회고가 정말 꼼꼼하고, 특히 FSD를 단순히 따라하기가 아니라 왜 이런 구조가 필요한지를 고민한 흔적이 잘 보입니다.\n\n\"모든 상태를 전역으로 관리할 필요가 없다는 것을 깨달았습니다\"라고 쓴 부분이 인상적이었어요. 많은 분들이 Zustand나 Redux를 배우면 모든 걸 전역으로 올리려고 하는데, 지영이는 상태의 성격에 따른 분리를 스스로 발견했네요. features에서 다른 features를 참조하고 싶은 유혹을 이겨내고 공통 로직을 entities나 shared로 내린 부분도 좋았습니다.\n\n지영이가 고민한 \"오버엔지니어링 아닌가?\", \"경계가 애매하다\" 같은 질문들은 사실 FSD를 배우는 진짜 이유와 연결되어 있습니다. FSD를 배우는 목적은 FSD를 완벽하게 구현하는 게 아니라고 제가 계속 강조를 했어요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못해요. 대신 규칙은 잘 외우는 편이죠. 그래서 일관성 있는 규칙을 만들어두면 관리가 쉬워지는 겁니다. 핵심은 경계를 고민하는 게 아니라, 규칙을 세워서 그 규칙대로만 하면 분리가 다 되느냐 아니냐를 발견하는 거예요.\n\nQ) FSD를 실제로 사용하고 계신지, 개인적인 선호도가 어떻게 되시는지 궁금합니다.\n\n네 사용하고 있어요. 하지만 FSD를 pages를 중심으로 nested하게 구성해서 쓰고 있어요. 실제로 pages별로 굉장히 독립적이다 보니 flat한 FSD만으로는 좀 관리가 어려웠어요.\n\n경계를 나누는 기준은 저는 FSD를 그대로 쓰기보다는 entities는 서버 상태 관리, features는 클라이언트 상태 관리, widgets는 useQuery와 화면 영역의 조합 정도로 단순화해서 씁니다. FSD가 완벽해서 쓰는 게 아니라 누군가가 명세를 문서화했고 널리 알려졌기 때문에 소통 비용이 줄어서 쓰는 거예요. 나중에 폴더 구조에 대한 설명이 없이도 보면 스스로 학습할 수 있으니까요.\n\nQ) 프로젝트 규모에 따라 FSD 적용 수준을 조절하는 기준이 있을까요?\n\n오버헤드라고 느껴지면 새로운 규칙을 찾아보세요. 중요한 건 FSD 자체가 아니라 팀 내에서 컨벤션을 만들고 그것을 일관되게 지키는 방향입니다. 그게 FSD든 아니든 상관없어요.\n\nQ) entities와 features의 경계가 애매한 경우 어떻게 판단하시나요?\n\n경계를 고민하지 말고 규칙을 하나 정하세요. 규칙이 맞냐 틀리냐보다 일관성 있게 적용되느냐가 더 중요합니다.\n\n3챕터를 함께 하느라 수고했어요. 이 과정을 통해서 프로젝트의 경계와 일관성이라는 관점에서 코드를 보는 눈이 더 선명해졌기를 바랍니다. 다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/19"
    }
  },
  {
    "passed": true,
    "name": "박창수",
    "feedback": "AI를 진하게 사용하신것 같네요 창수님 ㅋㅋㅋ\n리뷰 요청시에는 필요없는 AI관련 도구들은 같이 포함을 안시켜도 좋을것 같아요\n\ntanstack query를 적용하면서 entity로 해당 값들을 관리하는 경우들이 있는데, 이 부분들은 피처에 더 적합하지 않나 싶어요! 단순히 해당 엔티티에 대해 조회하는 목적이 아니라 액션들이 들어가는 부분이 있어서요.\n참고해주시면 좋을 것 같습니다. \n\nfeatures/post-search/ui/PostSearchInput.tsx같은 곳에서 feature에서 feature를 의존하는 방향이나, \nsrc/features/add-post/model/useAddPost에서도 피처끼리 의존하는ㄱ것처럼 FSD의 규칙을 위배하는 부분도 아직 있는것 같아요! 의존의 방향이 제일 중요한 이야기가 되니까 이런 부분들은 린트로 잘 관리해주시면 좋을것 같아요. \n\n다음 주 과제도 화이팅입니다!\n",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/20"
    }
  },
  {
    "passed": true,
    "name": "박형우",
    "feedback": "안녕하세요 형우님! 8주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n\nQ)\n문득 궁금증이 생긴 부분인데요.\n함수나 ui컴포넌트 내부에 주석을 자주 사용하는 건 안 좋은 습관/방법(?) 일까요?\n주석을 많이 사용하면 더티 코드가 될까요?\n\nA)\n저는 주석을 \"히스토리\"를 남기기 위함이라고 생각해요. 혹은 문서의 역할을 대체한다거나!?\njsdoc이나 typedocs 같은 것들을 이용해서 주석 기반의 문석을 만들어주거나\n아니면 이 코드가 \"왜\" 생겼는지, 왜 필요한지 등을 명시하는거죠\n\"어떻게\" 하는지 보다 \"왜\" 가 더 중요하답니다 ㅎㅎ\n\n가령, 코드를 삭제해도 되나 안 되나에 대한 판단을 한다거나!?",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://hyeongwoo94.github.io/front_7th_chapter3-3/"
    }
  },
  {
    "passed": true,
    "name": "박희정",
    "feedback": "고생하셨습니다 희정님!\n쿼리 모두 잘 적용해주신 것 같은데, 체크박스가 처리 되어있지 않네요\n회고도 잘 작성해주셨네요.\n\nsrc/shared/store/postAtoms.ts\n다만 우려가 되는 부분이 있는데, 위 shared 경로처럼 코드들에 각 레이어에 있는 여러 도메인 기능들이 결합되는 부분들이 존재하는데요. shared를 그렇게 쓰다가는 여러 레이어를 무시하는 계층으로 활용될 가능성이 있어서 가능한 공유가되는 코드지만, 각 도메인들에 얽메이지 않는 내용들만 담기는게 필요한 것 같아요. \n\n그 외에는 잘 고민해서 잘적용해주셨던것 같으니 이 부분도 잘 챙겨봐주시면 좋지 않을까..!\n\n> 과제를 하면서 제 역량의 한계를 더 명확히 보게 됐습니다. 시니어 직전으로 인정받기 위해 제가 만들어야 할 구체적 결과물은 무엇이고, 4~5년차에게 요구되는 기준(역할·기술·협업)은 어디까지인지 궁금합니다.\n\n음...! 제가 생각하는 부분에 있어서 말씀을 드려보면 (저도 아직 부족해서 채워나가야 한다고 생각하는 부분인데) \n크게보면 여러 작업을 빠르게 적응하고 쉽게 할 수 있는 역량, 컨텍스트 스위칭을 잘 할 수 있는것 \n모호한 작업을 구체적이게 만들고 함께 해내는 것\n기술적인 어려움을 해결할 수 있는 역량이 시니어에게 필요한 기술적인 부분이지 않을까 싶어요. \n이 과제에 있어서 그런것들을 느낀다면 아키텍처에 대해 고민을 많이 하시면서 시니어들이 이런것들을 고민하고 작성해야 하는것 아닐까?라고 생각하셨나 싶었는데요. 과제 관점에서는 단순히 여러 아키텍처, 디자인 관점 중 하나의 이야기만 있으니 이런 이야기가 왜 나왔는지 비슷한 이야기는 무엇이 있는지, 그리고 우리 프로젝트에 어떻게 맞게 활용할지등을 잘 고민할 수 있으면 되지 않을까 싶습니다 ㅎㅎ\n\n고생하셨고 다음 주도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/38"
    }
  },
  {
    "passed": true,
    "name": "손승현",
    "feedback": "잘했어요 승현! FSD를 처음 접했는데도 각 레이어의 역할을 실제로 나눠보면서 감을 잡아간 게 느껴집니다. 특히 \"작은 함수도 올바른 레이어에 두고 견고하게 만들어야 한다\"는 깨달음이 좋았어요. highlightText처럼 작은 유틸 하나도 제자리에 두는 습관이 쌓이면 나중에 큰 프로젝트에서 빛을 발합니다.\n\n\"깨끗한 코드가 테스트도 쉽게 만든다\"는 것도 정확히 맞아요. 입력과 출력이 명확한 순수 함수는 테스트하기 쉽고, 의존성이 분리돼 있으면 수정할 때도 영향 범위가 명확해지거든요. 이걸 3주 만에 체감한 건 큰 수확입니다.\n\n승현이가 아직 막연하다고 한 부분들에 대해 얘기하자면, 레이어 경계가 헷갈리는 건 자연스러운 거예요. 근데 중요한 건 경계를 고민하는 게 아니라, 규칙을 하나 정해서 그 규칙대로만 하면 분리가 다 되느냐 아니냐를 발견하는 겁니다. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외우거든요.\n\n저는 이렇게 단순화해서 쓰고 있어요. entities는 서버 상태 관리, features는 클라이언트 상태 관리, widgets는 화면 단위. 이렇게 나누니까 응집도가 높아지더라고요. 태그/검색 필터 로직 같은 것도 \"이게 서버에서 오는 데이터인가, 사용자가 UI에서 조작하는 상태인가?\"로 판단하면 돼요. 필터 옵션 목록은 entities, 현재 선택된 필터 값은 features에 두면 됩니다.\n\n서버 상태와 클라이언트 UI 상태의 구분은 \"새로고침하면 날아가도 되는가?\"로 판단하세요. 모달 열림/닫힘, 검색어 입력 중인 값은 날아가도 되니까 클라이언트 상태. 게시글 목록, 유저 정보는 서버에서 다시 받아야 하니까 서버 상태예요.\n\nFSD를 잘해야겠다보다는, 이 철학을 바탕으로 내 폴더 구조에 적용하면서 규칙을 설명할 수 있는 구조를 만드는 게 더 중요합니다. 그리고 \"엔티티가 드러나는 폴더 구조가 좋다\"는 감각을 가져가세요. 폴더 이름만 봐도 이 프로젝트가 뭘 하는지 알 수 있는 구조가 좋은 구조예요.\n\n3챕터 동안 수고했어요. 처음 접한 개념인데도 끝까지 따라온 것, 그게 가장 중요합니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/2"
    }
  },
  {
    "passed": false,
    "name": "신수빈",
    "feedback": "과제를 마무리 해주시지 못했군요 ㅠㅠ\n관련해서 FSD를 단순히 분류하기 보다는 과정을 진행하고 이를 왜 이렇게 분류했는지, 그리고 관련된 아키텍처들은 왜 이런 기준을 가졌는지 고민해보고 이야기 해보면 좋다고 생각합니다.\n너무 오랜 시간 뒤에 진행하기 보다는 꼭 진행하고 이야기 많이 나눠 보시면 좋겠어요!\n다음주 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/24"
    }
  },
  {
    "passed": false,
    "name": "안소은",
    "feedback": "이번 과제를 제출하지 못한 것 같아서 아쉬워요. 바쁘거나 여러 사정이 있었겠지만, 시간이 될 때 꼭 한번 해보기를 권합니다.\n\n이번 과제의 핵심은 FSD를 완벽하게 구현하는 게 아니에요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외운다는 점을 이해하고, 일관된 규칙으로 폴더 구조를 만들어보는 경험이 목표입니다. 직접 해보면 \"이 코드는 어디에 둬야 하지?\"라는 고민이 줄어들고, 폴더 이름만 봐도 프로젝트가 뭘 하는지 알 수 있는 구조가 뭔지 감이 잡혀요. 코드의 구조와 선명도가 확실히 달라지는 걸 느낄 수 있을 거예요.\n\n다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/18"
    }
  },
  {
    "passed": true,
    "name": "안재현",
    "feedback": "수고하셨습니다. 재현님\n\nQ. 많은 분들께 여쭤봤을 때 FSD 레이어를 분리하는 기준이 다른 경우가 많았어서 흥미로웠습니다. 코치님께서는 프로젝트에서 FSD를 도입하신다고 하면 어떤 기준을 가지고 레이어를 분리하실 것인지, 슬라이스(도메인)은 어떤 기준으로 나눌 것 같으신지 궁금합니다 !\n\nA. 일단 기준이라는 것은 만들려고하는 것이 무엇인지에 따라 달라질것 같아요.\n굳이 기준을 이야기 하지만 컴포넌트의 조합 어느정도 깊이까지 이뤄지는 가를 먼저 파악을 하게 될 것 같습니다.\n만들려는 어플리케이션이 어떤 구성이 필요한지 힌트를 줄 것 같거든요.\n만약에 그게 미리 알수 없다? 라고 한다면 전 딱 세가지 부터 시작할 것 같아요. page, feature, entity\n그리고 프로젝트가 진행하면서 레이어를 추가하거나 할 것 같습니다 ~\n물론 FSD가 지정한 각 레이어별 의미가 동일한 레이어는 아니겠지만요.\n중요한건\n애플리케이션을 일정한 기준을 갖고 레이어를 구분하고 각 레이어같의 의존에 방향성을 정한다 라는 컨셉과\n그리고 각 레이어를 일정한 규칙을 갖고 세그먼트로 일반화해서 역할별로 분리한다는 컨셉인 것 같습니다.\n요 두가지만 가져가고 나머진 다 커스텀 하게 어플리케이션에 맞게 구성할 것 같아요 :)",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/31"
    }
  },
  {
    "passed": true,
    "name": "양진성",
    "feedback": "진성님 수고하셨습니다.\n\nQ. widgets 기준을 잡는 과정에서 많이 헷갈렸습니다.\n\n말씀하신 규칙 (entities+entities→entities, entities+features→widgets)은 FSD 원칙에 잘 맞는 방법 이라고 생각합니다.\n무엇보다 제일 피해야하는것은 레이어 의존의 역전되는 상황일것 같아요.\n사실 각 레이어가 무엇을 뜻하는지가 중요한다기보다는\n어떤 레이어가 어떤 레이어를 사용할 수 있는지 즉 그냥 추상화 래밸의 수준으로 이해하시면 될 것 같아요.\n그게 그냥 모든것을 다 무시할 수 있는 FSD의 핵심인 것 같습니다.\n그래서 말씀하신 규칙대로 사용하셔도 되고요. 중요한 것을 일관성 일것 같아요.\n저도 레이어와 각레어의 특성은 어플리케이션마다 커스텀해서 정의합니다. FSD와 전혀 다른 것도 사용합니다.\n\n\nQ. staleTime을 어떻게 결정하는 것이 좋을지 궁금합니다\n\n아시다시피 자주 변경되면 낮게 거의 변경이 없다면 높게 설정하는 것이 기본적입니다.\n이것을 데이터를 기준으로 한다고해서 늘 정확한것 도 아닌 것 같아요.\n중요한건 업데이트 주기 같아요.\n유저가 업데이트를 할 수 있고 그것을 모두가 볼 수 있는 상황이라면 업데이트 주기를 판단할 수 없으니 낮게 잡는 것이 맞고\n우리가 업데이트 하는 경우는 업데이트 주기를 알 수 있으니 그 주기에 맞게 설정하면 될 것 같습니다.\n저도 처음엔 페이지 재로드 빈도같은 데이터를 활용해야 하나 했는데 그것도 그냥 평균일 뿐이니까요. 평균에 함정에 빠질 수 있습니다 :)\n아 물론 참고는 할 수 있죠.\n",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/14"
    }
  },
  {
    "passed": true,
    "name": "오새듬",
    "feedback": "잘했어요 새듬! 폴더 구조를 정말 꼼꼼하게 정리했네요. 특히 Atomic Design의 모호한 문제점을 지적하면서 \"Molecule과 Organism의 경계가 모호하고, 비즈니스 로직의 위치가 불명확하다\"고 쓴 부분이 좋았어요. UI 기준으로 나누면 경계가 모호해지고 도메인 간 의존성을 찾기 힘들다는 걸 정확히 짚었습니다.\n\n\"관심사의 분리는 명확한 하나의 기준으로 선명하게 분리되는 게 중요\"라고 정리한 것도 핵심이에요. FSD의 가장 큰 의의가 바로 그거거든요. 기존의 역할 기반 구조에서 \"엔티티\", \"화면\", \"기능\" 이 세 가지 관점을 명확히 나누자는 것.\n\n그리고 entity는 순수한 비즈니스 데이터, feature는 사용자 액션과 관련된 로직, widget은 읽기 전용으로 조합만 한다고 정리한 것도 좋아요. 저도 비슷하게 entities는 서버 상태 관리, features는 클라이언트 상태 관리, widgets는 화면 단위로 나누고 있거든요.\n\nQ) features 폴더 구조에서 하위 폴더를 만드는 것과 파일명으로 기능을 명시하는 것의 차이가 있을까요?\n\n과제니까 오버엔지니어링으로 해도 상관없어요. 근데 실무에서는 \"그 정도까지 해야 하나?\" 싶은 것들이 보이거든요. 지금 규모에서는 솔직히 큰 차이 없습니다. 새듬이가 느낀 \"굳이\"라는 감각이 맞아요.\n\n다만 이건 이론적으로 뭐가 맞다고 말하기 어려운 영역이에요. model 파일을 많이 늘려서 더 유리했는지, 하위 폴더를 만드니 더 유리해지는지는 예측에 의한 인지소모량 문제인데, 이건 감각적인 부분이거든요. 그래서 제 조언은 자신에게, 그리고 동료에게 A/B 테스트를 해보라는 거예요. 한 프로젝트에서는 파일명으로만 구분해보고, 다른 프로젝트에서는 폴더로 나눠보고, 어느 쪽이 더 찾기 쉬웠는지 비교해보세요.\n\n더 실용적인 크기감을 찾아서 합쳐보고, 일관성을 찾아보고, 이런 식으로 적절한 크기감을 찾아가보세요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외우거든요. 핵심은 경계를 고민하는 게 아니라, 규칙을 세워서 그 규칙대로만 하면 분리가 다 되느냐 아니냐를 발견하는 겁니다.\n\n3챕터 동안 수고했어요. 이 감각적인 부분을 계속 실험하면서 자기만의 기준을 만들어가세요!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/29"
    }
  },
  {
    "passed": false,
    "name": "오태준",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/28"
    }
  },
  {
    "passed": true,
    "name": "윤지훈",
    "feedback": "고생하셨습니다 지훈님!\n회고를 보니까 이번 과제를 진행하면서 제대로 의미를 느끼셨던것 같아요.\n\n> 작은 기능 하나를 추가할 때도 여러 폴더를 오가며 파일을 생성해야 하는 점이 오버헤드처럼 느껴지기도 했습니다.\n\n이 부분은 정말 명확하게 판단하신겁니다. 전에 말씀드린것처럼 점진적으로 규모가 있게 되는 또는 어느정도 규모가 있는 프로젝트에 FSD를 적용하는게 적합해요.\n\n> 낙관적 업데이트를 적용해보긴 했는데, 제대로 한게 맞나 싶긴 하네요.. 낙관적 업데이트 프로세스대로 UI 선 반영하고 목록API 다시 받아와서 그리는 로직을 구현했습니다. 근데 확인한 바로는 CRUD를 해도 API 리스폰스에는 반영되지 않는 문제가 있어서 화면 상으로는 제대로 반영되지 않은 것 처럼 보이고 있습니다..! (그나마 local에서 실행하면 깜빡거리기는 함..) 리스폰스가 정상적으로 반환된다는 전제 하에, 이렇게 처리하는게 낙관적 업데이트가 맞는지 궁금합니다!\n\n탠스택을 활용해서 낙관적 업데이트를 하는 가이드가 있는데요!\nhttps://tanstack.com/query/v5/docs/framework/react/guides/optimistic-updates \n요거는 한번 읽어보셨으려나요! 아마 읽어보고 흐름에 맞춰서 잘 작성해주신것 같은데요. 더미 데이터를 사용하고 있어서 깜빡이는게 아닐까 싶은데요! 잘 구현해주신걸로 저는 보여져요 ㅎㅎ\n\n\n> 시간이 없어 직접 구현하진 못했지만, 팝업 호출부를 공통화하여 글로벌하게 관리하고 싶다는 생각을 했습니다. 이와 관련하여 막연하게 계획한 내용에 대해 피대븍 주시면 감사하겠습니다..!\n\n배열형태로 모달을 관리하는 것은 좋은것 같아요. \nFSD관점에서 UI는 shared에 위치하겠지만, 각 비즈니스 로직에 해당 될 수 이는 내용들은 별도로 분리되어있어서 호출할 때 선언하거나 주입하는 형태로 되어야겠네요. Promise는 나쁘지 않지만, 실제 구현을 하면 리액트의 동작과는 조금 어색한(?) 절차적인 구조로 진행될 가능성이 있을 것 같아요. 콜백같은걸 주입해서 제어하게 하면 어떨까 싶은데, 이 부분에 대해서는 조금 더 구현을 해보고 이야기 해봐도 좋을것 같습니다 ㅎㅎ \n\n고생하셨어요! 담주도 화이팅입니다~",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/35"
    }
  },
  {
    "passed": false,
    "name": "이예인",
    "feedback": "이번 과제를 제출하지 못한 것 같아서 아쉬워요. 바쁘거나 여러 사정이 있었겠지만, 시간이 될 때 꼭 한번 해보기를 권합니다.\n\n이번 과제의 핵심은 FSD를 완벽하게 구현하는 게 아니에요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외운다는 점을 이해하고, 일관된 규칙으로 폴더 구조를 만들어보는 경험이 목표입니다. 직접 해보면 \"이 코드는 어디에 둬야 하지?\"라는 고민이 줄어들고, 폴더 이름만 봐도 프로젝트가 뭘 하는지 알 수 있는 구조가 뭔지 감이 잡혀요. 코드의 구조와 선명도가 확실히 달라지는 걸 느낄 수 있을 거예요.\n\n다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/41"
    }
  },
  {
    "passed": true,
    "name": "이윤지",
    "feedback": "안녕하세요 윤지님! 8주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n\nQ1) onTagClick을 props로 받은 결정이 맞나요?\nURL 파라미터 변경은 라우팅 관련이라 상위에서 처리해야 한다고 생각했는데,\n이것도 atom으로 만들어서 PostRow 내부에서 처리하는 게 더 좋을까요?\n\nA1)\n재활용 관점에서 봤을 대 좋은 선택이라고 생각합니다!\n다만 현재 코드의 위치가 feature에 있기 때문에 PostRow 내부에서 관리해도 무방하다고 생각해요 ㅎㅎ\n\n근데 이제 보니 어차피 내부에서 Atom에 접근중이라, 일관성있게 다같이 store에 접근해도 좋지 않을까 싶네요!\n\n---\n\n\nQ1) 코치님은 FSD가 좋다고 느끼실 때가 있으신가요?\n\n사실 이번에 하면서 \"FSD 좋은가...?\" 싶었습니다.\n\"이건 어디 들어가지?\", \"hooks 폴더명을 안 쓰는 게 좋다고..?\" 하면서 계속 낯설게 느껴졌어요.\nentities/features 구분이 책임 분리에 도움되는 것 같으면서도, 막상 코드 짜다 보면 \"이건 어디 넣지?\" 하면서 헷갈리기도 했습니다.\n원칙은 이해했는데 아직까지도 어색한 느낌이에요.. 코치님은 \"FSD 이럴 때 진짜 좋다\"고 느끼시는 순간이 있으신가요?\n\nA1)\n제가 오늘(13일 토요일) 발제를 할 때 이야기 하긴 했는데, 저는 FSD를 실무에서 사용해본 경험이 없어요.\n다만 FSD가 다루는 \"원칙\"은 중요하게 생각합니다.\n\n응집도를 높이고, 의존성을 단방향으로 만들고, 관심사 단위로 분리하는 등의 과정은 필요하다고 생각합니다.\n다만 이에 대한 구현이 FSD에 종속될 필요는 없어요!\n\n나만의 방법으로 좋은 코드를 만들어가는 고민을 해봐도 좋다고 생각합니다.",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/7"
    }
  },
  {
    "passed": true,
    "name": "이정민",
    "feedback": "정민님 수고 많으셨습니다!\n\nQ. FSD 패턴이 실제로 실무에서 많이 사용되는지 궁금합니다. \n\n사실 저도 실무에서는 사용해본 적 없습니다.\n사이드 프로젝트에서 몇번 사용해봤어요.\nFSD를 온전히 적용하는 것은 사실 조금 유연하지가 않은 느낌이었어요.\n특히 레이어의 구분은 모호한 경우가 많았고요.\n중요한건 핵심 컨셉\n애플리케이션을 일정한 기준을 갖고 레이어를 구분하고 각 레이어간의 의존에 방향성을 정한다 라는 컨셉 \n그리고 각 레이어를 일정한 규칙을 갖고 세그먼트로 일반화해서 역할별로 분리한다라는 컨셉을 유지한 채\n각 상황에 맞게 커스텀해서 사용하는 것 같습니다.\n\n자주 사용하는 패턴이 따로 있진 않고\n그때 그때마다 팀원들과 함께 같이 결정하는 구조를 사용합니다.\n매번 달라지는 것 같아요.\n어차피 중요한 건 약속이고 그것의 일관성이니까요 :)",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/34"
    }
  },
  {
    "passed": true,
    "name": "이현지",
    "feedback": "고생하셨습니다 현지님!\n관련해서 DDD에서 추구하는 개념과 FSD를 결합하면서 함께 고민하셨었군요 ㅎㅎ 두개를 결합하면서 엔터프라이즈에서 많이 쓰는건 뭔가 할루시네이션같은것 같긴한데,.,ㅋㅋㅋㅋㅋㅋㅋㅋ재밌을거같아요.\n\ntanstack query를 적용하면서 entity로 해당 값들을 관리하는 경우들이 있는데, 이 부분들은 피처에 더 적합하지 않나 싶어요! 단순히 해당 엔티티에 대해 조회하는 목적이 아니라 액션들이 들어가는 부분이 있어서요.\n참고해주시면 좋을 것 같습니다!\n\n추가로 src/features/post/ui/index.ts에 widget이 포함되어있는데 요거는 실수겠죠? ㅎㅎㅎ\n요런 것들 놓치지 않게 린트도구들 같은거 잘 활용해보시면 좋을것 같아요!\n나머지 의존성 방향은 잘 지켜주신것 같고, Post Table에서 수행하는 작업이 너무 많은 것 같은데, 조금 더 나눠봐도 좋을것 같아요.\n\n고생하셨고 담주 과제도 화이팅입니다!!!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/32"
    }
  },
  {
    "passed": true,
    "name": "전이진",
    "feedback": "고생하셨습니다 이진님 ㅎㅎ \n시간이 짧았음에도 굉장히 여러번 많은 시도를 하셨네요 :+1\n\n> \"얼마나 잘게 쪼개야 하는가?\"의 정답을 아직 모르겠습니다.\n\n결국 이 부분은 저번주에 공부하셨던 단일 책임과 어느정도의 파일 추상화를 가질것인가에 이어지는 내용인 것 같은데요. 동일하게 설명을 해주셨을 것 같지만, 변경의 빈도와 범위가 비슷한 코드들을 함께 모으고 관리하는 지점을 찾아내는게 핵심인 것 같아요. 저도 늘 어려운데요. 우선은 처음부터 너무 잘게 쪼개면 과한 추상화가 되니 분류를 적절하게 하고 점진적으로 개선해나가는게 좋다고 생각해요.\n\n> 저만의 기준을 세우긴 했지만 widgets와 features의 경계도 여전히 애매하게 느껴집니다.\n\n위젯이 항상 이런 부분이 존재하는데요. 위젯은 명시적으로 언제 사용한다고 개념을 잡기 보다는 명시적인 케이스들은 분리하고 피처와 피처를 조합해 사용하거나..레이어의 규칙을 위배되지 않는 선에서 페이지나 앱으로 가기 어려운 컴포넌트를 명확하게 관리하는 영역으로 사용을 저는 자주 했던것 같아요. 적어도 위젯에 대해서는 조금 나이브하게 접근해도 괜찮지 않을까..!\n\n> 현재 FSD 구조에서 개선할 부분이 있을까요?\n\n지금은 대부분 규칙을 잘 지켜주신 것 같아요. 크게 무리되는 부분도 없고 의존을 역전하는 부분도 제가 보기에는 못찾은 것 같아요 :+1\n타입같은 곳에서 가끔 엔티티에서 엔티티로 접근하는게 있는것 같은데 이 부분에 대한 고민을 좀 더 해보셔도 좋을것 같구요!\n\n말씀해주신것처럼 PostsManagerViewModel에서는 조금 더 나눌만한 이야기들이 있는것 같아요. 지금 당장은 해당 코드를 여러 군데에서 사용하지 않아서 그대로 운영을 해도 무리는 없지만 주석으로 남겨주신 기준에 맞춰서 변경 빈도에 맞춰서 분리를 하면 좋지 않을까 싶습니다.\n\n> 실무에서 FSD를 도입할 때 가장 주의해야 할 점은 무엇인가요?\n\n말씀해주신것처럼 상호간에 모두 공감할 수 있는 규칙을 만들고, 이 규칙을 매번 이야기 하지 않도록 명확한 문서화를 하는게 중요하다고 생각해요 ㅎㅎ 리뷰단계에서도 정적 분석을 통해 검증을 명확하고 쉽게 할 수 있도록 하구요. 그리고 운영하다 보면 점점 더 복잡한 케이스들이 있는데 그럴때 열린 토론을 가능하게 하는것들! 그런것들이 가장 중요한것 같아요.\n\n고생하셨고 다음주도 화이팅입니다!!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/17"
    }
  },
  {
    "passed": true,
    "name": "전희재",
    "feedback": "희재님 수고하셨습니다.\n\nPR작성중이라고 하셔서 기다렸는데\n지금 토요일 오전에도 없어서 그냥 채점 마무리합니다. ㅜㅜ\n제가 주말에 해야할 일이 있어서요.\n제가 셀프회고 보는 맛으로 채점을 하기 때문에 작성해주시면 나중에라도 읽을게요 :) ",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/12"
    }
  },
  {
    "passed": true,
    "name": "정나리",
    "feedback": "나리님 수고 많으셨습니다!\n\nQ. Widget에서 Hook을 호출해도 되는가?\n\nWidget에서 features/entities hooks를 직접 호출하는 현재 방식이 FSD 규칙에 어긋나지 않느 것 같아욥~\nFSD에서 widget은 “완성된 UI 블록”으로서 데이터 로직을 내부에 캡슐화해야할 것 같아요.\n어찌보면 그냥 prop이 없을 수록 좀 더 이상적인 위젯인것 같습니다.\n언제 어디서나 데이터 신경 안쓰고 그냥 툭 붙일 수 있게 말이죠 (예를들면 추천 목록등등)\n\nA. Widget의 적절한 단위는?\n\nPostListWidget은 나쁘지 않은 것 같아요 위젯이라는 레이어가 레이어 중에 래밸이 높기때 괜찮습니다~\n사실 위젯을 판단하는 기준은 레이어의 방향성을 유지하는 수준으로 판단하는 수밖에 없을 것 같아요.\n크기나 단위보다도 말이죠. \n저는 기능적으로는 독립적으로 사용될 수 있어서 데이터 신경쓰지 않고 어디든 붙일 수 있는 것으로\n이해했지만 사실 이것도 잘 모르겠어요. FSD의 모호한 점이라고 생각해요\n그러니 각 레이어별 특성은 스스로 정의하기 나름인 것 같고 그저 중요한건 레이어간 의존의 방향성 인 것 같습니다.\n그 수준을 맞추다보면 위젯에도 가고 피처로도 가는거죠.\n\n저라면 post 테이블은 entity와 widget 사이의 어딘가의 레이어로 들어갈 것 같아요.\nentity에 table이라는 슬라이스를 만들어 재사용하거나 그렇게 재사용될 테이블이 아니라면\n그냥 entity에 넣을 것 같습니다. 저는 레이어의 특성보다는 의존구조만 생각합니다 :) ",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/6"
    }
  },
  {
    "passed": false,
    "name": "정한슬",
    "feedback": "이번 과제를 제출하지 못한 것 같아서 아쉬워요. 바쁘거나 여러 사정이 있었겠지만, 시간이 될 때 꼭 한번 해보기를 권합니다.\n\n이번 과제의 핵심은 FSD를 완벽하게 구현하는 게 아니에요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외운다는 점을 이해하고, 일관된 규칙으로 폴더 구조를 만들어보는 경험이 목표입니다. 직접 해보면 \"이 코드는 어디에 둬야 하지?\"라는 고민이 줄어들고, 폴더 이름만 봐도 프로젝트가 뭘 하는지 알 수 있는 구조가 뭔지 감이 잡혀요. 코드의 구조와 선명도가 확실히 달라지는 걸 느낄 수 있을 거예요.\n\n다음 챕터도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/39"
    }
  },
  {
    "passed": true,
    "name": "주민수",
    "feedback": "안녕하세요 민수님! 8주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n\n다만 특별하게 궁금한점은 없는 것 같아서 피드백은 바로 마무리하겠습니다.\n궁금한점 생기면 디스코드를 통해 언제든 문의주세요!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/40"
    }
  },
  {
    "passed": true,
    "theBest": true,
    "name": "진재윤",
    "feedback": "잘했어요 재윤! 이번 셀프회고는 너무 좋았습니다. 양도 양이지만, 내용의 깊이가 다르네요. 정말 재윤이의 생각과 철학이 담뿍 담긴 좋은 회고였습니다. \n\n특히 \"Entity = 냉장고(데이터), Features = 요리사(행동)\"에서 시작해서 \"entities = useQuery(Read), features = useMutation(CUD)\"라는 공식으로 발전시킨 과정이 인상적이었어요. \"API 함수 자체는 도구일 뿐이고, 그 도구를 어떻게 사용하는가가 진짜 행동이다\"라는 정리도 정확합니다.\n\n의존성 역전을 ESLint 규칙으로 강제한 것도 좋았어요. features에서 app을 import하면 안 되는 상황에서 Context로 인터페이스만 shared에 두고, 구현은 app에서 주입하는 패턴을 직접 적용해본 건 큰 경험입니다. \"상위 레이어가 하위 레이어의 인터페이스에 의존한다\"는 걸 몸으로 이해한 거니까요.\n\n708줄짜리 PostsManagerPage.tsx를 Phase 1부터 7까지 단계별로 진행하면서 각 단계마다 ESLint 검증을 수행한 것도 체계적이에요. 덕분에 중간에 문제가 생겨도 어느 단계에서 발생했는지 쉽게 파악할 수 있었을 거예요.\n\nQ) 회고에 작성한 내용들이 제가 이번 챕터에서 배워가야 할 것들을 제대로 짚고 넘어가고 있는 걸까요?\n\n네, 충분히 짚고 넘어갔어요. \"좋은 구조를 만들기 위해서는 좋은 분석이 먼저 필요하다\"는 결론도 정확하고, 상태를 도메인/UI/라우팅으로 구분하는 기준도 잘 잡혔습니다.\n\nQ) 디렉토리 구조가 잘 적용된 건지 피드백을 주실 수 있을까요?\n\n이건 제가 \"이렇게 해야 좋다\"라고 정해줄 수 있는 영역이 아닙니다. 대신 스스로 검증해볼 수 있는 방법을 알려드릴게요. 먼저 재윤이가 분리했던 방법을 명세화할 수 있는지 확인해보세요. \"entities에는 이런 게 들어가고, features에는 이런 게 들어간다\"를 문서로 정리할 수 있어야 해요. 그다음 그 명세에 따라 다른 실무 프로젝트에 한번 적용해보는 연습을 해보세요. 그 과정에서 막힘이 없다면, 그래서 팀원이나 다른 사람이 예측 가능하다면 좋은 코드입니다. 그리고 각 파일마다 코드의 모양이나 패턴이 유사하게 만들어진다면 좋은 코드예요. 이 검증 과정에서 AI의 도움을 받아볼 수도 있을 거예요.\n\n3챕터 동안 정말 수고했어요. 이번 경험이 내가 앞으로 만들어가는 코드나 AI가 만들어줄 코드들을 이해하고 바라보는데 더 선명한 틀과 기준이 만들어지는 시간이 되었기를 바래요. 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/36"
    }
  },
  {
    "passed": false,
    "name": "차현빈",
    "feedback": "",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": ""
    }
  },
  {
    "passed": true,
    "name": "천진아",
    "feedback": "진아님 수고하셨습니다!\n\nQ. 어떤경우에 컴포넌트에서 props로 내려받고 어떤경우에 hook으로 기능을 내부에 구현하면 좋을까요? 이번과제에서는 feature/ui, widget/ui는 모두 내부에 hook으로 함수를 호출해서 독립적인 컴포넌트가 될수있도록 만들어 주었습니다. 하지만 이렇게 하니 테스트하기가 어려워 지는게 아닌가란 생각이 듭니다.\n\nA. \n말씀하신대로 훅을 내부에서 사용하면 테스트하기 까다로워지는 부분이 있어요.\n훅은 훅대로 컴포넌트는 컴포넌트대로 테스트를 하고 컴포넌트에서는 훅을 모킹하는 형태로 테스트를 보통합니다.\n이것도 익숙해지면 사실 크게 어렵진 않은 것 같아요.\n\nFSD에는 그런 원칙은 없지만 어플리케이션의 상황에 맞게 어떤레이어는 퓨어하게 훅을 사용하지 않고,\n다른 레이어에서 주입받는 것으로 약속을 할 수도 있을 것 같아요. 필요하다면 말이죠\n\nProps는 상위 컴포넌트에서 데이터 흐름을 제어할 때 사용하고, hooks는 컴포넌트 내부 로직을 캡슐화해 재사용성을 높일 때 적합합니다. \n하지만 성능면에서도 그렇고 비지니스 로직이 필요한 곳에서 훅으로 감싼 비지니스 로직과 데이터를 사용하는 편이 좋았던 것 같습니다.\n제가 딱 뭐가 좋다 말씀을 드리기 힘들고 그때그때 마다 상황에 맞는 이유가 있다면 그 이유로 선택하면 될 것 같아요 :) \n\n\n\nQ.제가 잡은 fsd 폴더 기준이 통용적으로 사용되는 기준일까요? 아니면 실제로 제가 세운 기준과는 다르게 사용이 될까요?\n\n네 레이어야 사실 정확히 FSD에서 요구하는대로 맞춰 사용하려고 하면 오히려 FSD라는 것이 모호한 면이 있는 것 같고요\n그냥 일정한 기준을 갖고 레이어를 구분하고 각 레이어같의 의존에 방향성을 정한다 라는 컨셉만 가져가려고 노력하면 좋을 것 같아요\n중요한 것은 일관성이고요.\n\n세그먼트도 model에서 타입이나 계산로직, 비지니스로직들의 조각들이 있고\napi에서는 fetch나 update등 API와 통신하는 로직이 들어있고\n\n넵 크게 문제 없이 구성하신것 같습니다.",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/21"
    }
  },
  {
    "passed": false,
    "name": "한선민",
    "feedback": "잘했어요 선민! 셀프회고를 읽으면서 FSD를 단순히 폴더 구조로 받아들이지 않고 \"왜 이렇게 나눠야 하는지\"를 끊임없이 질문한 흔적이 느껴졌습니다.\n\n특히 유효성 검사를 어디에 둘지 고민하면서 \"어디서든 동일하게 지켜져야 하는 규칙\"과 \"어떤 타이밍에 어떻게 막을 것인가\"를 분리했다는 부분이 인상적이었어요. 이건 스스로 기준을 세우고 그 기준에 따라 일관되게 배치한 좋은 예시입니다. \"왜 이 구조를 쓰는지 설명할 수 있는 설계를 목표로 하겠다\"는 마무리도 정확히 맞는 방향이에요.\n\n다만 선민이가 느낀 \"폴더/레이어가 늘어나면서 코드가 흩어졌다는 느낌\"은 자연스러운 감각입니다. FSD가 응집도를 높여준다기보다는, 규칙을 명확히 해서 나중에 찾기 쉽게 만들어주는 거예요. 인간은 거대한 프로젝트의 세부적인 것들을 다 외우지 못하지만 규칙은 잘 외우거든요. 그래서 핵심은 경계를 고민하는 게 아니라, 규칙을 세워서 그 규칙대로만 하면 분리가 다 되느냐 아니냐를 발견하는 겁니다.\n\nQ) feature/model 훅의 책임 범위 - usePostDetail, usePostCreate처럼 상태와 행동을 함께 가지는 훅을 작성하면서 편하긴 했지만 상태가 많아질수록 다시 복잡해지는 느낌도 받았습니다. 이 정도 복잡도에서 더 나은 분리 기준이 있는지 궁금합니다.\n\n훅이 비대해지는 건 자연스러운 현상이에요. 일단은 쪼개보세요. 쪼개놓고 나면 항상 비슷한 단위, 비슷한 모양들이 보이기 시작하거든요. 그게 패턴이에요. 패턴을 발견하는 게 먼저입니다. 그러다 보면 다시 적절한 단위로 합칠 수 있는 지점이 보이고, 그때 응집도를 높일 수 있어요. 매번 이렇게 분리를 하는데 안 한고 합쳐도 모두 일관되게 만들 수 있네? 그러면 여기까지 분리는 안해도 되겠구나 하면서 적절한 크기감을 찾아가세요. 일단 분리하는 법을 이해하되 최대한 덜 분리하는 식으로 만드는게 요령입니다.\n\nQ) 유효성 검증 위치에 대한 판단 - 검증 로직을 entities(lib)로 두고, 에러 표현만 feature/ui에서 처리하는 구조를 선택했는데 실무 기준에서도 괜찮은 선택인지 궁금합니다.\n\n좋은 선택이에요. 검증 규칙 자체는 도메인 로직이니까 entities에 두고, 언제 어떻게 보여줄지는 feature에서 결정하는 게 맞습니다. 중요한 건 이 기준을 프로젝트 전체에서 일관되게 적용하는 거예요.\n\nQ) 다이얼로그 제어 방식 - JSX 조건부 렌더링을 줄이기 위해 다이얼로그 상태를 훅으로 감싸는 방식을 선택했는데, 이 방식이 오히려 추상화를 과하게 만든 건 아닌지도 궁금합니다.\n\n과하지 않아요. 오히려 좋은 방향입니다. 다이얼로그 열림/닫힘이 여러 곳에서 제어되면 버그 추적이 어려워지거든요. 한 곳에서 관리하는 게 맞습니다.\n\n3챕터 동안 수고했어요. 스스로 기준을 세우고 그 기준을 설명할 수 있게 된 것, 그게 이번 과제의 가장 큰 수확입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/15"
    }
  },
  {
    "passed": true,
    "name": "한세준",
    "feedback": "안녕하세요 세준님! 8주차 과제 잘 진행해주셨군요 ㅎㅎ 고생하셨습니다!!\n\n다만 특별하게 궁금한점은 없는 것 같아서 피드백은 바로 마무리하겠습니다.\n궁금한점 생기면 디스코드를 통해 언제든 문의주세요!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/3"
    }
  },
  {
    "passed": true,
    "name": "현채은",
    "feedback": "채은님 고생하셨어요!\n건강 이슈가 있으셨지만, 과제는 그럼에도 잘 마무리해주셨네요 ㅎㅎ\n\n내부 작성해주신 코드를 보면요.\n\nsrc/entities/post/api/hooks.ts를 보면 post와 user의 api를 모두 호출하는 그림인데요. 이렇게 되면 엔티티에서 다른 엔티티의 api를 참조하는 그림이니 의존 방향을 위배하는 경우가 발생할 것 같아요 ㅠㅠ \n\nsrc/features/post/filter/ui/TagFilter.tsx에서도 피처에서 피처를 참조하는 그림인것 같구요.\n\n이런 부분은 나도모르게 실수하곤 하는데, FSD의 입장에서는 가장 중요한 부분이니 꼭 린트같은 도구를 활용해서 실수를 찾아내시면 좋을것 같아요.\n\n> Widget과 Feature의 경계: PostsTable처럼 entities와 features를 조합하는 컴포넌트를 widget으로 분류했는데, 이 기준이 적절한지 피드백 부탁드립니다.\n\n저는 좋은것 같아요. 지금 피처와 피처의 조합이 사용되는 컴포넌트를 위젯으로 분리한 형태인데요. 저는 이런 형태로 실제 회사에서 많이 사용하는 중입니다. 위젯이라는 영역 자체가 명확한건 정말 명확한데, 그 명확한것들을 제외하면 너무 모호한 지점이라 생각하거든요. 하지만, 지금처럼 이런 방식으로 활용한다면 FSD의 규칙을 어기지 않고 목적에 맞춰 잘 활용했다고 생각합니다.\n\n> Zustand Store 분리 단위: 현재 searchStore, filterStore, paginationStore, postDialogStore, userModalStore로 나눴는데, 너무 세분화된 건 아닌지 궁금합니다. 혹은 더 합치거나 나눠야 할 부분이 있을까요?\n\n세분화를 잘 하셨다고 생각은 하는데요! 결국 이 부분은 저번주에 공부하셨던 단일 책임과 어느정도의 파일 추상화를 가질것인가에 이어지는 내용인 것 같은데요. 동일하게 설명을 해주셨을 것 같지만, 변경의 빈도와 범위가 비슷한 코드들을 함께 모으고 관리하는 지점을 찾아내는게 핵심인 것 같아요. 저도 늘 어려운데요. 우선은 처음부터 너무 잘게 쪼개면 과한 추상화가 되니 분류를 적절하게 하고 점진적으로 개선해나가는게 좋다고 생각해요.\n\n> TanStack Query 키 설계: 계층적 키 구조가 실무에서도 일반적으로 사용되는 패턴인지, 혹시 더 나은 방법이 있다면 알려주시면 감사하겠습니다.\n\n넵 잘 해주셨어요! 이런 것들을 명확하게 관리하기 위해 별도 유틸함수를 만들거나 쿼리 키 팩토리 함수 라이브러리를 사용하곤 하는데요. \n\nhttps://github.com/toss/frontend-fundamentals/discussions/7 \n요거를 참고해보셔도 좋을것 같아요!\n\n(기다렸는데 추가 회고는 없는거 같아서 마무리할게여 ㅎㅎㅎ)\n고생하셨고 다음주도 화이팅입니다~~",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/26"
    }
  },
  {
    "passed": true,
    "name": "황준태",
    "feedback": "고생하셨습니다 준태님 ㅎㅎ \n전반적으로 너무 잘 구현해주셨고, 특별히 FSD 규칙에 어긋나도록 구현해주신 부분은 없어보여요 :+1\nPostTable이 뜻하지 않게 비대해지는 부분은 없지 않아 있지만, 전반적으로 잘 해주셨습니다ㅎㅎㅎ\n\n> useQuery 사용과 관련해서 아래 두 가지 방식 중 어떤 방식이 더 좋을지 고민이 됩니다. 순수 UI 컴포넌트들을 제외한 나머지 컴포넌트에서는 useQuery를 사용하면 될까요?\n\n탠스택 관점에서는 어느 컴포넌트에서도 선언적이게 접근하도록 하니, 각 컴포넌트에서 선언하도록 하는게 좋다고 할 것 같은데요.\n음..! 하지만 결국 이건 컴포넌트를 구성하는 이야기로 이어질 것 같아요.\n데이터를 각 컴포넌트에서 페칭을 하다가 UI역할을 하는 컴포넌트에서 호출을 하게 되면 재사용성이 떨어지는 컴포넌트를 구성하게 될수도 있구요. 테스트가 어려워지는 단점도 발생하죠. 그 관점에서는 적절한 위치에서 b방식을 사용하게 되는게 좋지 않을까 싶어요. \n고로 딱 떨어지는 정답은 없지만, 테스트를 구성하기 용이한 재사용이 가능한 컴포넌트를 구성하기 위한 적절한 위치를 찾는다 로 정리해볼법한것 같아요.\n\n> 여러 개의 도메인이 존재하는 웹 서비스에서, 2-3개의 도메인에서만 쓰이는 컴포넌트들이 많아진다면 이러한 컴포넌트들은 전부 widgets 폴더에 두어야할까요? widgets폴더가 너무 비대해질까봐 고민입니다!\n\n그것이 FSD의 규칙이라면 앱의 특징에 따라 비대해지면 될 것 같아요 ㅎㅎ\n사실 꽤 규모있는 앱들을 운영해봤지만 위젯 자체가 비대해지는 경험들은 많이 없었던 것 같아요. 걱정은 따로 안하셔도 괜춘습니다 ㅎㅎ\n자연스럽게 피처, 앱들이 비대해질거에요.\n\n고생하셨고 다음주도 화이팅입니다!",
    "assignment": {
      "name": "STEP16 프론트엔드 아키텍처 설계 및 디자인 시스템 심화과제",
      "url": "https://github.com/hanghae-plus/front_7th_chapter3-3/pull/22"
    }
  }
]